{"meta":{"title":"Brief Candle","subtitle":"Unterm Rad","description":"Planet earth is blue, and there is nothing I can do.","author":"Kiman Yang","url":"https://kimanyang.xyz","root":"/"},"pages":[{"title":"文章归档","date":"2022-03-09T07:13:15.346Z","updated":"2022-03-09T07:06:47.634Z","comments":true,"path":"archive.html","permalink":"https://kimanyang.xyz/archive.html","excerpt":"","text":""}],"posts":[{"title":"一个短篇","slug":"一个短篇","date":"2022-09-24T15:54:46.000Z","updated":"2022-09-25T06:16:41.337Z","comments":true,"path":"2022/09/24/一个短篇/","link":"","permalink":"https://kimanyang.xyz/2022/09/24/%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%AF%87/","excerpt":"","text":"一个短篇 分享一首歌的歌词，腰乐队，收錄於2014年專輯《相見恨晚》。 那个时代有些东西已经显露出端倪，但是他们靠着对未来无休止贪婪的索取延续到了今天，正如歌词所说——“這夜派對 就要散場”，这个散场今天才迟迟到来，而我们仍然同当初一样静默，结束的派对留下一地烂摊。在与这现实缠斗的痛苦过程中我们仍然要迎接明天的到来，在烂摊子里担负起对后来者责任。 尽管已经不抱任何信任，但还是希望独夫在高级堡垒里的大会之后能够多少回味起它的一丝良心，不然的话我们终将被沉默中必将到来的灭亡所掩埋。 旋轉 跳躍喔 他感到每條路都在頭痛 新鮮的Patrick滿腦子 都是開拓的自慰器 那些男人愛的男人愛市政 市政愛市民 市民愛流連 旋轉 跳躍喔 他感到飛鳥們也在頭痛 冒牌的Patrick滿腦子 都是穩妥的獨角戲 那些男孩愛的男人愛機器 機器愛法律 法律是你 深夜裡辛蒂蕾拉們倒下的地方 促成整片血紅的高樓 在搞與不搞之間泛起淡淡的哀傷 他的來頭已經腐朽 別擔心沒有哪一首歌能夠 把這個現實唱到地獄去 當你還能享有這種靜默我的老爺 這爛攤就不會收場 旋轉 跳躍吧 他感到連晚風也在頭痛 狗娘養的Patrick滿腦子 關於體態的滑翔機 他說過那些女人愛的男人愛蘿莉 蘿莉愛包包 包包愛貨幣 他在高級堡壘的方陣裡走出 帶來大會的消息 在幼犬和地皮商的征程裡 他是發達的肯定句 等他和他們 他們和所有人之間都搞不來信任的時候 只有冬和她的姨媽從沒有熄燈的視窗 無聲眺望 這夜派對 就要散場 幽暗的最高頻道還在 為全城遮蓋下一百年的昂貴謎底 他倚靠在令人害羞的禮品堆裡 冉冉睡去 幽暗的最高頻道還在 為全城遮蓋下一百年的昂貴謎底 他倚靠在令人害羞的禮品堆裡 冉冉睡去 幽暗的最高頻道還在 為全城遮蓋下一百年的昂貴謎底 他倚靠在令人害羞的禮品堆裡 冉冉睡去","categories":[{"name":"散文","slug":"散文","permalink":"https://kimanyang.xyz/categories/%E6%95%A3%E6%96%87/"}],"tags":[{"name":"散文","slug":"散文","permalink":"https://kimanyang.xyz/tags/%E6%95%A3%E6%96%87/"}]},{"title":"基于`colly`的本子爬虫实现","slug":"基于colly的本子爬虫实现","date":"2022-09-11T02:23:24.000Z","updated":"2022-09-11T02:37:06.256Z","comments":true,"path":"2022/09/11/基于colly的本子爬虫实现/","link":"","permalink":"https://kimanyang.xyz/2022/09/11/%E5%9F%BA%E4%BA%8Ecolly%E7%9A%84%E6%9C%AC%E5%AD%90%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"基于colly的本子爬虫实现这篇文章主要是来介绍下自己整活的小项目Youngkingman&#x2F;gentlemanSpider: 基于colly，支持标签(xp)筛选和多线程加速的绅士漫画爬虫优雅实现 (github.com)。 基本用途： 爬取并保存网站 绅士漫画 的本子&#x2F;色图（大陆用户要求在梯子的环境下使用） 支持按照配置进行多线程(协程)加速 支持按照配置对个人喜好的xp标签进行过滤（可用标签在项目下的activeTags文件夹中可查看） 这个小项目里主要学习了以下的东西： colly库的基本使用。官方教程虽然都是英文的，没有python那么多中文教程，但是例子还挺完善的，照着基本能学下来，也巩固了一下CSS选择器（虽然还是要用得查的程度） docker的一些网络构建。如何多阶段构建以及如何容器与宿主机共享网络 如何直接用github发布使用自己的包。以前没注意过，现在发现只要在githbub上就是无脑发布了，还挺不错的 如何进行并发的控制。这个项目以及上一个聊天室项目里我把并发控制相关的知识很好地应用了一遍（不再是没有实际用处的demo例题或者仅仅八股文），包括了读写锁&#x2F;并发安全集合实现&#x2F;管道控制并发&#x2F;waitGroup的等待控制等等，以及相关最佳实现，例如： 使用一个结构体管理大部分与并发相关的数据结构 尽可能地在函数外实现并发（这一点还是没有完全实现，在cooridnator结构里的并发数目仍然在各个函数内） 不要暴露管道给外部，仅仅提供通过管道传递信息的方法。这种做法防止了管道的滥用，即使是单向管道暴露给外部仍然具有语义上的模糊性 使用空结构体struct&#123;&#125;控制并发。在limitChannel中使用了空结构体来控制goroutine的创建数量（注意非运行数量），这样可以一定程度减少调度器的负担，使得程序即使在配置较低的机器上也能较为流畅地运行。 当然实际运行起来也是相当给力的: 硬盘的消耗速度非常快，程序也能够稳定运行，作为仓鼠癖患者属实非常快乐了。","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"爬虫","slug":"爬虫","permalink":"https://kimanyang.xyz/tags/%E7%88%AC%E8%99%AB/"},{"name":"colly","slug":"colly","permalink":"https://kimanyang.xyz/tags/colly/"}]},{"title":"Go几个同步原语的解析笔记","slug":"Go几个同步原语解析笔记","date":"2022-09-01T12:32:24.000Z","updated":"2022-09-01T12:37:26.293Z","comments":true,"path":"2022/09/01/Go几个同步原语解析笔记/","link":"","permalink":"https://kimanyang.xyz/2022/09/01/Go%E5%87%A0%E4%B8%AA%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Go几个同步原语的解析笔记同步的基本原语： sync.Mutex 互斥锁 sync.RWMutex 读写锁 sync.WaitGroup sync.Once sync.Cond 条件变量 上述原语较为原始，大部分时候应该选择channel进行并发编程 sync.Mutex互斥锁的基本结构： 1234type Mutex struct &#123; state int32 sema uint32&#125; 其中的state变量共32位四字节，结构为： 低1位：mutexLocked表示互斥锁是否被锁定 低2位：mutexWoken 表示从正常模式唤醒 低3位：mutexStarving 表示当前互斥锁进入饥饿状态 高29位：waitersCount 当前互斥锁上等待的Goroutine个数 关于饥饿模式与正常模式：正常模式goroutine先进先出竞争锁，一旦有某些Goroutine超过1ms都没拿到锁（虽然是雪菜先来的，但是新建的冬马goroutine更会抢），那它就把锁切换到饥饿模式，这时锁直接给队头，其它的goroutine别抢 互斥锁的加锁采用了CAP和自旋两个步骤： 1234567func (m *Mutex) Lock() &#123; // CAP 参数为 target_addr expeted_val new_val if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) &#123; return &#125; m.lockSlow()&#125; 其中lockerSlow()包含一个非常复杂的for循环： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func (m *Mutex) lockSlow() &#123; var waitStartTime int64 starving := false awoke := false iter := 0 old := m.state for &#123; // 进入循环条件的判断，要求为普通模式(mutexStarveing位与0) // 要求runtime.sync_runtime_canSpin()返回true，即： // 1.多cpu机器上才可自旋 2.iter小于4次 3.存在一个正在运行的P(GMP模型)且队列为空 if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123; if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp; atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123; // 唤醒当前锁 awoke = true &#125; // 进行自旋，一段汇编实现的自旋流程 runtime_doSpin() iter++ old = m.state continue &#125; // 结束自旋或者根本就不能自旋，开始更新锁的状态 new := old if old&amp;mutexStarving == 0 &#123;// 非饥饿状态，新的进行锁定 new |= mutexLocked &#125; if old&amp;(mutexLocked|mutexStarving) != 0 &#123;// 锁定或者饥饿状态,进入等待队列+1 new += 1 &lt;&lt; mutexWaiterShift &#125; if starving &amp;&amp; old&amp;mutexLocked != 0 &#123;// 饥饿且没有锁定，进入饥饿状态 new |= mutexStarving &#125; if awoke &#123;// 有点迷惑 new &amp;^= mutexWoken &#125; if atomic.CompareAndSwapInt32(&amp;m.state, old, new) &#123;// 发生变化,CAS if old&amp;(mutexLocked|mutexStarving) == 0 &#123; break // 通过 CAS 函数获取了锁 &#125; ... runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1) starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs old = m.state if old&amp;mutexStarving != 0 &#123; delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift) if !starving || old&gt;&gt;mutexWaiterShift == 1 &#123; delta -= mutexStarving &#125; atomic.AddInt32(&amp;m.state, delta) break &#125; awoke = true iter = 0 &#125; else &#123; old = m.state &#125; &#125;&#125; 解锁相对简单： 1234567891011121314151617181920212223242526272829func (m *Mutex) Unlock() &#123; new := atomic.AddInt32(&amp;m.state, -mutexLocked)//mutexLocked -1为0成功解锁 if new != 0 &#123; m.unlockSlow(new) &#125;&#125;func (m *Mutex) unlockSlow(new int32) &#123; // 如果已经被解锁过了那就是异常，同时被解锁两次 if (new+mutexLocked)&amp;mutexLocked == 0 &#123; throw(&quot;sync: unlock of unlocked mutex&quot;) &#125; if new&amp;mutexStarving == 0 &#123; // 正常模式 old := new for &#123; if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 &#123;// 如果没有等待者或者处于locked/woken/starving之一，可以直接跑路不管 return &#125; new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt32(&amp;m.state, old, new) &#123; //存在等待者，唤醒等待者移交锁的权力，大家开始抢锁（大选） runtime_Semrelease(&amp;m.sema, false, 1) return &#125; old = m.state &#125; &#125; else &#123; // 饥饿模式，直接移交权力给下一位（钦定），不退出饥饿状态 runtime_Semrelease(&amp;m.sema, true, 1) &#125;&#125; sync.RWMutex 读写锁基于Mutex进行更加细粒度的拆分，支持多读，不支持同时读写和多写。基本结构如下： 1234567type RWMutex struct &#123; w Mutex // 复用互斥锁 writerSem uint32 // 等待写信号量 readerSem uint32 // 等待读信号量 readerCount int32 // 当前读操作goroutine数量 readerWait int32 // 当前写操作时被阻塞的读goroutine数量&#125; 读写锁封装的方法主要有： 写操作：sync.RWMutex.Lock()&#x2F;sync.RWMutex.Unlock() 读操作：sync.RWMutex.RLock()&#x2F;sync.RWMutex.RUnlock() 写锁加锁操作：类似于互斥锁，使用互斥锁阻塞写操作，同时使用信号量阻塞读操作，如果仍然有持有读锁的goroutine那就进入休眠状态等待所有读锁先释放再继续操作。 写锁释放操作：将readerCount由原子操作变为正数释放读锁；for循环通过信号量唤醒所有读锁等待中的goroutine；最后释放互斥锁允许写操作 读锁加锁操作：原子操作将readerCount加一，如果返回负数则无法操作，直接休眠，非负数就无所谓。 读锁释放操作：尝试把readerCount减一，返回大于等于零就成功，否则存在正在执行的写操作进入rUnlockSlow，减1等待写操作释放的readerWait，若减到0则触发信号量尝试唤醒写锁。 sync.WaitGroup 等待组常见的使用场景是发出一组并行的I/O请求等待其执行完毕返回，因为串行执行的时间成本过高，这类请求包括网络连接&#x2F;文件读写等等，常见用法： 12345678910wg := &amp;sync.WaitGroup&#123;&#125;;ioReqs := []*IORequest&#123;...&#125;wg.Add(len(ioReqs))for _, req := range ioReqs &#123; go func(r *IORequest) &#123; defer wg.Done() //iorequest do something &#125;(req)&#125;wg.Wait() //阻塞 基本结构： 1234type WaitGroup struct &#123; noCopy noCopy //保证不会因为再赋值被拷贝 state1 [3]uint32 //与状态有关的信号量&#125; 暴露的三个基本接口包括Done&#x2F;Add&#x2F;Wait，下面看看其具体实现： 123456789101112131415161718192021222324252627282930313233func (wg *WaitGroup) Add(delta int) &#123; statep, semap := wg.state() state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32) v := int32(state &gt;&gt; 32) w := uint32(state) if v &lt; 0 &#123; // 不可传入负数 panic(&quot;sync: negative WaitGroup counter&quot;) &#125; if v &gt; 0 || w == 0 &#123; return &#125; *statep = 0 for ; w != 0; w-- &#123;// 唤醒等待状态的`goroutine` runtime_Semrelease(semap, false, 0) &#125;&#125;func (wg *WaitGroup) Wait() &#123; statep, semap := wg.state() for &#123; state := atomic.LoadUint64(statep) v := int32(state &gt;&gt; 32) if v == 0 &#123; return &#125; if atomic.CompareAndSwapUint64(statep, state, state+1) &#123; runtime_Semacquire(semap) if +statep != 0 &#123; panic(&quot;sync: WaitGroup is reused before previous Wait has returned&quot;) &#125; return &#125; &#125;&#125; sync.Once 只做一次该同步原语最常见的场景就是优雅实现懒汉式单例（不用手写两次if），当然其内部采用的也仍然是锁+原子操作来实现。使用场景如下： 12345678var something Somethingvar o sync.Oncefunc GetSomething() *Something &#123; o.Do(func()&#123; // init somthing, only init once &#125;) return &amp;something&#125; 通常这个something会是数据库连接内存池之类的全局可用重资源。下面看看具体实现： 123456789101112131415161718type Once struct &#123; done uint32 m Mutex&#125;func (o *Once) Do(f func()) &#123; if atomic.LoadUint32(&amp;o.done) == 0 &#123;// 原子操作看看是否已经进入过，即第一个if o.doSlow(f) //可能有多个goroutine进入 &#125;&#125;func (o *Once) doSlow(f func()) &#123; o.m.Lock()// 尚未进入过则加锁开始执行，此处可能有多个`goroutine`到达 defer o.m.Unlock() if o.done == 0 &#123;// 二次if，确保拿到锁的goroutine是第一个到达的 defer atomic.StoreUint32(&amp;o.done, 1)// 置1，后面拿到锁的goroutine就不会进来这里了 f() &#125;&#125; sync.Cond 条件变量该原语让一组goroutine在满足条件时被唤醒，在个人项目聊天室里用管道实现了房间的广播器，其具体实现其实也可以通过条件变量。通常条件变量需要和锁配合使用，基本上很少用到就展现一下例程： 123456789101112131415161718192021222324252627282930var status int64func main() &#123; c := sync.NewCond(&amp;sync.Mutex&#123;&#125;) for i := 0; i &lt; 10; i++ &#123; go listen(c) &#125; time.Sleep(1 * time.Second) go broadcast(c) ch := make(chan os.Signal, 1) signal.Notify(ch, os.Interrupt) &lt;-ch&#125;func broadcast(c *sync.Cond) &#123; c.L.Lock() atomic.StoreInt64(&amp;status, 1) c.Broadcast() c.L.Unlock()&#125;func listen(c *sync.Cond) &#123; c.L.Lock() for atomic.LoadInt64(&amp;status) != 1 &#123; c.Wait() &#125; fmt.Println(&quot;listen&quot;) c.L.Unlock()&#125; 每次对于条件得读取都要进行锁的获取防止race，在broadcast方法执行后listen子协程才能进入打印段。如果采用的不是c.Broadcast()而是c.Signal()则唤醒队列最前的goroutine。相比于单纯的for循环忙等待，条件变量直接通过runtime让出处理器权力不至于多次空转，效率相对较高一些(goroutine调度效率本身就很高了大部分时候不需要进一步做这种优化）。 使用SingleFlight来防止缓存击穿这里顺手复习一下击穿和雪崩的区别——击穿是指内容尚未读到缓存(Redis或者进程内缓存)中而同时有大量请求直接指向数据库的同一个内容，这会导致数据库的瓶颈，解决方法当然也可以预先将所有接口热点数据读到Redis中永不过期，但更多使用SingleFlight。雪崩则是指Redis或进程内缓存数据同时过期挂掉导致整个应用访问变慢，解决方法是设置一个随机范围的过期时间防止突然崩溃。剩下的缓存穿透则是指数据不可能获取但还是会去数据库请求，这种则使用布隆过滤器解决。 对于同一个键值对的多次请求采用SingleFlight来防止缓存击穿 12345678910111213141516171819type service struct &#123; requestGroup singleflight.Group&#125;func (s *service) handleRequest(ctx context.Context, request Request) (Response, error) &#123; v, err, _ := requestGroup.Do(request.Hash(), func() (interface&#123;&#125;, error) &#123; rows, err := // select * from tables if err != nil &#123; return nil, err &#125; return rows, nil &#125;) if err != nil &#123; return nil, err &#125; return Response&#123; rows: rows, &#125;, nil&#125;) 在这里我们定义了一个请求的哈希用于辨识请求的唯一性，相同的请求只会做一次，有效避免缓存击穿。具体结构如下： 1234567891011121314type Group struct &#123; mu sync.Mutex m map[string]*call&#125;type call struct &#123; wg sync.WaitGroup val interface&#123;&#125; err error dups int chans []chan&lt;- Result&#125; 其中的互斥锁和调用体，具体的Do/DoChan接口实现： 1234567891011121314151617181920212223242526272829303132333435363738func (g *Group) DoChan(key string, fn func() (interface&#123;&#125;, error)) &lt;-chan Result &#123; ch := make(chan Result, 1) g.mu.Lock() // map查询需要锁 if g.m == nil &#123; g.m = make(map[string]*call) &#125; if c, ok := g.m[key]; ok &#123;// 如果已经存在 c.dups++ // 重复请求加一 c.chans = append(c.chans, ch)// 接受管道加入请求数组 g.mu.Unlock()// 等待所有人 // c.wg.Wait() // 如果式 Do 这里需要等待执行完成 return ch &#125; c := &amp;call&#123;chans: []chan&lt;- Result&#123;ch&#125;&#125; c.wg.Add(1) g.m[key] = c g.mu.Unlock() go g.doCall(c, key, fn) // 执行请求 // 如果是do的话则同步执行 /* g.doCall(c, key, fn) return c.val, c.err, c.dups &gt; 0 */ return ch&#125;func (g *Group) doCall(c *call, key string, fn func() (interface&#123;&#125;, error)) &#123; c.val, c.err = fn() // 实际执行函数 c.wg.Done() g.mu.Lock() delete(g.m, key) for _, ch := range c.chans &#123; // 释放所有重复请求并返回结果 ch &lt;- Result&#123;c.val, c.err, c.dups &gt; 0&#125; &#125; g.mu.Unlock()&#125; 返回结构还得再接口断言一下。如果这个请求不怎么耗时就同步，很耗时就异步。","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://kimanyang.xyz/tags/golang/"},{"name":"并发编程","slug":"并发编程","permalink":"https://kimanyang.xyz/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://kimanyang.xyz/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"读写锁","slug":"读写锁","permalink":"https://kimanyang.xyz/tags/%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"条件变量","slug":"条件变量","permalink":"https://kimanyang.xyz/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"}]},{"title":"Go并发相关的一些碎碎念","slug":"Go并发编程的知识点总结","date":"2022-08-15T05:42:24.000Z","updated":"2022-08-15T05:50:35.492Z","comments":true,"path":"2022/08/15/Go并发编程的知识点总结/","link":"","permalink":"https://kimanyang.xyz/2022/08/15/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"Go并发相关的一些碎碎念在实践中遇到的一些问题，不够全面，只是个人的一个巩固总结。 单例模式两种实现： 饿汉式：简单，但是调用开销大 123456789101112package singletontype singleton struct &#123; count int&#125;var Instance = new(singleton)func (s *singleton) Add() int &#123; s.count++ return s.count&#125; 懒汉式：写起来复杂，可能有多个goroutine（线程）同时创建该单例所以有同步问题（该问题仅仅在创建时有可能出现），但是开销相对较小。又分为一般的懒汉式和double check的懒汉式，后者在创建后就可以不再使用锁了，进一步降低了调用开销。 123456789101112131415161718192021222324252627282930313233343536373839404142package singletonimport ( &quot;sync&quot;)type singleton struct &#123; count int&#125;var ( instance *singleton mutex sync.Mutex)//单次检查模式func New() *singleton &#123; mutex.Lock() if instance == nil &#123; instance = new(singleton) &#125; mutex.Unlock() return instance&#125;//double check模式func NewDC() *singleton &#123; if instance == nil &#123; // 第一次检查 // 这里可能有多于一个 goroutine 同时达到 mutex.Lock() // 这里每个时刻只会有一个 goroutine if instance == nil &#123; // 第二次检查 instance = new(singleton) &#125; mutex.Unlock() &#125; return instance&#125;func (s *singleton) Add() int &#123; s.count++ return s.count&#125; 关于goroutine的最佳实践小思考 一个最佳实践：应该让函数的调用者自行决定是否需要并发执行，每新开一个goroutine都必须知道它什么时候会停止。每次写出go Somefunc()之前必须搞清楚什么时候这个函数会被终止以及怎么样终止。 time.After()相关的内存泄漏：该函数等待一段时间返回一个只读的通道传送触发的时间，如果在等待时间内goroutine退出了，此时该通道不会被GC回收，同时你又没有任何途径去读取该通道将其释放，于是会造成内存泄漏。解决方法：1.要么注意这段时间内goroutinue一定不会退出 2.要么使用time.NewTimer() 并记得退出的时候关闭，具体如下： 12345678910111213func() process() &#123; idleDuration := 5 * time.Minute idleDelay := time.NewTimer(idleDuration) defer idleDelay.Stop() //...处理并发的逻辑，可能涉及 /*select&#123; case &lt;- idleDelay.C: dosomething() case &lt;- somethingCouldDone() &#125; */ //...... return&#125; channel阻塞造成的内存泄漏：比如你的管道一直在被for-range读并且阻塞着，但是你又不去关闭它或者发送一方不会发送数据但你一直在阻塞等待&lt;- readCh，那么管道就会一直占用内存资源直到程序退出 channel的一些碎碎念生产消费模型的良好抽象我们希望某一个实例所持有的所有管道的生产与消费操作都完全由该实例完成，那么如果这个实例作为： 生产者： 自身持有一个包装为函数的close(ch)方法在生产结束时进行关闭，操作关闭的对象可以是自身也可以是其他对象，但是编程时必须关注这一点(因为关闭操作只能由发送方进行，对应只能对双向和只发送管道执行close) 往管道中添加数据并不直接访问管道本身进行操作，而是包装成一个方法，显示生产者对管道的持有与管理，限制对管道的滥用 消费者： 一般消费者都持有一个死循环&#x2F;对管道的遍历&#x2F;for与select组合，用于对读出数据的处理，同样这些应当包装为对应处理对象所持有的函数，大部分时候生产消费者模型的处理过程都在这一步进行 通过无缓冲管道实现同步的处理两个无缓冲管道ch1和ch2，两个协程goroutine A和goroutine B，ch1由A-&gt;B发送数据，B进行处理后立刻把结果从ch2由B-&gt;A发送数据，只要两个管道都是无缓冲的，那么协程A拿到的结果就是它刚刚发送出去的，但是如果加了缓冲同时存在协程C且C提前向B发送了数据，那么A就有可能拿到B对C数据的处理结果造成混乱，这点小细节要注意下 管道关闭后的发送数据及接收数据情况管道关闭后接收方还能持续获取信息直到重复获得一个零值，for range语法下会跳出，但我们也无法从接收方判断管道是否被关闭。发送方重复关闭一个管道会panic，对于一个nil管道进行关闭也会panic 管道可能造成的goroutine泄露如果一个生产者开了goroutine通过某个管道发送数据，但是对应管道的接收者跑路直接退出了会造成泄露，解决方法是确保管道会被关闭并且在接收端使用for range，确切的方法还得具体问题具体分析（还没有设计过太多的并发呜呜呜）。 在select场景下如果没有搭配for使死循环用，那么需要很谨慎地思考如果一个管道得到返回之后退出其他管道是否还能被接受，如果不能那么它们的发送者goroutine就可能发生泄漏。select如果想要无阻塞那么可以使用default。 Goroutine和线程的一些区别这一点更加详细的GMP模型的文章已经写过了。这里做些补充，我们都知道goroutine运行在用户态，和操作系统线程不同，而且量远远大于操作系统的线程。操作系统线程的栈大小是固定的（可能是2MB），这种大空间对于小小的协程来说是种浪费，所以一个goroutine栈是动态伸缩的，开始会2KB左右，最大甚至可能1GB。 goroutine是绑定在操作系统线程上 执行的，这个操作系统线程一般被称为P，大量的goroutine绑定在P上执行，但是goroutine本身的调度并不需要进入内核态，切换效率会高很多。 goroutine在设计上让应用程序编写者不能获取其索引，即没有特定的id号。这鼓励程序员尽量不要关心并发协程的调度过程从而搞出一堆黑魔法，而是专注于并发本身的逻辑。","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://kimanyang.xyz/tags/golang/"}]},{"title":"Go语言`sqlx`库使用总结","slug":"sqlx库使用的一些总结","date":"2022-08-08T15:43:24.000Z","updated":"2022-08-08T15:44:39.152Z","comments":true,"path":"2022/08/08/sqlx库使用的一些总结/","link":"","permalink":"https://kimanyang.xyz/2022/08/08/sqlx%E5%BA%93%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"Go语言sqlx库使用总结思考再三决定还是不打算在项目中采用ORM的方式，仅仅使用sqlx库来完成与数据库的链接操作。在这里总结一下文档介绍的使用方法以及我在项目中对该库进行的一些简单二次封装。本文使用的时mysql的驱动，该库同样也支持其他数据库驱动。 起步与设计在初始化时命令行执行如下命令： 12go get github.com/go-sql-driver/mysqlgo get github.com/jmoiron/sqlx 我习惯将mysql&#x2F;redis以及一些进程内的缓存包装到项目下的pkg/dbutil文件夹中，作为相关插件的具体逻辑实现，然后再将与数据库相连接的具体对象放到全局包之中进行访问：对于mysql数据库而言就是sqlx的DB对象；对于redis则是redis-client对象；对于进程内缓存则是并发安全的map的抽象接口；对于云服务器数据库则是合法的访问链接，不同的厂商代码不一样。 经过设计的任意单体项目的基本结构如下： 12345678910\\---project | initSetting.go /*一些初始化配置（包括数据库初始化）*/ | main.go /*项目入口*/ | +---global | db.go /*全局数据库变量*/ | setting.go /*全局设定（包括数据库配置）*/ | \\---pkg \\---dbutil /*数据库相关逻辑*/ 当然这只是一种抽象方法，也有些人喜欢用Java类似的那一套疯狂依赖注入层层抽象来获取对象，然后懒汉饿汉式单例模式或者接口抽象约束多次包装只能工厂模式访问数据库(对于一定会被访问的数据库这么做只会让你的代码变得啰嗦)，但gopher大道至简就一个单例全局即可。由于全局的数据库变量var db *sqlx.DB会自己维护一个连接池，所以我们并不需要关心并发的问题，直接访问并使用即可。 配置相关数据库的配置注入采用了如下的结构： 1234567891011type DatabaseSettingS struct &#123; DBType string UserName string Password string Host string DBName string TablePrefix string Charset string MaxIdleConns int MaxOpenConns int&#125; 具体的注入配置方法不同的人喜欢不同的库，在这里我使用的是viper库。具体看每一个字段： DBType:这个字段设为mysql，当然也可以是其他的，提高项目的一个可扩展性 UserNmae~DBName：配置用户名&#x2F;密码&#x2F;Host地址（这个带端口号，因为没有专门弄个port出来）&#x2F;数据库名 TablePrefix:部分安全考虑部分便捷考虑，和项目相关的数据库表会加上一个前缀，这个前缀在具体的sql语句中变为#__然后再被dbutil中的相关方法替换为真正的语句，能够防止一部分sql注入，同时针对不同项目的表的一些相同操作可以复用代码而仅仅单纯替换前缀的配置 Charset字符集，设置为utf8 MaxIdleConns和MaxOpenConns两个参数和我们之前提到的数据库连接池有关，设置最大的挂起连接数和最大的开放连接数，分别通过调用DB.SetMaxIdleConns(n int)和DB.SetMaxOpenConns(n int)来实现 这里给出我们如何创建一个数据库的连接的代码： 1234567891011121314151617181920212223242526func New(config *setting.DatabaseSettingS) (db *sqlx.DB, err error) &#123; var dbonce sync.Once dbonce.Do(func() &#123; // ：&quot;用户名:密码@tcp(IP:端口)/数据库?charset=utf8&quot; db, err = sqlx.Open( config.DBType, fmt.Sprintf( &quot;%s:%s@tcp(%s)/%s?charset=%s&quot;, config.UserName, config.Password, config.Host, config.DBName, config.Charset, ), ) if err != nil &#123; log.Printf(&quot;get mysql database error: %s&quot;, err) &#125; else &#123; db.SetMaxIdleConns(config.MaxIdleConns) db.SetMaxOpenConns(config.MaxOpenConns) db.Mapper = reflectx.NewMapperFunc(&quot;json&quot;, strings.ToLower)//之后解释这行代码 &#125; &#125;) return&#125; CRUD BOY具体怎么用sqlx工作这一节主要讲怎么通过sqlx库自己写sql语句进行苦逼的增删改查，成为一颗合格的crud螺丝钉，覆盖了一些常见的业务场景 查询接口罗列一些接口，这些接口我 不会 在项目中直接使用，一方面是包装简陋使用起来很复杂，一方面是存在需要自己把握的sql注入问题的避免。 Query(...) (*sql.Rows, error)单行查询适配原始sql库接口 QueryRow(...) *sql.Row 多行查询适配原始sql库接口 Queryx(...) (*sqlx.Rows, error)单行查询二次包装 QueryRowx(...) *sqlx.Row多行查询二次包装 查询时使用sqlx库的正确方式是如下两个接口，这是该库独有的语法： Get(dest interface&#123;&#125;, ...) error 单行查询，可以直接实现类似于对象关系映射的功能，具有参数化查询接口 Select(dest interface&#123;&#125;, ...) error 多行查询，直接获取一个对象数组，比原始的多行查询需要的代码大大减少 何为参数化：参数化就是将sql语句中的具体参数替换为某个符号，在进行执行的时候预编译进行替换检查然后再交由数据库连接去执行，是规避sql注入的常用手段之一，具体为什么可以看下一小节的例子 MySQL使用符号? PostgreSQL 使用迭代的参数即$1``$2 SQLite兼容上述两位，可以用?和$1 Oracl 使用符号:name 你在使用到sql语句带有IN条件时你会用到”IN (?)”这样的例子，后面的具体参数应该是一个golang切片，如： 12var levels = []int&#123;4, 6, 7&#125;rows, err := db.Query(&quot;SELECT * FROM users WHERE level IN (?);&quot;, levels) 接下来回顾一下创建数据库连接时候的这行代码： 1db.Mapper = reflectx.NewMapperFunc(&quot;json&quot;, strings.ToLower) 这里规定了数据库的对象映射规则，数据库字段将会全部小写之后和查询对象的json标记相匹配，当然如果你只是简单地定义db.MapperFunc(strings.ToUpper)那么数据库字段将会小写后和你的db字段相匹配，很多时候这个东西和json是重合的，所以只写一遍还是会舒服很多。下面给出一个官方的查询例子（适配了本文项目结构）： 123456789101112131415161718192021222324type Place struct &#123; Country string City sql.NullString TelephoneCode int `db:&quot;telcode&quot;`&#125;func main() &#123; p := Place&#123;&#125; pp := []Place&#123;&#125; // this will pull the first place directly into p err = global.db.Get(&amp;p, &quot;SELECT * FROM place LIMIT 1&quot;) // this will pull places with telcode &gt; 50 into the slice pp err = global.db.Select(&amp;pp, &quot;SELECT * FROM place WHERE telcode &gt; ?&quot;, 50) // they work with regular types as well var id int err = gobal.db.Get(&amp;id, &quot;SELECT count(*) FROM place&quot;) // fetch at most 10 place names var names []string err = global.db.Select(&amp;names, &quot;SELECT name FROM place LIMIT 10&quot;)&#125; 需要注意的是如果业务中你查的东西是无限的或者大的无法想象那可能得回到传统的做法去链接，但是一般也不会整出这种活。 增加数据条目或者创建新表本节不讨论删除，但也是同理的，但是实际业务一般并不会这么干，只会加懒标记。 这个执行非查询语句的用法如下所示： Exec(...) (sql.Result, error)和标准库一致 MustExec() sql.Result 经过了封装，查不出来那错误会变panic，记得线上环境处理这个要recovery 同样这个语句的亮点在于你可以且应当使用参数化的方式构建你的sql语句，然后再去交由Exec执行（建表除外，但一般这件事不在后端这里干而是使用迁移库）。同样是官方的例子： 1234567891011121314schema := `CREATE TABLE place ( country text, city text NULL, telcode integer);` // execute a query on the serverresult, err := global.db.Exec(schema) // or, you can use MustExec, which panics on errorcityState := `INSERT INTO place (country, telcode) VALUES (?, ?)`countryCity := `INSERT INTO place (country, city, telcode) VALUES (?, ?, ?)`global.db.MustExec(cityState, &quot;Hong Kong&quot;, 852)global.db.MustExec(cityState, &quot;Singapore&quot;, 65)global.db.MustExec(countryCity, &quot;South Africa&quot;, &quot;Johannesburg&quot;, 27) 这里仅仅展示了插入和创建语句，诸如UPDATE/DELETE/INSERT...ON DUPLICATE KEY UPDATE之类的都可以随便用，自由度很高。 可以看到上述的插入语句都使用了?代替了具体参数，一般而言这些参数可能来自于客户端和前端的信息，这些信息是不可靠的，使用参数化的语句而不是直接拼接sql使得它能够根据类型进行预编译抛出错误从而防止sql注入。 事务的处理在事务的处理这里我不过多细说，但是给出一个相对优雅的实现以及一些值得注意的细节。一个完整相对优雅的事务执行如下所示： 1234567891011tx, err := global.db.Begin()defer func() &#123; if err != nil &#123; log.Printf(&quot;something failed with error: %s\\n&quot;, err) tx.Rollback()//事务回滚 return &#125; err = tx.Commit()&#125;()tx.Exec(...)...//具体的多条业务逻辑 sqlx同时也提供了等级更高的接口db.MustBegin()和tx.MustExec(...)配套使用，记得这两位会抛出panic，上述的defer()得改成： 1234567891011defer func() &#123; if err != nil &#123; log.Printf(&quot;something failed with error: %s\\n&quot;, err) if err := recover();err != nil &#123; log.Printf(&quot;panic recover failed with: %s\\n&quot;, err) &#125; tx.Rollback()//事务回滚 return &#125; err = tx.Commit()&#125;() 最后要说的一点是tx.Exec()事实上具有返回值，分别是一个result接口和一个error，关于result接口具体看这里sql package - database&#x2F;sql - Go Packages。你调用这个接口的LastInsertId() (int64, error)方法获得的id是你表中插入数据的自增主键，这个细节在实际业务中可能会很有用。RowsAffected() (int64, error)返回受影响的行数，多用于日志记录。","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"sqlx总结","slug":"sqlx总结","permalink":"https://kimanyang.xyz/tags/sqlx%E6%80%BB%E7%BB%93/"}]},{"title":"(六)Go语言实现Hopcroft算法","slug":"由实例开始构造正则引擎(6)Go语言实现Hopcrpft算法","date":"2022-06-19T12:58:24.000Z","updated":"2022-06-19T12:57:10.743Z","comments":true,"path":"2022/06/19/由实例开始构造正则引擎(6)Go语言实现Hopcrpft算法/","link":"","permalink":"https://kimanyang.xyz/2022/06/19/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(6)Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0Hopcrpft%E7%AE%97%E6%B3%95/","excerpt":"","text":"Go语言实现Hopcroft算法作为本系列最后一篇，我们先重复一下之前所说的算法流程： 初始时刻，我们将$D$中的状态分为两个组，分别为非接受组$S-F$（包含所有非终止状态）和接受组$F$（包含所有终止状态）。从我们的当前划分出的组中选择一个状态组$A$，选定某个输入符号$a$检查是否可以用于区分状态组中的某些状态，对于能够区分的我们就划分为多个组使得组内的状态在$a$作用下都到达相同的状态。重复上述分割过程直到无法继续分割。我们把某一步的算法得到的分割方法定义为$\\prod_{new}$，初始划分${ {F},{S-F}} $为定义为$\\prod$。算法完成时的分割方法定义为$\\prod_{final}$。下面给出算法流程： 如先前所说划分两个组接受组$F$和非接受组$S-F$作为初始划分 如下图所示进行划分构造 如果$\\prod_{new}&#x3D;\\prod$则直接令$\\prod_{final}&#x3D;\\prod$；否则用$\\prod_{new}$替换$\\prod$并重复步骤2。 在分划出的$\\prod_{final}$的每个组选定一个状态作为该组的代表，这些代表构成了$D^{‘}$的状态，对于这些状态： $D^{‘}$的开始状态是包含了$D$开始状态的组 $D^{‘}$的终止状态是包含了$D$终止状态的组 令$s$是$\\prod_{final}$中某个组$G$的代表，并令$D$中在输入$a$上离开$s$的转换到达状态$t$。令$r$为$t$所在组$H$的代表，那么在$D^{‘}$中存在一个从$s$到$r$在输入$a$上的转换。 下面我们开始给出实现过程： MDFA相关结构类似地，还是有三个主要结构。 MDFA_Node1234567type MDFA_Node struct &#123; Id int Set map[int]bool IsAccept bool Edges *MDFA_Edge Next *MDFA_Node&#125; 和之前完全一致。 MDFA_Edge123456type MDFA_Edge struct &#123; Ch byte From *MDFA_Node To *MDFA_Node Next *MDFA_Edge&#125; 和之前完全一致。 MDFA_Graph12345678910type MDFA_Graph struct &#123; innerDFA *dfa.DFA_Graph //内建的非最小确定性状态机 NodeCount int //所有图节点的个数，随着构造过程逐渐增加 Head *MDFA_Node //整个DFA图的起始节点，构成一条链表用于最后的存图 Nodes []*MDFA_Node //存图后可以通过该项索引所有的点 AlphaBeta map[byte]bool //所有可行的字符集合 /*Used to compare whether two divisions are different*/ GammaOld []map[int]bool //算法中的上一个集合划分 GammaNew []map[int]bool //一个新的集合划分&#125; MDFA核心函数三个函数，在开头提到的算法步骤1~3为函数hopcroft()，函数split(Set map[int]bool) SetPair实现了对集合的划分（一分二），最后的MinimizeDFA()实现了步骤4。最为核心的函数split()的实现较为繁琐，有兴趣可以仔细阅读（我的实现可能不是最优的，可能在集合比较上还得加上用哈希进行优化更好），这里就不做展示了。 hopcroft算法12345678910111213141516171819202122232425262728func (g *MDFA_Graph) hopcroft() &#123; acceptSet := make(map[int]bool) notAcceptSet := make(map[int]bool) for p := g.innerDFA.Head; p != nil; p = p.Next &#123; if p.IsAccept &#123; acceptSet[p.Id] = true &#125; else &#123; notAcceptSet[p.Id] = true &#125; &#125; g.GammaNew = append(g.GammaNew, acceptSet) g.GammaNew = append(g.GammaNew, notAcceptSet) for !compareTwoGamma(g.GammaOld, g.GammaNew) &#123; g.GammaOld = g.GammaNew g.GammaNew = nil &#125; for _, v := range g.GammaOld &#123; tmp := v s1 := g.split(tmp).Set1 if len(s1) != 0 &#123; g.GammaNew = append(g.GammaNew, s1) &#125; s2 := g.split(tmp).Set2 if len(s2) != 0 &#123; g.GammaNew = append(g.GammaNew, s2) &#125; &#125;&#125; 最小化过程12345678910111213141516171819202122232425262728293031func (g *MDFA_Graph) MinimizeDFA() &#123; g.AlphaBeta = g.innerDFA.Alphabeta g.hopcroft() // store the graph for _, v := range g.GammaNew &#123; node := make(map[int]bool) for k, v1 := range v &#123; node[k] = v1 &#125; p := NewMDFA_Node(g.NodeCount, node, false, nil, g.Head) g.NodeCount++ g.Head = p for k := range v &#123; if g.innerDFA.Nodes[k].IsAccept &#123; p.IsAccept = true &#125; &#125; &#125; g.Nodes = make([]*MDFA_Node, g.NodeCount) for p := g.Head; p != nil; p = p.Next &#123; g.Nodes[p.Id] = p &#125; for p := g.innerDFA.Head; p != nil; p = p.Next &#123; for q := p.Edges; q != nil; q = q.Next &#123; g.addEdge(q.From.Id, q.To.Id, q.Char) &#125; &#125;&#125;","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"(五)Go语言实现子集构造法","slug":"由实例开始构造正则引擎(5)Go语言实现子集构造法","date":"2022-06-18T13:58:24.000Z","updated":"2022-06-18T13:09:43.887Z","comments":true,"path":"2022/06/18/由实例开始构造正则引擎(5)Go语言实现子集构造法/","link":"","permalink":"https://kimanyang.xyz/2022/06/18/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(5)Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%AD%90%E9%9B%86%E6%9E%84%E9%80%A0%E6%B3%95/","excerpt":"","text":"Go语言实现子集构造法在本系列的第二章我们已经详细介绍过子集构造法了，现在我们用一张图做一个简单的回顾 需要声明一下，我们这里也把Dtran函数称作delta操作（即我们在定义一个状态机如何转移时用的那个数学符号），同样表示从某个状态（或者状态集合）经由某条边（字符）可以到达的状态。再次回顾一下epsilon闭包指的是从某个状态（状态集合）出发一直走空边能够到达的所有状态。 DFA的相关结构链式前向星已经在第三章介绍过了，这里不多介绍。 DFA_Node1234567type DFA_Node struct &#123; Id int //每个节点都有唯一的标识符 IsAccept bool //当前节点是否是接收状态，不同于NFA只有一个起始一个接受，DFA可以多个接受 StatesIn map[int]bool //当前状态的集合，由多个NFA的节点编号组成 Edges *DFA_Edge //核心结构，每一条从当前节点出发的边都会存在这个链表中，存储链表头节点 Next *DFA_Node //用于遍历，在构建过程中存储新节点链条&#125; DFA_Edge123456type DFA_Edge struct &#123; Char byte From *DFA_Node To *DFA_Node Next *DFA_Edge&#125; 完全和NFA_Node相同 DFA_Graph123456789type DFA_Graph struct &#123; innerNFA *nfa.NFA_Graph //内建的NFA_Graph结构 NodeCount int //所有图节点的个数，随着构造过程逐渐增加 Alphabeta map[byte]bool //所有可行的字符集合 Head *DFA_Node //整个DFA图的起始节点，构成一条链表用于最后的存图 Nodes []*DFA_Node //存图后可以通过该项索引所有的点 Edges map[byte][]*DFA_Edge//存图后可以通过相关的字符索引对应的边 NeedNewNode bool //在子集构造法中标记对象&#125; DFA的核心函数存图相关的内容此处不再赘述。核心函数主要包含了三个，分别是： delta epsilonClosure subsetContruct delta函数实现在链式前向星结构存图的加成下，delta函数的实现十分简单，只需要通过传入的字符索引一个NFA_Edge的数组，然后遍历该数组检查边的起点是否在传入的集合中，然后将边的到达节点加入返回集合即可。 123456789func (g *DFA_Graph) delta(s map[int]bool, ch byte) (ret map[int]bool) &#123; edges := g.innerNFA.Edges[ch] for _, edge := range edges &#123; if s[edge.From.Id] &#123; ret[edge.To.Id] = true &#125; &#125; return&#125; epsilonClosure实现epsilonClosure的实现稍微复杂一点。我们在NFA_Node的结构中安排了isVisited这一属性同时还有一个ResetNodeVisited函数，这用于给DFA实现广度优先搜索。对于传入的集合经由每一条空边能到达的未访问状态就加入队列，直到队列为空，将队列中被加入过的状态标记为访问过。最后把所有节点访问状态清零。 12345678910111213141516171819202122func (g *DFA_Graph) epsilonClosure(x map[int]bool) (epsilonClosure map[int]bool) &#123; Q := make([]int, 0) for k := range x &#123; Q = append(Q, k) &#125; for len(Q) &gt; 0 &#123; q := Q[0] Q = Q[1:] epsilonClosure[q] = true p := g.innerNFA.Nodes[q].Edges for p != nil &amp;&amp; p.Char == nfa.EPSILON_EDGE &#123; if !p.To.IsVisited &#123; Q = append(Q, p.To.Id) p.To.IsVisited = true &#125; p = p.Next &#125; &#125; g.innerNFA.ResetNodesVisited() return&#125; subsetConstruct实现实现了上述的两个操作后，只要按部就班的照着算法写就可以了，我们用一个workQueue来表示Dstates，整个过程基本就是翻译伪代码： 123456789101112131415161718192021222324func (g *DFA_Graph) subsetContruct() &#123; initSet := map[int]bool&#123; g.innerNFA.StartId: true, &#125; q0 := g.epsilonClosure(initSet) workQueue := make([]map[int]bool, 0) workQueue = append(workQueue, q0) for len(workQueue) &gt; 0 &#123; q := workQueue[0] workQueue = workQueue[1:] for c := range g.Alphabeta &#123; v := g.delta(q, c) if v == nil &#123; continue &#125; t := g.epsilonClosure(v) g.addEdge(q, t, c) if g.NeedNewNode &#123; workQueue = append(workQueue, t) g.NeedNewNode = false &#125; &#125; &#125;&#125; 接口规范12345678910type DFA interface &#123; findOrInsertNode(map[int]bool) *DFA_Node //以集合作为索引查找节点 addEdge(from, to map[int]bool, ch byte) //添加一条新边 delta(s map[int]bool, ch byte) map[int]bool epsilonClosure(x map[int]bool) map[int]bool constructAlphabeta() subsetContruct() storeGraph() //存图 ToDFA() //将NFA转换为DFA&#125;","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"(四)Go语言实现Thompson算法","slug":"由实例开始构造正则引擎(4)Go语言实现Thompson算法","date":"2022-06-17T09:58:24.000Z","updated":"2022-06-18T12:54:11.053Z","comments":true,"path":"2022/06/17/由实例开始构造正则引擎(4)Go语言实现Thompson算法/","link":"","permalink":"https://kimanyang.xyz/2022/06/17/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(4)Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0Thompson%E7%AE%97%E6%B3%95/","excerpt":"","text":"Go语言实现Thompson算法在本系列的第二章我们已经详细介绍过Thompson算法了，现在我们用一张图做一个简单的回顾 我们会根据解析的语法树递归地将最终的NFA逐步构建出来。 NFA相关的数据结构（链式前向星简介）首先在这里给出构造NFA所需的数据结构，同时介绍构造图的链式前向星结构，后续的DFA以及MDFA都会采用这种方式进行图的存储。 链式前向星首先是将所有的节点放在一个数组中，这样我们就能通过其Id进行O(1)的复杂度索引，空间复杂度为O(N)，之后每个节点同时持有所有从该节点出发的边链表，这样查询下一个节点的复杂度就是O(m)。这样做的好处：不仅在点数量多和边数量多的情况之间进行了取舍，对边结构的建模使得我们能够存储更多的信息。像网络流之类的题目通常也会采取链式前向星进行建模。 NFA_Node123456type NFA_Node struct &#123; Id int //每个节点都有唯一的标识符 IsVisited bool //用于DFA构造的广度优先搜索，此处可先忽略 Next *NFA_Node //用于遍历，在构建过程中存储新节点链条 Edges *NFA_Edge //核心结构，每一条从当前节点出发的边都会存在这个链表中，存储链表头节点&#125; NFA_Edge123456type NFA_Edge struct &#123; Char byte //该边的持有字符 From *NFA_Node //该边的起始节点 To *NFA_Node //该边到达节点 Next *NFA_Edge // 单向链表的下一个节点&#125; NFA_Graph123456789type NFA_Graph struct &#123; AstTree *lexer.AST //通过调用Lexer获取的解析树 Head *NFA_Node //整个NFA图的起始节点，构成一条链表用于最后的存图 NodeCount int //所有图节点的个数，随着构造过程逐渐增加 StartId int //当前图起始节点的标识符 AcceptId int //当前图接受（终止）节点的标识符 Nodes []*NFA_Node //存图后可以通过该项索引所有的点 Edges map[byte][]*NFA_Edge //存图后可以通过相关的字符索引对应的边&#125; 与图的构建相关的三个函数这三个函数在DFA和MDFA中共同拥有，都是用于链式前向星图的构建，它们分别是findOrInsertNode(num *int*) *NFA_Node|addEdge(from, to *int*, edgeChar *byte*)|storeGraph() 。 12345678910111213func (g *NFA_Graph) findOrInsertNode(num int) *NFA_Node &#123; node := g.Head for node != nil &#123; if node.Id == num &#123; return node &#125; node = node.Next &#125; pNode := NewNFA_Node(num) pNode.Next = g.Head g.Head = pNode return pNode&#125; findOrInsertNode函数在每次创建图节点的时候先进行查找，如果节点存在则直接返回，否则创建新节点并将其加入链表。 123456func (g *NFA_Graph) addEdge(from, to int, edgeChar byte) &#123; fNode := g.findOrInsertNode(from) tNode := g.findOrInsertNode(to) edge := NewNFA_Edge(edgeChar, fNode, tNode, fNode.Edges) fNode.Edges = edge&#125; addEdge用于在两个节点之间构建一条新的边。 1234567891011121314func (g *NFA_Graph) storeGraph() &#123; g.Nodes = make([]*NFA_Node, g.NodeCount) for p := g.Head; p != nil; p = p.Next &#123; g.Nodes[p.Id] = p q := p.Edges for q != nil &amp;&amp; q.Char != EPSILON_EDGE &#123; if g.Edges[q.Char] == nil &#123; g.Edges[q.Char] = make([]*NFA_Edge, 0) &#125; g.Edges[q.Char] = append(g.Edges[q.Char], q) q = q.Next &#125; &#125;&#125; storeGraph用于 将已经构建的节点链表整合成数组，用于下一步的快速索引 将每一个节点所带的边链表加入集合索引，这样我们可以通过字符索引所有相关的边 核心Thompson算法的实现Thompson算法从根节点开始，根据每个节点的类型决定接下来的行为： 如果当前节点是字符即TOKEN_CHAR，则直接创建两个节点和链接两个节点的边，图的起始和接收节点设为当前两个节点 如果当前节点是|即TOKEN_ALTHER，则 递归左子树，存储返回图的起始和接受节点 再递归右子树，存储返回图的起始和接受节点 建立两个节点作为新的起始节点和接受节点，通过并联方式建立新的图（添加空边） 如果当前节点是连接即TOKEN_CONCAT，则 递归左子树，存储返回图的起始和接受节点 再递归右子树，存储返回图的起始和接受节点 在左子图的接受节点和右子图的起始节点间建立空边 图的起始节点设置为左子图的起点，接受节点设置为右子图的接受节点 如果当前节点是*即TOKEN_KLEEN，则 递归左子树，存储返回图的起始和接受节点 在左子图的接受点和起始点间添加一条空边（注意反向） 建立两个节点作为新的起始节点和接受节点，之间建立一条空边，同时通过空边和之前的子图串联 如果当前节点是?即TOKEN_OPTION，则类似于克林闭包 递归左子树，存储返回图的起始和接受节点 建立两个节点作为新的起始节点和接受节点，在起始和接受节点添加一条空边，同时通过空边和之前的子图串联 如果当前节点是+即至少重复一次，则 递归左子树 在图的接收点和起始点间添加一条空边（注意反向） 上述的说明可以配合代码文件中的Regex/NFA/impl_nfa.go中的 recurciveConstruct函数进行理解。 接口规范12345678type NFA interface &#123; thompsonAlgor(tree *lexer.AST) //核心算法 addEdge(from, to int, edgeChar byte) //添加边 findOrInsertNode(num int) *NFA_Node //插入或查询节点 storeGraph() //存图 ToNFA() //转换为NFA ResetNodesVisited() //用于DFA构建时的广度优先搜索，此处可先忽略&#125;","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"(三)Go语言实现递归下降分析","slug":"由实例开始构造正则引擎(3)Go语言实现递归下降分析","date":"2022-06-17T01:58:24.000Z","updated":"2022-06-18T12:53:33.184Z","comments":true,"path":"2022/06/17/由实例开始构造正则引擎(3)Go语言实现递归下降分析/","link":"","permalink":"https://kimanyang.xyz/2022/06/17/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(3)Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90/","excerpt":"","text":"Go语言实现递归下降分析项目基本介绍现在我们正式开始基于Go语言构建一个正则表达式引擎。项目地址位于这里。 在这之前我们先整体介绍一下项目的基本架构。正则引擎位于Regex文件夹中，下面包含了四个文件夹Lexer|NFA|DFA|MDFA，分别是语法解析器&#x2F;非确定性有限状态自动机&#x2F;确定性有限状态自动机和最小化确定性有限状态自动机。 我们向正则引擎传递一个正则表达式regexpr字符串，接下来： 这个字符串会首先传送给MDFA，MDFA调用DFA的构造方法将字符串传递正则字符串 DFA接受regexpr后调用NFA的构造方法传递正则字符串 NFA接受regexpr后调用Lexer的构造方法传递正则字符串 Lexer接受regexpr生成语法解析树AST，并回传给NFA NFA根据回传的内建AST经由Thompson算法构建NFA_Graph并回传给DFA DFA根据回传的内建NFA_Graph经由子集构造法构建DFA_Graph并回传给MDFA MDFA根据回传的DFA_Graph经由Hopcroft算法构建MDFA_Graph并回传给Regex，正则引擎通过该最小化的确定性有限状态自动机进行字符串匹配 在这个过程中向下传递的过程通过每个结构各自的构造函数实现，而回传过程通过Golang的interface规范了相互之间调用的接口，同时每一步都采用了空接口断言的方式保证了所有接口都有被实现。第5~7步中的*_Graph采用链式前向星的数据结构进行图的存储，在邻接表和邻接矩阵两种极端的结构之间取了一个中庸性能的结构，因为在算法实现过程中我们需要大量访问边和点而并非只是其中之一，所以这可能是一个更好的选择。 语法解析树的构建这部分的工作属于编译器前端的一部分，主要是将文本根据给定的巴克斯范式解析为一系列token，生成一颗语法解析树，之前我们已经给出过BNF范式的表达如下： 12345BNF: expr ::= term(&quot;|&quot;term)* term ::= factor* factor ::= (subfactor|subfactor (&quot;*&quot;|&quot;+&quot;|&quot;?&quot;)) subfactor ::= char | &quot;(&quot; expr &quot;)&quot; 我们可选的工具很多比如yacc&#x2F;gyacc等等，但是由于正则表达式属于最简单的语言了，在这个项目里就直接自己手写递归下降解析为token了。 Token结构123456type Token struct &#123; Token_Type int Char byte LeftChild *Token RightChild *Token&#125; Token是一个典型的二叉树结构，语法解析树是由一个个Token所构成的，Char字段表示其在正则表达式中的字符（或单纯的连接符号）,Token_Type字段由枚举结构给出，总共有六种： 12345678const ( TOKEN_CHAR = iota //字符类型 TOKEN_ALTER //或类型`|` TOKEN_CONCAT //链接符 TOKEN_KLEEN //克林闭包`*` TOKEN_OPTION //可选类型`?` TOKEN_P_KLEEN //重复一次或以上`+`) AST结构以及其对parser接口的实现123456type AST struct &#123; expr string pos int curChar byte Root *Token&#125; AST的结构包括了内建的正则表达式expr，当前解析的位置pos，当前解析的字符curChar以及当前解析树的根节点Root。 parser接口的定义如下： 12345678type parser interface &#123; nextChar() byte //解析下一个字符 parse_expr() *Token //对应BNF中的第一行 parse_term() *Token //对应BNF中的第二行 parse_factor() *Token //对应BNF中的第三行 parse_subfactor() *Token//对应BNF中的第四行 toAST() //进行字符串到AST的转换&#125; 该接口将由AST结构实现 具体代码直接参考项目源文件这里。","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"关于Go语言Context包的一些总结","slug":"关于Go语言Context包的一些总结","date":"2022-06-13T01:23:24.000Z","updated":"2022-06-15T03:39:16.491Z","comments":true,"path":"2022/06/13/关于Go语言Context包的一些总结/","link":"","permalink":"https://kimanyang.xyz/2022/06/13/%E5%85%B3%E4%BA%8EGo%E8%AF%AD%E8%A8%80Context%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/","excerpt":"","text":"关于Go语言Context包的一些总结最近在follow一个微服务的后端Go的搭建实现，在读源码的过程中发现大量使用了context（其中有很大一部分是Gin框架自己再封装的），于是觉得很有必要总结一遍context的使用。 context包最重要的用途是在不同的goroutine之间传递上下文信息（即”context”本意），这些信息在不同的goroutine内使用不会发生并发冲突，具体使用上大体分为三点： 在函数(goroutine)链上传递键值对信息（通过withValue) 进行超时控制（通过withTimeout） 进行取消控制（通过withCancel） 使用方法在开始前我们先总结一下context包的用法 Context的创建主要有两种方式来创建context，分别是： context.Background() context.TODO() 二者没有本质区别，但是在系统架构搭建的前期如果不知道当前的context具体需要什么功能但是直到一定会将数据传递给其他函数处理的情况下，可以使用context.TODO()（比如可能会用到上述三点作用中的某一点）；而context.Background()指的是空的context，是一个根源的context。 具体使用一个context的具体作用往往通过四个context包的With函数来实现： 1234func WithCancel(parent Context) (ctx Context, cancel CancelFunc)func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)func WithValue(parent Context, key, val interface&#123;&#125;) Context 这四个函数都需传入一个父context用于派生新的context，通过这种方式形成一个context树。子节点的退出并不会影响父节点和同级节点，但是会影响到其子节点。这几个函数使用例子具体看context package - context - Go Packages（或者中文文档），这里仅给出简单使用。 WithValue的使用1ctx := context.WithValue(context.Background(),KEY,VAL) 当创建的ctx在不同函数间传递时，所有goroutine都能通过KEY安全读写VAL的值，二者都是interface&#123;&#125;类型。值的获取既可以从当前的ctx也可以从父节点ctx获取，本质上是在父节点存储的，查询时从子节点回溯查询。 WithDeadline和WithTimeout这两个函数作用于超时控制。 12ctxTimeout,cancelTimeout = context.WithTimeout(context.Background(),3 * time.Second)ctxDDL,cancelDDL = context.WithDeadline(context.Background(),time.Now()+3*time.Second) 需要强调的是：**如果在子程序中开启了一个goroutine去处理其他任务又不想要请求被中断的话需要重新开启一个空的context**。 withCancel1ctx,cancel := context.WithCancel(context.Background()) 和上面的类似，ctx传递函数链上游可以根据需要自己决定满足条件时刻调用cancel()来向下游的函数传递结束信息，具体上就是在子函数执行前： 1234567select &#123; case &lt;- ctx.Done(): fmt.Println(ctx.Err()) return default: /*Something YOUWANT*/&#125; 可以看出其实ctx.Done()其实是个管道。 Context的基本结构这个包并不大，方法也不多，很适合作为阅读Go语言标准库源码的一个入门，这里不做太多展开。作为一个接口，Context定义了四个方法： 123456type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 需要的时候阅读四个方法的基本实现就可以知道如何进行自己的魔改context。如何安全地在各个协程之间传递具体得看看WithCancel函数中用到的concelCtx类： 1234567type cancelCtx struct &#123; Context mu sync.Mutex // protects following fields done atomic.Value// of chan struct&#123;&#125;, created lazily, closed by first cancel call children map[canceler]struct&#123;&#125; // set to nil by the first cancel call err error// set to non-nil by the first cancel call&#125; 更多的细节实现可以看： 深度解密Go语言之context - Stefno - 博客园 (cnblogs.com)","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"Context总结","slug":"Context总结","permalink":"https://kimanyang.xyz/tags/Context%E6%80%BB%E7%BB%93/"}]},{"title":"关于彼得堡的回忆","slug":"关于彼得堡的回忆","date":"2022-05-29T05:34:02.000Z","updated":"2022-05-29T05:43:35.703Z","comments":true,"path":"2022/05/29/关于彼得堡的回忆/","link":"","permalink":"https://kimanyang.xyz/2022/05/29/%E5%85%B3%E4%BA%8E%E5%BD%BC%E5%BE%97%E5%A0%A1%E7%9A%84%E5%9B%9E%E5%BF%86/","excerpt":"","text":"关于彼得堡的回忆最近梦里我时常回到疫情前从彼得大帝青铜骑士像出发沿着涅瓦大街游荡的那个白夜凌晨。想起冬宫广场狂欢一夜后的一地酒瓶，一片静寂中在燃烧的垃圾桶前弹奏吉他的流浪汉，而后走到不远的喀山大教堂前又遇到了烂醉如泥倚到我身上的大胡子男人。想起莫斯科火车站（像在上海设了北京火车站一样别扭）旁分岔出两条小道，其中一条阴暗破旧路面积水，那里抽着水烟揽客的妓女意兴阑珊地望了我一眼又自顾自地抽烟。北极星商场前一个年轻的推销员向我喊了几句俄语，看见我迷惑的表情又用英语说“We can be free friend.”，当时我仅仅回了句抱歉就继续前行，如今我却无比好奇他在那个白夜里究竟在贩卖些什么。当亚历山大·涅夫斯基修道院最终呈现在我面前时，太阳也恰恰升到修道院塔尖，十字架泛着金色的光芒，陀翁的墓近在眼前，但修道院并不会在五点开放，于是在路边的消防栓上坐了十分钟后我便返程了。清晨的彼得堡宁静祥和，人们早早出门聚集在涅瓦河畔等待着盛大的海军军演，那时的我并不知道从头顶飞过的苏24以及面前驶过的护卫舰们将会迎来怎样的未来。一个父亲将儿子扛到肩上，涅瓦河上的吊桥缓缓升起，随着飞机的轰鸣和军舰驶过，他们欢呼起来。 冬宫广场与亚历山大柱 彼得大帝青铜骑士像 在我的梦中，拉斯科利尼科夫举起斧子将桥索砍断，彼得大帝筑城的二十万劳工与农奴的死魂灵从泥泞的大地中升起，从天而降的铝热剂燃烧弹将我与每个活人烧穿，青铜骑士在熊熊烈火里融化，阿芙乐尔号也缓缓沉没，在死亡与惨叫声中谢尔盖·沃尔孔斯基用年迈农奴的锄头为每具尸体挖好坟墓，就像他为被尼古拉一世炮火轰碎的十二月党人挖好的坟墓一样。随后一场冰雹从天而降，彼得堡如同从未存在过一样化为波罗的海旁一片沼泽。 宫廷桥，涅瓦河上的吊桥 醒来的我仍要面对着怎样寻找下一个李雅普诺夫函数的问题，这个在哈尔科夫大学任教的、为爱情自尽的彼得堡学派数学家葬于战舰波将金号起义的敖德萨港——那里已被战火覆盖。曾经崇高的一切被一个又一个独裁者的野心所摧毁，而纯粹的灵魂却能久远地影响世人，所以我将用同样出生于彼得堡的维克多·崔的歌曲结束这篇喃喃自语： 多么温暖的房间啊 但我却不得不上路了 我的军靴上有星光点点 舒适的沙发，格子的纹络 与没有扣动的扳机 不要叫醒我好吗？以后阳光灿烂的日子只在美梦中 而我的血型却写在我的袖章上 我的编号写在我的袖口里 但愿我能平安归来,愿我能平安归来 不要死在战场上 不要埋在战场上 但愿我能平安归来,但愿我能平安归来! 虽然有获取胜利的方法 但是我并不想要 我不想把靴子踏上谁的胸膛 我只想和你在一起 只是和你在一起 但是天上高高的星星召唤我上路 而我的血型却写在我的袖章上 我的编号写在我的袖口里. 但愿我能平安归来,愿我能平安归来 不要死在战场上 不要埋在战场上 但愿我能平安归来,但愿我能平安归来! ————《руппа крови》Виктор Цой","categories":[{"name":"散文","slug":"散文","permalink":"https://kimanyang.xyz/categories/%E6%95%A3%E6%96%87/"}],"tags":[{"name":"散文","slug":"散文","permalink":"https://kimanyang.xyz/tags/%E6%95%A3%E6%96%87/"}]},{"title":"拓扑排序&网络流算法&二分图匹配","slug":"网络流算法","date":"2022-05-15T11:32:04.000Z","updated":"2022-05-15T11:44:42.664Z","comments":true,"path":"2022/05/15/网络流算法/","link":"","permalink":"https://kimanyang.xyz/2022/05/15/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%AE%97%E6%B3%95/","excerpt":"","text":"拓扑排序&amp;网络流算法&amp;二分图匹配最近上了黄荷姣老师的计算机通识课，讲的是网络流算法，第一节课给没有计算机基础的同学介绍了各种图搜索算法和拓扑排序算法，后一节课讲的是网络流相关的问题，刚好最近在练习稳定AC中等偏困难题，所以上课之余总结一下。 拓扑排序力扣在拓扑排序这个专题经典题有三道：207课程表、210课程表Ⅱ和329矩阵最长递增路径 拓扑排序的作用在于对一个有向无环图中重新标号使得边满足。 算法的执行过程：初始化时队列为空，计算每一个节点的入度存入indegree数组中，定义一个next计数器为0： 将入度为0的节点标记为next指针值，next指针自加，节点加入队列，若无进入步骤2 若列表为空则算法结束，否则从列表弹出队头节点将其邻接边的indegree值减一，回到步骤1 LeetCode 207课程表&amp;LeetCode 210课程表Ⅱ你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi]，表示如果要学习课程 ai 则 必须 先学习课程 bi。 例如，先修课程对 [0, 1]表示：想要学习课程0 ，你需要先完成课程 1。请你判断是否可能完成所有课程的学习？如果可以，返回true；否则，返回 false。 对于210则是返回一个可能的学习顺序。 这道题并非完整的拓扑排序题，但是涉及到了相关知识，即判断给定的图是否满足拓扑序，如果满足拓扑序的话，每个节点的入度能够被依次清零。下面给出代码: 123456789101112131415161718192021222324252627class Solution {public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { vector&lt;int&gt; indegrees(numCourses,0); vector&lt;vector&lt;int&gt;&gt; neiborlist(numCourses,vector&lt;int&gt;(0)); for(auto&amp; p:prerequisites) { indegrees[p[0]]++; neiborlist[p[1]].push_back(p[0]); } int permitCnt = 0; queue&lt;int&gt; q; for(int i = 0;i &lt; numCourses;++i) { if(indegrees[i]==0) q.push(i); } while(!q.empty()){ int node = q.front(); q.pop();permitCnt++; for(auto&amp; i:neiborlist[node]){ indegrees[i]--; if(indegrees[i]==0) { q.push(i); } } } return permitCnt == numCourses; }}; 和上面的那道题是类似的，只不过需要返回的是一个学习顺序，那么我们只需要将广度优先搜索的每个弹出节点记录下来返回即可，需要注意的是同时也得判断可不可行。代码很类似如下所示： 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { vector&lt;int&gt; indegrees(numCourses,0); vector&lt;vector&lt;int&gt;&gt; neigborList(numCourses,vector&lt;int&gt;(0)); for(auto&amp; p:prerequisites) { neigborList[p[1]].push_back(p[0]); indegrees[p[0]]++; } queue&lt;int&gt; q;vector&lt;int&gt; ret; int permitCnt = 0; for(int i = 0;i &lt; numCourses;++i) if(indegrees[i] == 0) q.push(i); while(!q.empty()) { int node = q.front(); permitCnt++; ret.push_back(node); q.pop(); for(auto&amp; i:neigborList[node]){ indegrees[i]--; if(indegrees[i]==0) q.push(i); } } return permitCnt == numCourses ? ret : vector&lt;int&gt;(0); }}; LeetCode 329矩阵最长递增路径第一次一次过的HARD，虽然知道用拓扑排序之后就很好想了，这道题题意很简单就是给定一个矩阵找出其中的最长递增路径。 仔细思考利用入度的概念，一个节点如果能够作为最长递增路径的起点，那么它肯定是入度为0的，那么我们通过广度优先搜索将每一步将队列中所有入度为0的节点周围的可行节点入度减为1，再将每一步变为入度0的节点加入新的队列，直到新的队列为空，那么此时广度优先搜索的深度就是最长递增路径的长度。代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {private: vector&lt;int&gt; dir = {-1,0,1,0,-1};public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; indegrees(m, vector&lt;int&gt;(n,0)); //获取所有初始节点的入度 for(int i = 0;i &lt; m;++i) { for(int j = 0;j&lt;n;++j) { for(int k = 0;k &lt; 4;++k) { int next_x = i + dir[k], next_y = j + dir[k+1]; if(next_x &gt;= 0 &amp;&amp; next_y &gt;= 0 &amp;&amp; next_x &lt; m &amp;&amp; next_y &lt; n) { if(matrix[next_x][next_y] &lt; matrix[i][j]) indegrees[i][j]++; } } } } //获取第一步可以作为起点的入度为0节点 vector&lt;int&gt; q; int idx = 0; for(int i = 0;i &lt; m;++i) { for(int j = 0;j &lt; n;++j) { if(indegrees[i][j] == 0) q.push_back(i*n+j); } } //当还存在入度为0的可行节点时 while(!q.empty()){ //存储下一步的可行节点队列 vector&lt;int&gt; next_q; for(auto&amp; pos:q) { int cur_x = pos / n, cur_y = pos % n; for(int k = 0;k &lt; 4;++k) { int next_x = cur_x + dir[k], next_y = cur_y + dir[k+1]; if(next_x &gt;= 0 &amp;&amp; next_y &gt;= 0 &amp;&amp; next_x &lt; m &amp;&amp; next_y &lt; n) { if(matrix[next_x][next_y] &gt; matrix[cur_x][cur_y]){ indegrees[next_x][next_y]--; if(indegrees[next_x][next_y] == 0) { next_q.push_back(next_x*n+next_y); } } } } } idx++; q = next_q; } return idx; }}; 类似的题还有802/851/954，就不一一列举了。 网络流网络流基础算法是Ford-Fulkerson算法，算法导论中讲的略微复杂（本文这里旨在给出代码和基本概念，作为作者个人消化学习的笔记，不适合新手学习相关知识，建议可以看网络流简介 - OI Wiki (oi-wiki.org)）。 它的基本思想是寻找增广路，即容量不为0的路径，单纯减去流量并不能保证算法正确于是对每一条边引入了反向边，初始值为0，当我们选择了一条增广路的正向路径最小值，那对应的这条路径的反向路径要加上这个最小值，这可以理解为一种撤销操作，这个算法的正确性就不做证明，具体参考《算法导论》的内容。 朴素实现具体编程实现上朴素想法可以通过深度优先搜索来获取增广路径，FF算法代码如下，存图方法采用链式前向星,这是一种采用数组来模拟链表的方法，免去了复杂的指针操作： 建图过程：12345678910struct Edge { int to, w, next;}edges[MAXN];int head[MAXN], cnt=-1; //cnt为建图过程中当前边的编号,初始化为-1是必要的，可以简化反向边索引操作void add(int from, int to, int w) { edges[++cnt].w = w; //新增一天编号为cnt+1的边，权重（容量）为w edges[cnt].to = to; //新增的边终点设为to edges[cnt].next = head[from]; //下一条边作为当前起点的第一条边 head[from] = cnt; //当前起点的边设置为新增的边} 同时我们在建图的时候要保证同一条边的下一个编号的边就是反向边，具体操作就是： 1234for(auto [from,to,w,isend]:=read();!isend;){ add(from,to,w); add(to,from,0);} 算法过程：123456789101112131415161718192021222324252627int n,m,s,t; // s是源点,t是汇点bool vis[MAXN]; //dfs访问列表，在一次增广路搜索后重新清空int dfs(int p = s, int flow = INF) { if(p == t) return flow;//到达汇点，返回增广路上的流量 vis[p] = true; for(int eg = head[p];eg;eg = edges[eg].next){ int to = edges[eg].to, vol = edges[eg].w,c; if(vol &gt; 0 &amp;&amp; !vis[to] &amp;&amp;(c = dfs(to,min(vol,flow)))!=-1) { /* 网络流算法核心，对于正向边减去容量，反向边加上容量，形成新的残余网络 向上返回的容量是当前容量和下层递归得到容量的最小值 */ edges[eg].w -= c; edges[eg ^ 1].w += c; return c; } } return -1;//不可达的清空则返回-1}int FordFulkerson() { int ans = 0,c; while((c = dfs())!=-1) { memset(vis,0,sizeof(vis));//深搜时清空访问数组的简便方法 ans += c; } return ans; //每条增广路径的流量加起来就是最大流} 但是这种实现不是多项式复杂度的，意味着它很玄学。 Edmond-Karp改进一般会考虑采用BFS版本的实现，变成了Edmond-Karp算法，EK算法采用BFS的方式进行遍历构造，和之前一样我们忽略根据数据建图过程给出代码如下。 1234567891011121314151617181920212223242526272829303132333435363738int n,m,s,t,last[MAXN],flow[MAXN];bool bfs(){ memset(last,-1,sizeof(last)); queue&lt;int&gt; q; q.push(s); flow[s] = INF; while(!q.empty()) { int p = q.front(); q.pop(); if(p == t){//到达汇点循环结束 break; } /* 广度优先搜索一条可行流，flow[i]表示以节点i为末尾的一个流,last[to]表示 到达to节点的边 */ for(int eg=head[p];eg;eg = edges[eg].next) { int to = edges[eg].to, vol = edges[eg].w; if(vol &gt; 0 &amp;&amp; last[to] == -1) {//边容量大于0且没被选过 last[to] = eg; flow[to] = min(flow[p],vol); q.push(to); } } } return last[t] != -1; //返回是否有到达汇点的路径}int EdmondKarp() { int ans = 0; while(bfs()){//能够找到一条通往汇点的增广路径 ans += flow[t]; for(int i = t;i != s;i = edges[last[i]^1].to) { //向前回溯每一条路径的反向边并更新残余网络 edges[last[i]].w -= flow[t]; edge[last[i]^1].w += flow[t]; } }} 上述算法的多项式时间复杂度上线。 Dinic算法在边数过多的稠密图状况下EK算法还有改进空间，就是Dinic算法，在现实中最常用的是这种(虽然老师上课讲的是label correcting，不过区别仅仅在于贴标签的方向不同）。 Dinic算法先采用BFS分层贴标签然后再用DFS在可行弧中寻找解。其时间复杂度的上界是，平均为，如果用在二分图算法里则该算法优于匈牙利算法。 Dinic算法给定了层级图(level graph)和距离标签(distance label)来对网络进行增广路径搜索。 123456789101112131415161718192021222324252627282930313233343536373839404142434445int n, m, s, t, level[MAXN], cur[MAXN];bool bfs() {//BFS算法对节点进行分层 memset(level,-1,sizeof(lv)); level[s] = 0; //从源节点开始给各个节点编号 memcpy(cur,head,sizeof(head));//将所有节点索引起始弧作为当前优化弧 queue&lt;int&gt; q; q.push(s); while(!q.empty()){ int p = q.front(); q.pop(); for(int eg = head[p];eg;eg = edges[eg].next) { int to = edges[eg].to, vol = edges[eg].w; if(vol &gt; 0 &amp;&amp; level[to] == -1) {//新一节点未被编号 level[to] = level[p] + 1, q.push(to); } } } return level[t] != -1; //汇点无法被标签更新则无法到达，返回false}int dfs(int p = s, int flow = INF) { if(p == t){ return flow; } int res = flow; for(int eg = cur[p];eg &amp;&amp; res&gt;0;eg = edges[eg].next) {//有剩余流量则继续 cur[p] = eg; //节点p的当前弧更新 int to = edges[eg].to, vol = edges[eg].w; if(vol &gt; 0 &amp;&amp; level[to] == level[p] + 1){ //选择层数更高的方向即可行弧方向进行增广 int c = dfs(to,min(vol,res));//尽可能多传递流量 res -= c; //更新剩余流量 //更新残存网络 edges[eg].w -= c; edges[eg ^ 1].w += c; } } return flow - res; //返回从当前节点传出去的流量}int dinic() { int ans = 0; while(bfs()) { ans += dfs(); } return ans;} 最大二分匹配假设我们的基础问题是董事长有八个员工编号为1到8，同时有8项工作编号为a到h，员工们能干的活如下： 员工1： a b c d 员工2：c d 员工3： e f 员工4： f g 员工5：a e f g 员工6：g 员工7：h 员工8：h 问怎么找到一个算法安排每个员工同时干一件事来使得能够完成的工作最多。首先我们根据问题给出每个员工能干的活给出一个可视化的图。 匈牙利算法在介绍这个问题之前我们给出一个类似于最大流最小割的Konig定理，一个二分图中的最小覆盖点等于最大匹配数，最小覆盖点指选取一个最小的点集使得所有边（视作无向）都至少在这个点集中有一个端点。所以很多时候最小覆盖问题也可以转换为最大匹配问题从而用匈牙利算法解决，类似于最小割问题也可以转化为求取最大流问题，这体现了线性规划问题中的对偶性（我猜的）。 匈牙利算法就是遍历二分图的s集合中的点i，与i能够匹配的第一个可行解直接匹配，如果发生冲突则看当前冲突的对象是否有别的可行解没被匹配，有的话就让它和其他解匹配，然后i和可行解匹配，没有的话就移到下一个可行解（优先NTR，不行就选择别人，真有你的黄毛）。代码如下： 123456789101112131415161718192021222324int M = 8, N = 8; //M, N分别表示左、右侧集合的元素数量int Map[M][N]; //邻接矩阵存图int p[M]; //记录当前右侧元素所对应的左侧元素bool vis[N]; //记录右侧元素是否已被访问过bool match(int i){ for (int j = 1; j &lt;= N; ++j) if (Map[i][j] &amp;&amp; !vis[j]) {//有边且未访问 vis[j] = true; //记录状态为访问过 if (p[j] == 0 || match(p[j])){ //如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配 p[j] = i; //当前左侧元素成为当前右侧元素的新匹配 return true; //返回匹配成功 } } return false; //循环结束，仍未找到匹配，返回匹配失败}int Hungarian(){ int cnt = 0; for (int i = 1; i &lt;= M; ++i){ memset(vis, 0, sizeof(vis)); //重置vis数组 if (match(i)) cnt++; } return cnt;} 网络流解法这类问题也可以建模为网络流问题，通常需要自己加上一个原点和汇点，根据增广路算法的使用相比于匈牙利算法可能会更加高效（比如laebel correcting算法）。 我们为前面所说的图添加一个源点和汇点： 每个原点流出为1，每个汇点接受也为1，这样就表示每个员工同时只能干一件工作，一件工作同时只能被一个人干，这就将二分图最大匹配问题转换为了网络流问题，可以使用我们在之前提到的网络流算法来解决了。 一些例题这部分给定一些看起来不像是二分图匹配但是却可以用二分图匹配解决的问题，以后再来写。 LCP 04. 覆盖 - 力扣（LeetCode） （洛谷P1129） [ZJOI2007]矩阵游戏 （TYVJ P1035） 棋盘覆盖","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://kimanyang.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://kimanyang.xyz/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"https://kimanyang.xyz/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"网络流","permalink":"https://kimanyang.xyz/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"Ford-Fulkerson算法","slug":"Ford-Fulkerson算法","permalink":"https://kimanyang.xyz/tags/Ford-Fulkerson%E7%AE%97%E6%B3%95/"},{"name":"Dinic算法","slug":"Dinic算法","permalink":"https://kimanyang.xyz/tags/Dinic%E7%AE%97%E6%B3%95/"},{"name":"Edmond-Karp算法","slug":"Edmond-Karp算法","permalink":"https://kimanyang.xyz/tags/Edmond-Karp%E7%AE%97%E6%B3%95/"}]},{"title":"树状数组应用及ST表","slug":"树状数组应用及ST表","date":"2022-05-06T09:12:44.000Z","updated":"2022-05-10T06:28:52.907Z","comments":true,"path":"2022/05/06/树状数组应用及ST表/","link":"","permalink":"https://kimanyang.xyz/2022/05/06/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%BA%94%E7%94%A8%E5%8F%8AST%E8%A1%A8/","excerpt":"","text":"树状数组应用及ST表周末的学习就要结束了，限于篇幅上一篇树状数组与线段树 - Brief Candle (kimanyang.xyz)写到线段树为止。这篇文章将树状数组的应用做了下总结。 另外没有什么太大关系的一部分给出在不需要修改数据时求取区间最大值的数据结构ST表，它的查询时间是的，相比线段树更优。 树状数组应用——二维偏序问题树状数组常常应用于解决二维偏序问题，比如经典的数组中的逆序对和下面给出的一道周赛题。（想要稳定AC周赛还是得学高级数据结构的）。 二维偏序是这样一类问题：对于一个点的序列在其上定义某种偏序关系。给定一个点求所有满足的数量。在数学上我们称一个偏序关系具有如下性质： 自反性：给定一个关系，若对于中的每一个都有，那么称是自反的（这个关系对对自己也成立的意思) 反对称性：给定一个关系，对于中的每一个和都有和成立时，则称该关系是反对称的 传递性：给定一个关系，对于中的每一个，若且，则成立。 对于给定的任意二维有序对，我们一定能定义出一种偏序关系： 周赛题——统计包含每个点的矩形数目给你一个二维整数数组rectangles，其中rectangles[i] = [li, hi]表示第 i 个矩形长为li高为hi。给你一个二维整数数组points，其中points[j] = [xj, yj]是坐标为(xj, yj)的一个点。 第i个矩形的左下角在(0, 0)处, 右上角在(li, hi)。 请你返回一个整数数组count，长度为points.length，其中count[j]是包含第j个点的矩形数目。 如果 0 &lt;= xj &lt;= li 且0 &lt;= yj &lt;= hi，那么我们说第 i 个矩形包含第j 个点。如果一个点刚好在矩形的边上 ，这个点也被视为被矩形包含。链接：https://leetcode-cn.com/problems/count-number-of-rectangles-containing-each-point 数据范围和约束： 1 &lt;= rectangles.length, points.length &lt;= 5*10e4 rectangles[i].length == points[j].length == 2 1 &lt;= li, xj &lt;= 10e9 1 &lt;= hi, yj &lt;= 100 所有 rectangles 互不相同 。 所有 points 互不相同 。 排序+二分查找一个朴素的思路是对所有的矩形进行排序，然后扫描每个点，针对该点二分查找可能的矩形范围再进行验证，这样做仍然十分复杂且低效。 树状数组我们需要统计的是的个数。 一开始的朴素想法是对于矩形的坐标和坐标都进行一个前缀和统计，看数据范围可以对于可以直接遍历而不需要树状数组，但由于x轴范围达到了10e9的程度树状数组需要离散化求解。改换一下思路，把所有的点和矩形混在一起进行排序（多一个记号标记一下点原来的位置用于返回答案），这样就转换成了经典的二维偏序问题了。所有的点按照x轴的位置作为第一关键字，y轴位置作为第二关键字进行从大到小排序，保证位于自己右上角的元素一定位于自己之前，然后更新树状数组。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {private: using pii = pair&lt;int,int&gt;; using piii = pair&lt;pii,int&gt;; const int TAG = 1e8; //细节之一，当矩形和点同时排序时，矩形排在后，处理时会优先处理 int n = 0; //树状数组的长度,取决于y轴最大数+1 vector&lt;int&gt; tree; int lowbit(int x) { return x &amp; (-x); } void update(int idx) { for(;idx &lt;= n;idx+=lowbit(idx)) tree[idx]++; } int getsum(int idx) { int ret = 0; for(;idx&gt;0;idx-=lowbit(idx)) ret += tree[idx]; return ret; }public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) { vector&lt;piii&gt; pts; for(auto&amp; rec:rectangles) { pts.push_back(piii(pii(rec[0],rec[1]),TAG)); n = max(n,rec[1]); } for(int i = 0;i &lt; points.size();++i) { pts.push_back(piii(pii(points[i][0],points[i][1]),i)); n = max(n,points[i][1]); } tree = vector&lt;int&gt;(n + 1,0); sort(pts.begin(),pts.end()); //自动按照前几个关键字升序排列 vector&lt;int&gt; ans(points.size(),0); for(int i = pts.size()-1;i &gt;= 0;--i) {//降序搜索,相同时先处理矩形后处理点（重合不算的话则应将TAG设为-1） auto cur_pt = pts[i]; if(cur_pt.second == TAG) {//标记为矩形 update(cur_pt.first.second); //更新y轴前缀和 } else {//标记为点 ans[cur_pt.second] = getsum(n) - getsum(cur_pt.first.second-1); //大于自己y轴的区间和 } } return ans; }}; 有诸多细节需要注意，特别是排序的时候关键字的顺序和处理顺序 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 题目十分简单，简单来说我们的偏序关系在这里变成了对于一个点集的两个点和满足： (a_i,i)\\prec (a_j,j) \\triangleq a_i > a_j\\and i","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"},{"name":"树状数组","slug":"树状数组","permalink":"https://kimanyang.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://kimanyang.xyz/tags/ST%E8%A1%A8/"}]},{"title":"树状数组与线段树","slug":"树状数组与线段树","date":"2022-04-29T02:12:04.000Z","updated":"2022-05-08T15:23:58.273Z","comments":true,"path":"2022/04/29/树状数组与线段树/","link":"","permalink":"https://kimanyang.xyz/2022/04/29/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%B8%8E%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"树状数组与线段树隐约记得以前总结过但是又没有翻到于是重新写一遍。这两个数据结构通常是用来解决区间和与二维偏序问题的，这将会在下一篇文章详细解说，本文先介绍两种数据结构。 树状数组工作原理基本介绍树状数组和线段树有相似之处，树状数组能做的线段树也能做，线段树能做的树状数组不一定有但是代码要相对简单好理解一些。 树状数组通过大的节点表示小节点的信息，在查询的时候只需要通过大节点不断跳转来进行查询。上图展示了一个长度为8的数组如何通过树状数组查询，从图中可以看出： 表示到的和 表示到的和 表示到的和 表示到的和 相比于正常的前缀和数组，这样做的好处是当原数组发生修改时，它的维护开销比前缀和会更小。 上图可以发现，如果我们修改了某一个点，那我们只需要沿着该点向上更新它的父关系节点即可，不需要和普通的前缀和数组一样逐个更新。先忽略这个树是怎么构建的，我们的问题现在是：给定一个数组的索引idx，怎么通过这个树结构求取前idx个数的和？比如上图如果要求前7项和的话，可以发现： 7的二进制是111，6的二进制是110，4的二进制是100 求取前$(111)2=7项和只需要加上当前的c{(111)2}，然后加上c{(110)2}再加上c{(100)_2}$ 这刚好是每次去掉二进制末尾的1知道索引变成0，我们定义把一个数二进制数x获取其最后一位的操作为lowbit(x)，理解这一过程就可以给出下面的函数了，实现起来反而相对简单： 为了能够实现给定一个能够知道它的管理区间和，引入了一个函数lowbit，这就是树状数组最核心的一点 12345678int lowbit(int x) { // x 的二进制表示中，最低位的 1 的位置。 // lowbit(0b10110000) == 0b00010000 // ~~~^~~~~ // lowbit(0b11100100) == 0b00000100 // ~~~~~^~~ return x &amp; -x;} 计算机中的数以补码的形式存储，取相反数意味着按位取反再加一，恰好获得了最后一位。 于是愉快地实现一下上述的前项求和函数： 1234567int getsum(int k) { int ret = 0; while(k &gt;= 1) { ans += c[k]; k = k - lowbit(k); }} 除了向下求和，还有单点修改，比如给加上了增量，那只需要向上更新所属的数组对象： 123456void update(int x, int delta) { while(x &lt; TREE_MAX) {//小于c数组的尺寸 c[x] += delta; x = x + lowbit(x); }} 区间求和最直观的方法当然是：一个数组维护一个树状数组，通过两次getsum方法求取前缀和相减得到所需的区间和，具体操作。 123int rangesum(int l, int r) { return getsum(r) - getsum(l-1);} 建树遍历原数组，插入一个数同时就去维护其所有相关父节点： 123456void init(vector&lt;int&gt;&amp; arr) { int n = arr.size(); for(int i = 1;i &lt;= n;++i) { update(i,nums[i]); }} 当然竞赛党们搞了一个建树的小trick: 1234567void init(vector&lt;int&gt;&amp; arr) { for(int i = 1;i &lt;= n;++i) { c[i] += a[i]; int j = i + lowbit(i); if(j &lt;= TREE_MAX) c[j] += c[i]; }} 上述的方法看到了前一个方法里多余的操作，既然数组本身就可以表示子数组和了那么只需要递推更新一个直系的父节点就足够了。 线段树在理解了树状数组的基础上，我们可以进一步学习线段树了。线段树相对树状数组更加复杂，树状数组的索引是一个相同大小的数组用二进制的特性进行区间划分，但是到了线段树这里索引变成了一棵平衡二叉树，这也意味着代码量的巨大增长，但同时线段树的功能也会更加强大一些。 线段树 - OI Wiki (oi-wiki.org)故弄玄虚给出了线段树维护的信息具有的性质： 线段树维护的信息满足幺半群限制，一个幺半群定义为,其中为集合上定义的二元运算符而是幺元，幺半群具有如下性质： 封闭性：和有 结合律：有 存在幺元： 满足有，为左幺元，或者，为右幺元 一般来说正常实数域的加法乘法满足这个条件，二元运算取幺元也可以满足这个条件，这说明线段树拓展到区间最大值最小值，这是树状数组所不具备的。 可能这些佬们讲这个条件是想说这东西能推广到矩阵上去吧。 基本形态对一个大小为5的数组，其线段树的基本形态如下所示，每个节点维护其区间和： 类似于堆这种基本结构，一个完全二叉树可以用数组来代替。 第位的数组元素左子节点，右子节点。在开始写代码之前我们强调一下，下面代码中线段树的所有区间都是左闭右闭的，这一点对于递归区间查询十分重要。 如何建树直接的做法是递归地进行构造，先上代码： 123456789101112void build(int l = 1, int r = n-1, int p =0) { if (l == r) {//到达了叶子节点 tree[p] = arr[l]; //进行赋值 } else { int mid = l + (r-l)&gt;&gt;1; //首先将本节点需要的左右节点先构造完成 build(l,mid,p*2+1); build(mid+1,r,p*2+2); //当前节点地构造等于左右节点和 tree[p] = tree[p*2+1]+tree[p*2+2]; }} 刷题基础牢靠的话这个算法还是很好理解的。如果一共有个叶子节点（数组元素），那么采用堆式存储的线段是其最大数组范围是，空间相比于树状数组增加了许多，但通常4倍空间就很足够了。 区间修改/查询与lazy tag在进行区间修改的时候，如果区间发生了修改，朴素的想法是递归方式逐层修改，那程序需要遍历包含区间的所有节点。从时间复杂度角度上这是无法接受的，于是线段树引入了lazy tag的方法，这是线段树的精髓，类似于缓存的思想。 其基本思想是：对于正好是线段树节点的区间，递归不会继续进行下去，而是打上一个lazy tag，在未来需要用到子区间的再向下传递。 函数签名void update(int l, int r, int delta, int p=1, int cl=1,int cr = n)，其中l和r为目标区间，cl和cr为当前区间，当前节点为p。（当l==r的时候即单点修改，否则区间内所有值加上目标增量delta。 代码实现如下： 123456789101112131415161718192021222324int n, m, A[MAXN], tree[MAXN * 4], mark[MAXN * 4];//一般树开个4倍空间就很够了，void update(int l, int r, int d, int p = 0, int cl = 0, int cr = n-1) { if (cl &gt; r || cr &lt; l){//和当前区间没有交集，递归结束 return; } else if (cl &gt;= l &amp;&amp; cr &lt;= r) {//当前区间被目标区间包含 tree[p] += (cr - cl + 1) * d;//节点的值加上区间长度乘以增量 if (cr &gt; cl)//非叶子节点的话打上lazy tag mark[p] += d; } else {//两者之间存在交集但并不包含 int mid = cl + (cr-l)&gt;&gt;1; push_down(p, cr - cl + 1); //传播当前的懒标记 update(l, r, d, p * 2 + 1, cl, mid); //递归处理左子树 update(l, r, d, p * 2 + 2, mid + 1, cr); //递归处理右子树 tree[p] = tree[p * 2 + 1] + tree[p * 2 + 2];//更新当前父节点的值 }}void push_down(int p, int len) { mark[p * 2 + 1] += mark[p]; //左子树节点加上懒标记 mark[p * 2 + 2] += mark[p]; //右子树节点加上懒标记 tree[p * 2 + 1] += mark[p] * (len - len / 2);//更新左子树节点的增量 tree[p * 2 + 2] += mark[p] * (len / 2); //更新右子树节点的增量 mark[p] = 0; //清空父节点的标记，因为已经不需要了} 需要处理的情况有三种： 当前区间和目标区间没有交集，递归直接结束 当前区间被目标区间包含，整个当前区间值更新，同时打上lazy tag（叶子节点就不用了，因为不会向下传递） 当前区间和目标区间相交但并非包含关系,这时候的处理相对比较复杂，首先要将区间一分为二（和建树的时候的递归操作一样），分别处理左右区间，存在lazy tag的情况下要向下传播即push_down函数，随后清空当前的lazy tag。 在实现区间增量修改的过程中我们已经体会到lazy tag在什么时间节点需要被传播，于是类似地我们可以写出查询的情况： 1234567891011int query(int l, int r, int p = 0, int cl = 0, int cr = n-1) { if(cl &gt; r || cr &lt; l) {//当前区间不是目标区间，返回0 return 0; } else if(cl &gt;= l &amp;&amp; cr &lt;= r) {//当前区间被目标区间包含，返回节点值 return tree[p]; } else { int mid = cl + (cr-l)&gt;&gt;1; push_down(p,cr-cl+1); return query(l,r,p*2+1,cl,mid) + query(l,r,p*2+2,mid+1,cr); }} 上述的线段树的实现在找工作的时候大概已经够用了，不过仍旧略显稚嫩。 被豆瓣群嘲的清华老哥张昆玮在 《统计的力量——线段树全接触》之中提出的zkw线段树统一了树状数组和线段树的性质，极大降低了原本递归方法的常数复杂度，此处不多扩展。 实现区间最值查询线段树现在我们已经了解了线段树的基本原理，现在可以把线段树扩展到区间最值查询了。这时候recall一下幺半群的性质就能理解为什么线段树对这类数据处理来说是一个很有效的范式了。查询的时候我们的三个分类操作可以理解为：返回集合中的一个元素，返回幺元0（若最大值问题取,最小值问题取）以及对递归获取的两个区间内容进行二元操作。下面以最大值为例直接作出修改： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int n, m, arr[MAXN], tree[MAXN * 4], mark[MAXN * 4];void build(int l = 1, int r = n-1, int p =0) { if (l == r) {//到达了叶子节点 tree[p] = arr[l]; //进行赋值 } else { int mid = l + (r-l)&gt;&gt;1; //首先将本节点需要的左右节点先构造完成 build(l,mid,p*2+1); build(mid+1,r,p*2+2); //当前节点地构造等于左右节点最值 tree[p] = max(tree[p*2+1],tree[p*2+2]); }}void update(int l, int r, int d, int p = 0, int cl = 0, int cr = n-1) { if (cl &gt; r || cr &lt; l){//和当前区间没有交集，递归结束 return; } else if (cl &gt;= l &amp;&amp; cr &lt;= r) {//当前区间被目标区间包含 tree[p] += d;//节点的值加上增量，最值操作不需要乘长度 if (cr &gt; cl)//非叶子节点的话打上lazy tag mark[p] += d; } else {//两者之间存在交集但并不包含 int mid = cl + (cr-l)&gt;&gt;1; push_down(p); //传播当前的懒标记 update(l, r, d, p * 2 + 1, cl, mid); //递归处理左子树 update(l, r, d, p * 2 + 2, mid + 1, cr); //递归处理右子树 tree[p] = max(tree[p * 2 + 1], tree[p * 2 + 2]);//更新当前父节点的值 }}void push_down(int p) { mark[p * 2 + 1] += mark[p]; //左子树节点加上懒标记 mark[p * 2 + 2] += mark[p]; //右子树节点加上懒标记 tree[p * 2 + 1] += mark[p]; //更新左子树节点的增量 tree[p * 2 + 2] += mark[p]; //更新右子树节点的增量 mark[p] = 0; //清空父节点的标记，因为已经不需要了}int query(int l, int r, int p = 0, int cl = 0, int cr = n-1) { if(cl &gt; r || cr &lt; l) {//当前区间不是目标区间，返回负无穷 return INT_MIN; } else if(cl &gt;= l &amp;&amp; cr &lt;= r) {//当前区间被目标区间包含，返回节点值 return tree[p]; } else { int mid = cl + (cr-l)&gt;&gt;1; push_down(p,cr-cl+1); return max(query(l,r,p*2+1,cl,mid), query(l,r,p*2+2,mid+1,cr)); }}","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"},{"name":"线段树","slug":"线段树","permalink":"https://kimanyang.xyz/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"https://kimanyang.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"敏感词匹配问题——KMP、Trie到AC自动机","slug":"敏感词匹配问题——KMP、Trie字典树到AC自动机","date":"2022-04-15T06:06:14.000Z","updated":"2022-04-20T10:31:57.718Z","comments":true,"path":"2022/04/15/敏感词匹配问题——KMP、Trie字典树到AC自动机/","link":"","permalink":"https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"敏感词匹配问题——KMP、Trie到AC自动机寅宝最近向我炫耀了他在业务中用到的最先进的算法居然是字典树，并解释这个业务是要做敏感词匹配。 没有打过比赛的我第一反应觉得应该使用DFA（或正则调库）来解决这个问题，编译一个模式串就可以判断有无敏感词。 但是这种解决方法的缺点就是随着敏感词增加模式串增加每次都需要重新编译出一次DFA。 寅宝提出的方案是字典树，实际上如果正则引擎有做优化的话那编译出来的DFA也就是一颗字典树（大概类似用|连接每一个敏感词模式串然后进行捕捉替换），比起我的想法这种更加适合热更新，每次只要执行脚本修改内存中的字典树即可。 但显然我们都太菜了，在实际中采用的方案通常是AC自动机。这个方案结合了KMP算法中next数组的思路和字典树多模式匹配的优势，本文先回忆了一下KMP的基本思想，然后再给出正常的字典树写法，最后介绍AC自动机。 KMP算法问题描述首先我们描述单模式匹配要解决的问题，我们有一个长度为文本字符串text和一个对应的长度为模式串pattern，我们要寻找文本字符串text中是否包含模式串，必要的时候把所有模式串的起点都标出来（返回数组表示每个对应模式文本起始位置）。 最容易想到的就是从文本串的每个字符开始往后按位遍历模式串看是否满足匹配，这种做法的缺点显而易见，时间复杂度为。 代码实现（Go）在解释KMP算法之前我们先完整展示下面的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445package algorithmfunc KMPMatch(text string, pattern string) int { if pattern == \"\" { return 0 } next := getNext(pattern) pat_ptr, tar_ptr := 0, 0 for tar_ptr &lt; len(text) { if text[tar_ptr] == pattern[pat_ptr] { tar_ptr += 1 pat_ptr += 1 } else { if pat_ptr == 0 { tar_ptr += 1 } else { pat_ptr = next[pat_ptr-1] } } if pat_ptr == len(pattern) { return tar_ptr - pat_ptr } } return -1}func getNext(pattern string) (next []int) { pre_ptr, itr_ptr := 0, 1 next = append(next, 0) for itr_ptr &lt; len(pattern) { if pattern[pre_ptr] == pattern[itr_ptr] { pre_ptr += 1 itr_ptr += 1 next = append(next, pre_ptr) } else { if pre_ptr == 0 { next = append(next, 0) itr_ptr += 1 } else { pre_ptr = next[pre_ptr-1] } } } return} 上述代码匹配成功后是直接退出的，但是也可以匹配成功后记录结果回退后文要讲的next数组继续匹配，从而寻找所有成功匹配点，这种做法通常也被称作所谓的“KMP自动机”。 匹配部分解析对于每一个模式串，即我们要匹配的敏感词其自身拥有一个待匹配的数组成为next数组，其严格定义为：next数组长度于模式串长度相同，其每一位i对应的值k表示对于模式串从0到i的子串前k位和后k位恰好相同的最大的k，特别的k不能取为i+1，因为自身肯定和自身相等（这一点是为了回退考虑）。 比如对于下面的模式串：TobeOrNoTobe来说，它的next数组为000000001234，仅仅有后四位跟模式串的前四位分别匹配。 比如我们要匹配TobeOrNoTobringTobeOrNoTobe，显然在bring处失配了，那么此时对应的模式串适配位置next数组的值就是4，我们只需要将头指针移动到失配处往前移动4位开始下一轮匹配即可；如果失配处是0，那么前面的部分可以完全舍弃，直接将头指针移动到失配的下一位开始下一轮匹配即可。这部分作为核心框架 这种做法能够将复杂度降低到的水平，相比原来提高了许多。 获取Next数组那么我们如何获得next数组呢？我们具有在的时间复杂度之内构造next数组的方法，也即上面代码的核心部分getNext()，这部分也是KMP算法的核心思想，即模式串与模式串自己匹配来求取Next数组。 在初始时刻我们有一个前缀指针pre_ptr设置为0和迭代指针itr_ptr设置为1，next数组出于其自身性质首位被设置为0。 在每次循环中我们考虑两种情况： 前缀指针的字符能够和当前的迭代指针匹配：两个指针各自后移一位，next数组的itr_ptr-1位设置为当前pre_ptr的值（或者如代码中直接插入，效率较低） 前缀指针字符和当前迭代指针失配： 如果pre_ptr是首位，那么itr_ptr位设为0，itr_ptr后移一位，否则： 当前的pre_ptr不在首位。这一步利用到了next数组的递推构造性质，也是构造过程实现线性时间复杂度的核心所在，**pre_ptr位会退回当前pre_ptr前一位的next数组值** 这里我们详细解释一下为什么是回退当前前一位的的next数组值。例如我们构造了模式串：abcabxxxabcabc，那我们的next数组将会是00012000123453，当我们按照上述算法在匹配到最后一位的时候会出现pre_ptr=5,itr_ptr=13，此时next[itr_ptr]的值应该设置为3，这恰好是next[pre_ptr-1]+1的值，也就是说我们失配的时候前缀数组的指针移动到了next[pre_ptr-1]的位置，这是因为我们希望在失配后当前位置重新匹配的前缀要尽可能地长，而失配前我们已经完整匹配了abcab五个字母，那么下一次检验是否匹配的起始位置就应该pre_ptr的前一个位置所能完整匹配的前缀起始位置。 自此我们完整描述了KMP算法的完整过程，读者可以用手执行一遍上述例子更好理解这个算法。 Trie字典树问题描述字典树要解决的问题的是单词查找的问题，也即多模匹配。“多模”意味着多个模式串，而KMP问题仅仅只能解决单个模式串的匹配。字典树能够做到：给出一个字典集合，我们能在线性时间复杂度内实现某个待查找的串是否属于字典。注意我们此时还未考虑子串匹配的问题。 代码实现首先给出Trie的代码实现。思路很好理解，看代码即可，实质上就是一个叉树，为字符集大小，下面两份代码展现小写字母情况下的Trie树构建，分别是C++和Golang。 插入单词时递推构建树的节点，如果有重复则无需重新构造对应字符 Go版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647type Trie struct { Inner byte Children []*Trie IsEnd bool}func Constructor() Trie { ori := make([]*Trie,26) return Trie { byte('0'), ori, false, }}func (this *Trie) Insert(word string) { cur := this for i, ch:=range word { if cur.Children[ch-'a'] != nil { cur = cur.Children[ch-'a'] cur.IsEnd = (i == len(word)-1) || (cur.IsEnd) } else { tmp := make([](*Trie),26) node := Trie { byte(ch), tmp, i == len(word) -1, } cur.Children[ch-'a'] = &amp;node cur = cur.Children[ch-'a'] } }}func (this *Trie) Search(word string) bool { cur := this for _, ch := range word { if cur.Children[ch-'a'] == nil { return false } cur = cur.Children[ch-'a'] } return cur.IsEnd} C++版本12345678910111213141516171819202122232425262728293031323334353637383940class Trie {private: vector&lt;Trie*&gt; children; bool isEnd;public: Trie() : children(26), isEnd(false){} void insert(string word) { Trie* node = this; for(char ch:word){ if(node-&gt;children[ch-'a']==nullptr){ node-&gt;children[ch-'a'] = new Trie(); } node = node-&gt;children[ch - 'a']; } node-&gt;isEnd = true; } bool search(string word) { Trie* node = this; for(char ch:word){ if(node-&gt;children[ch - 'a'] == nullptr){ return false; } node = node-&gt;children[ch - 'a']; } return node-&gt;isEnd; } bool startsWith(string prefix) { Trie* node = this; for(char ch:prefix){ if(node-&gt;children[ch - 'a'] == nullptr){ return false; } node = node-&gt;children[ch - 'a']; } return true; }}; AC自动机接下来到了这篇文章最重点的部分AC自动机了，建议读者能够把前两个算法完全理解再来看这部分。 AC 自动机 - OI Wiki (oi-wiki.org)这篇文章写的很好强烈推荐一下。笔者按照自己的理解给出代码并进行解释。 问题描述Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法。已知KMP虽然能够实现随机长度文本的线性时间复杂度单模匹配但是多模匹配的时间复杂度是乘方的；Tire能够实现定长文本的线性时间多模匹配但是对于随机长度文本的多模匹配时间复杂度也是乘方的。 自然我们的任务是敏感词匹配，对于给定的敏感词字典在不确定长度的文本中进行匹配，匹配成功后进行屏蔽或者封号之类的操作，非常具有拆腻子特色了，是一个简中互联网实用算法。 基本思想AC自动机相比于普通的字典树多了一个fail指针来给定失败情况下需要跳转到哪一个状态重新开始匹配，这很类似于KMP中的next数组做的事，只不过我们从模式串指针变为了节点，这两者之间主要的不同是：next指针失配仅仅需要针对当前模式求最长相同前后缀，但是fail指针需要匹配所有模式串能够匹配当前状态的最长后缀。比如soobxxxoob/oob都在字典中，那么在模式串soobxxxoob的多个oob处其fail指针指向另外一个模式串oob对应的oob处。 总结一下就是建立AC自动机分为两步： 将所有模式串构建为一颗Trie树 参考KMP算法的思想，对Trie树上的每个节点构造对应的fail指针 字典树的搭建就不多赘述，算法的核心就在于构造每个结点的fail指针。 构造fail指针基本的想法是这样的：考虑字典树中的节点u，其父节点为p，边(p,u)通过字符ch连接，这种状态转移记作Trie[p,ch]=u。由于fail指针是按照广度优先的方式进行遍历的，我们假设高度小于u节点的所有节点都已求得fail指针。 如果Trie[fail[p],ch]存在（此时fail[p]可以是根节点），那么u的fail指针指向trie[fail[p],ch] 如果Trie[fail[p],ch]不存在： fail[p]为根节点：那fail指针指向根节点 fail[p]不为根节点，递归查找集合Trie[fail[fail[p]],ch] 其中fail[u]表示u节点的fail指针 这个例子取自AC 自动机 - OI Wiki (oi-wiki.org)，给出了 i he his she hers 组成的字典树构建 fail 指针的过程。下面代码也取自该文。 自动机构建过程虽然解释起来很复杂，但是如果对并查集路径压缩、KMP、图论搜索和字典树构造都足够熟悉的话，代码写起来还是相当简洁的。假设我们已经构建完成字典树了，采用的是二维数组的形式便于状态转移以及后续现实工程化的状态压缩（字母表通过掩模+按位获取来压缩内存）。 1234567891011121314void build() { for (int i = 0; i &lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); while (q.size()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) { if (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]); else tr[u][i] = tr[fail[u]][i]; } }} 上述代码通过广度优先搜索层序构造各个节点fail指针，同时进行自动机的构造。我们采用一个fail数组来表示第个节点的fail指针。这里有一个和并查集路径压缩类似的做法：如果fail指针在u处失配会多次跳转，那不如一开就走到fail[u]能够转移到的匹配位置，对于字符集中少量不存在的字符可能就直接转移回到原点了，效率很高。 具体的构造过程如图所示，其中： 蓝色结点：BFS 遍历到的结点 u 蓝色的边：当前结点下，AC 自动机修改字典树结构连出的边。 黑色的边：AC 自动机修改字典树结构连出的边。 红色的边：当前结点求出的 fail 指针 黄色的边：fail 指针 灰色的边：字典树的边 原先的树在经过fail指针构造和自动机构造之后已经变成了DFA图。 读者可能会发现采用数组的方法无法额外添加IsEnd属性，我们可以选择在外部新开一个endWith数组，在插入的时候统计以节点u为末尾的个数，具体可以看下方完整代码。 匹配过程12345678910int query(char *t) { int u = 0, res = 0; for (int i = 1; t[i]; i++) { u = tr[u][t[i] - 'a']; // 转移 for (int j = u; j &amp;&amp; e[j] != -1; j = fail[j]) { res += e[j], e[j] = -1; } } return res;} 对于字符串中的每一位进行转移，如果匹配到以当前传为结尾的那匹配次数加上当前结尾次数再清零（如果要多次使用就不必进行这一步，直接记录匹配时的i和对应字符深度一次性将前文清空即可）。 红色结点： 结点 粉色箭头： 在自动机上的跳转， 蓝色的边：成功匹配的模式串 蓝色结点：示跳 fail 指针时的结点（状态）。 完整代码C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using namespace std;const int N = 1e6 + 6;int n;namespace AC { int tr[N][26], tot; int e[N], fail[N]; void insert(char *s) { int u = 0; for (int i = 1; s[i]; i++) { if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot; // 如果没有则插入新节点 u = tr[u][s[i] - 'a']; // 搜索下一个节点 } e[u]++; // 尾为节点 u 的串的个数 } queue&lt;int&gt; q; void build() { for (int i = 0; i &lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); while (q.size()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) { if (tr[u][i]) { fail[tr[u][i]] = tr[fail[u]][i]; // fail数组：同一字符可以匹配的其他位置 q.push(tr[u][i]); } else tr[u][i] = tr[fail[u]][i]; } } } int query(char *t) { int u = 0, res = 0; for (int i = 1; t[i]; i++) { u = tr[u][t[i] - 'a']; // 转移 for (int j = u; j &amp;&amp; e[j] != -1; j = fail[j]) { res += e[j], e[j] = -1; } } return res; }} 完整代码Go带测试样例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package mainimport ( \"fmt\" \"strings\" \"testing\")const alphabetSize = 26type ACnode struct { char byte // the char hold by a node children []*ACnode //child in a tree struct fail *ACnode //fail pointer to others acceptLen int // Accepted status with nonnegative length isRoot bool // is root status}func GetWordFilter(slist []string) (ret ACnode) { ret = getRoot() ret.buildFromWordList(slist) ret.buildfail() return}func getRoot() ACnode { ori := make([]*ACnode, alphabetSize) return ACnode{ byte('0'), ori, nil, 0, true, }}func (node *ACnode) buildFromWordList(slist []string) { for _, word := range slist { lword := strings.ToLower(word) node.insert(lword) }}func (node *ACnode) insert(word string) { cur := node for i, ch := range word { if cur.children[ch-'a'] != nil { cur = cur.children[ch-'a'] } else { tmp := make([](*ACnode), alphabetSize) node := ACnode{ byte(ch), tmp, nil, //build later 0, false, } cur.children[ch-'a'] = &amp;node cur = cur.children[ch-'a'] } if i == len(word)-1 &amp;&amp; cur.acceptLen == 0 { cur.acceptLen = i + 1 } }}// BFS construct the AC automatonfunc (root *ACnode) buildfail() { root.fail = root q := make([]*ACnode, 0) for i := 0; i &lt; alphabetSize; i++ { if root.children[i] != nil { q = append(q, root.children[i]) root.children[i].fail = root } else { root.children[i] = root } } for len(q) &gt; 0 { u := q[0] q = q[1:] for i := 0; i &lt; alphabetSize; i++ { if u.children[i] != nil { u.children[i].fail = u.fail.children[i] q = append(q, u.children[i]) } else { u.children[i] = u.fail.children[i] } } }}func (root *ACnode) MaskText(text string, mask byte) (ret []byte) { ret = []byte(text) text = strings.ToLower(text) cur := root for i, ch := range text { cur = cur.children[ch-'a'] j := cur for !j.isRoot { if j.acceptLen &gt; 0 { maskSingleWord(ret, i-j.acceptLen+1, j.acceptLen, mask) } j = j.fail } } return}func maskSingleWord(target []byte, start int, l int, mask byte) { if start &lt; 0 { return } for i := start; i &lt; start+l &amp;&amp; i &lt; len(target); i++ { target[i] = mask }}// used as a Trie tree, check if a word in the built treefunc (root *ACnode) IsInIndex(word string) bool { cur := root for _, ch := range word { if cur.children[ch-'a'].isRoot { return false } cur = cur.children[ch-'a'] } return cur.acceptLen &gt; 0}/* ouput: \"dadfsef*****asdfew***asef**r\"*/func Test_AC(t *testing.T) { wordlist := []string{\"i\", \"she\", \"his\", \"hers\", \"he\"} filter := GetWordFilter(wordlist) //fmt.Print(filter.IsInIndex(\"rhe\")) fmt.Println(string(filter.MaskText(\"dadfsefsheheasdfewhisasefher\", '*')))} 总结其实这三个算法除了字典树很多时候确实没啥大用处（被哈希吊打）以外，另外两个都有各自的典型使用场景，比如unix系统中需要把多个文件名文件筛选出来就会用到AC自动机，vim里面替换所有文本的%s/x/y命令就会使用KMP（我猜的）。就连确实很废的字典树都可以很适合用来实现Web框架中的一部分路由匹配任务。 能够理解上面的算法对于业务还是很有帮助的（显然AC自动机我肯定是直接抄或者找库，不打比赛能够默写出来也就我刚写完博客这几天），业务中能够用到的高级算法并不只是字典树而已。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"KMP","slug":"KMP","permalink":"https://kimanyang.xyz/tags/KMP/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"Trie字典树","slug":"Trie字典树","permalink":"https://kimanyang.xyz/tags/Trie%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://kimanyang.xyz/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"路径压缩","slug":"路径压缩","permalink":"https://kimanyang.xyz/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"}]},{"title":"LQR(Linear Quadratic Regulator)与其Matlab实现","slug":"LQR详解与其matlab使用","date":"2022-03-29T15:45:14.000Z","updated":"2022-04-14T07:37:57.199Z","comments":true,"path":"2022/03/29/LQR详解与其matlab使用/","link":"","permalink":"https://kimanyang.xyz/2022/03/29/LQR%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%85%B6matlab%E4%BD%BF%E7%94%A8/","excerpt":"","text":"LQR(Linear Quadratic Regulator)与其Matlab实现这部分内容的推导部分参考MIT相关课程。 问题简述传统控制中，针对LTI（线性时不变）系统：$$\\begin{aligned}\\dot{x} &amp;&#x3D; Ax+Bu \\\\y &amp;&#x3D; Cx + Du\\end{aligned}$$我们通常可以设置控制律$u&#x3D;Kx$来实现全状态反馈的零极点配置，虽然方法类似，但是在LQR之中$K$的选取是不同的。 在LQR算法中我们寻找$K$是通过求解一个优化问题来获得的，因此我们需要一个优化判据。此类算法都要求我们给出一个正定的$Q$矩阵和正定的$R$矩阵对控制器的性能（时间、能量）进行二次综合，其内部参数体现我们对控制器性能的代价取舍，大部分时候会建立如下的代价函数：$$J&#x3D;\\int_0^\\infty\\left(x^TQx+u^TRu \\right)dt$$ $Q$矩阵通过求解过程中的状态变化来衡量状态到达稳定的速度，$R$则是衡量能量的消耗，它们内部参数（一般选取对角阵）代表着我们对每一维状态的权重选取；每一维控制状态的能量要求。 将动力学方程带入其中便可以通过求解凸优化问题来获得对应的系统参数。 ***remark:*上述代价函数是基于$x$趋于0进行设计的，如果我们要求的是追踪问题，那么需要将$x$更换为参考误差 问题求解在matlab中有现成的LQR库可供使用，最简单的： 1234567891011121314151617181920close all% initial statex0 =[3;0];% System DynamicA = [0,1;0.01,0];B= [0;1];C = [1,0];D = 0;% Control LawQ = [1,0;0,1];R = 2;K = lqr(A,B,Q,R);% Closed loop systemsys = ss((A-B*k),B,C,D);%Run reponse to initial statet = 0:0.005:30;[y,t,x] = initial(sys, x0, t); 进一步的讨论最基本的公式很容易理解，但是我们还可以进一步讨论加深理解。 对于给出的判据：$$J&#x3D;\\int_0^\\infty\\left(x^TQx+u^TRu \\right)dt$$其最优解$J^*$满足哈密顿-雅可比-贝尔曼（HJB）方程：$$\\forall x,\\min_{u}\\left[x^TQx+u^TRu+\\frac{\\partial J^*}{\\partial x}(Ax+Bu) \\right]&#x3D;0$$这里有关键的一步，不作证明，但是针对这个最优控制问题我们可以认为最优解是一个二次型的形式，具体可以参考Ch. 7 - Dynamic Programming (mit.edu)。 ***remark:*这个思路跟我们在MPC里提到的最优化问题求解是不同的，MPC算法是通过模型预测将代价函数中的未来状态消去从而使之成为一个标准的二次规划问题，但是LQR中对于优化问题的求解则是采用了最优控制的相关知识求解偏微分方程。 于是预设最优解满足:$$J^*(x)&#x3D;x^TSx,S&#x3D;S^T\\ge0$$对上式求导代入HJB方程最小项内部，可以得到一个显示的二次规划问题（凸优化问题）：$$\\min_{u}\\left[x^TQx+u^TRu+2x^TS(Ax+Bu) \\right]&#x3D;0$$对上式进行求导：$$\\frac{\\partial}{\\partial u}&#x3D;2u^TR+2x^TSB&#x3D;0$$于是可以给出最优控制策略：$$u^*&#x3D;-R^{-1}B^TSx&#x3D;-Kx$$现在我们还有一个问题没有解决，$S$究竟是多少，为了解决这个问题，我们将求解的$u$回代到HJB方程之中：$$x^T[Q-SBR^{-1}B^TS+2SA]x&#x3D;0$$这一等式对于所有的$x$都是成立的，如下的方程成立：$$Q-SBR^{-1}B^TS+2SA&#x3D;0$$这个等式被称为代数里卡提等式(algebraic Riccati equation). 有限时间判别的LQR上述我们采取的全过程稳态收敛的LQR，有时对于一个限定时间的任务，我们需要用到新的判别函数：$$\\begin{aligned}J &amp;&#x3D; h(x(t_f))+\\int_0^{t_f}l(x(t),u(t))dt\\\\h(x)&amp;&#x3D;x^TQ_fx,Q_f&#x3D;Q_f^T\\ge0\\\\l(x,u)&amp;&#x3D;x^TQx+u^TRu,Q&#x3D;Q^T\\ge0\\end{aligned}$$同样通过HJB方程可以有：$$\\min_{u}\\left[x^TQx+u^TRu+\\frac{\\partial J^*}{\\partial x}(Ax+Bu) + \\frac{\\partial J^*}{\\partial t} \\right]&#x3D;0$$对于时变的情况我们假设最优代价函数具有如下形式：$$J^*(x,t)&#x3D;x^TS(t)x,S(t)&#x3D;S^T(t)\\gt0$$类似于我们在之前所用的方法可以获得连续时间微分Riccati方程：$$-\\dot{S}(t)&#x3D;S(t)A+A^TS(t)-S(t)BR^{-1}B^TS(t)+Q$$以及末端条件：$S(t_f)&#x3D;Q_f$. 无限时间的LQR可以通过令$\\dot{S}(t)&#x3D;0$来进行求解。上述方程可以通过数值积分解法来获得，不过在弱可控系统之中这种数值解法经常是不稳定的，可能会使得$S$的对称性或者正定性被破坏，为了获得稳定的数值解，通常会把上述的矩阵写成$S(t)&#x3D;P(t)P^T(t)$的形式，即所谓的平方根形式里卡提微分方程：$$-\\dot{P}(t)&#x3D;A^TP(t)-\\frac{1}{2}S(t)BR^{-1}B^TP(t)+\\frac{1}{2}QP^{-T}(t),P(t_f)&#x3D;Q_f^{\\frac{1}{2}}$$这种解法要求$P(t)$是可逆的。 离散时间Riccati方程考虑如下的离散时间动力系统：$$x[n+1]&#x3D;Ax[n]+Bu[n]$$对于这种形式我们需要满足的判据是：$$\\min\\sum_{n&#x3D;1}^{N-1}x^T[n]Qx[n]+u^T[n]Ru[n],Q&#x3D;Q^T\\ge0,R&#x3D;R^T\\gt0$$可以认为模型满足如下的递推式（从后往前推）：$$J(x,n-1)&#x3D;\\min_{u}x^TQx+u^TRu+J(Ax+Bu,n)$$类似于我们之前的方法，给出如下的假设：$$J(x,n)&#x3D;x^TS[n]x,S[n]&#x3D;S^T[n]\\gt0$$回代递推式可得：$$u^*[n]&#x3D;-K[n]x[n]&#x3D;-(R+B^TS[n]B)^{-1}B^TS[n]Ax[n]$$使得：$$S[n-1]&#x3D;Q+A^TS[n]A-A^TSB(R+B^TSB)^{-1}(B^TSA)$$其中$S[N]&#x3D;0$，这是著名的Riccati差分方程。对于无限窗口LQR问题我们类似的有：$$S&#x3D;Q+A^TSA-(A^TSB)(R+B^TSB)^{-1}(B^TSA)$$这被称为离散时间代数Riccati方程。 Matlab可以直接调用Implicit solver for discrete-time algebraic Riccati equations - MATLAB idare接口求解 具有输入和状态限制的LQR通常我们都会考虑到一些输入或者状态的限制，诸如$|u[n]|\\le1$或者$x[n]\\ge2$之类的，此类的线性约束都可以表示为$Cx+Du\\le1$的形式。一般而言我们不会去寻求这类问题的全局最优而是选择一个限定的时间窗口来求解使之可以计算，于是我们有了MPC，Marcucci17.pdf (mit.edu)。自此我们可以了解MPC事实上是对离散、具有状态限制的LQR算法的一个推广。","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"https://kimanyang.xyz/tags/matlab/"},{"name":"LQR算法","slug":"LQR算法","permalink":"https://kimanyang.xyz/tags/LQR%E7%AE%97%E6%B3%95/"},{"name":"凸优化","slug":"凸优化","permalink":"https://kimanyang.xyz/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"HJB方程","slug":"HJB方程","permalink":"https://kimanyang.xyz/tags/HJB%E6%96%B9%E7%A8%8B/"}]},{"title":"分布式卡尔曼滤波阅读笔记","slug":"分布式卡尔曼滤波观测器","date":"2022-03-25T05:12:23.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/03/25/分布式卡尔曼滤波观测器/","link":"","permalink":"https://kimanyang.xyz/2022/03/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E8%A7%82%E6%B5%8B%E5%99%A8/","excerpt":"","text":"TargetDesign a distributed linear estimator of linear time-varying random field that uses only local communications among the sensors such that the distributed estimates are asymptotically unbiased with bounded mean-squared errors. Main Contribution Propose a single time scale distributed information Kalman filter (DIKF) to obtain unbiased estimates with bounded MSE for unstable systems Develop a general analytical design of the estimator gain matrices by introducing a novel consensus+innovations type dynamic averaging step that runs in parallel with the DIKF Problem FormulationObserver dynamicsLet collect the samples of the system at time . Observer dynamics:where is the system dynamics matrix and is the input noises. The system is observed by a network of sensors(agents), where the measurement of sensor , . In vector notation:$$\\underbrace{}{z_i}=\\underbrace{}{H}x_i+\\underbrace{}{r_i}z_i,r_i\\in R^{\\sum{n=1}^N M_n}\\A\\in R^{M\\times M}\\H_n\\in R^{M_n\\times M}\\H\\in R^{\\sum_{n=1}^N M_n\\times M}$$Some assumptions : the input noise sequence and the sensing noise sequence are zero mean independent the input noise sequence and the sensing noise sequence are both distributed Gauss with covariance and where is block-diagonal . the input noise sequence and the sensing noise sequence are respectively and statistically independent of each other and of Communication NetworkThe sensors communicate through a network define by a simple(no self-loops nor multiple edges), undirected, connected graph , where is the set of sensors(nodes, vertexes or agents) and is the set of local communication channels(edges or links) among the sensors. The Laplacian matrix of is denoted by . The communication network is sparse and time-invariant. Overall Properties and Assumptions The paper focus on developing a distributed estimator over a time-invariant network with time-invariant observation models , and time-invariant dynamics Each agent knows the dynamics model and , the statistics of the initial condition and , the observations model, and , and the network, . The field dynamics and the distributed observations are globally observable but not necessarily locally detectable, i.e., the pair is detectable but are not necessarily detectable. The agent communication network is connected, i.e., the algebraic connectivity of the Laplacian matrix is strictly positive. The system is distributedly observable, i,e., the matrix is full rank, where: Centralized Kalman Filter(CKF)Pseudo-ObservationFor dimensions of the local observations, are different for different agents, we need to introduce pseudo-observations which have the same dimension :Let . The vector form:where . The average pseudo-observations are:$$\\bar{y}i = \\frac{1}{N}\\sum{n=1}^NH_n^TR_n^{-1}z_i^n=Gx_i+\\frac{1}{N}H^TR^{-1}r_i$$ Centralized Kalman FilterFollow the general Kalman filter algorithm: Global Averaging: $\\bar{y}i=\\frac{1}{N}\\sum{n=1}^N y_i^n$ Filtering:$$\\begin{align}K_i^c&amp;=\\left(\\frac{1}{N}(\\Sigma_{i|i-1}^c)^{-1}+G\\right)^{-1} \\\\hat{x}{i|i}^c&amp;=\\hat{x}^c{i|i-1}+K_i^c(\\bar{y}i-G\\hat{x}{i|i-1}^c) \\\\Sigma_{i|i}^c &amp;=(I_M-K_i^cG)\\Sigma_{i|i-1}^c(I_M-GK_i^c)+\\frac{1}{N}K_i^cGK_i^c\\end{align}$$ Prediction:$$\\begin{align}\\hat{x}{i+1|i}^c &amp;= A\\hat{x}{i|i}^c \\\\Sigma^c_{i+1|i} &amp;= A\\Sigma^c_{i|i}A^T+V\\end{align}$$ Distributed Information Kalman Filter(DIKF)PreworkSome pre-definition:In DIFK algorithm, each agent runs two companion sub-routines: dynamic consensus on the pseudo-observations to estimate distributed filtering to estimate the state To achieve dynamic consensus on the pseudo-observations, we define the error process. The agent’s distributed filter and prediction estimates of are and , respectively. The distributed filter error and the distributed prediction error are :$$\\begin{align}\\epsilon^n_{i|i} &amp;= \\hat{x}^n_{i|i}-x_i \\\\epsilon_{i+1|i}^n &amp;= \\hat{x}{i+1}^n-x{i+1}\\end{align}q_i^n = \\hat{y}i^n-Gx_i$$The distributed pseudo-observations error covariance matrix is . Let be the covariance between $\\epsilon{i|i-1}q_i^n$\\hat{x}{i|i} =\\begin{bmatrix}\\hat{x}^1{i|i}\\ \\vdots \\ \\hat{x}^N_{i|i}\\end{bmatrix},\\hat{x}{i+1|i} =\\begin{bmatrix}\\hat{x}^1{i+1|i}\\ \\vdots \\ \\hat{x}^N_{i+1|i}\\end{bmatrix},\\hat{y}{i} =\\begin{bmatrix}\\hat{y}^1{i}\\ \\vdots \\ \\hat{y}^N_{i}\\end{bmatrix},\\begin{align}\\epsilon_{i|i}&amp;=\\hat{x}{i|i}-1_N\\otimes x_i \\\\epsilon{i+1|i}&amp;=\\hat{x}{i+1|i}-1_N\\otimes x{i+1} \\q_i &amp;= \\hat{y}i - 1_N\\otimes(Gx_i)\\end{align}$$The covariance between $\\epsilon{i|i-1}q_i\\Pi_i\\Sigma_{i|i}\\Sigma_{i+1|i}Q_iP_i$ are block matrices of the above vector. Initial Conditions$$\\begin{align}\\hat{x}_{0|-1} &amp;= \\bar{x}0 \\A_G\\hat{y}{-1}^n &amp;= G\\bar{x}0 \\\\Sigma{0|-1} &amp;= J\\otimes \\Sigma_0 \\Q_0 &amp;= \\left( (I_N\\otimes B)\\bar{D}_H-I_N\\otimes G \\right)(J\\otimes \\Sigma_0) \\&amp;\\left(\\bar{D}_H(I_N\\otimes B^T)-I_N\\otimes G \\right)+(I_N\\otimes B)\\bar{D}_H(I_N\\otimes B^T) \\\\Pi_0 &amp;=(J\\otimes \\Sigma_0)\\left(I_N \\otimes G- \\bar{D}_H(I_N\\otimes B^T)\\right)\\end{align}$$ AlgorithmAt time , agents communicate their pseudo-observations estimates to neighbors and implement the following steps: Dynamic Consensus on Pseudo-Observations: $$ \\begin{align} \\hat{y}i^n &amp;= A_G\\sum{l\\in\\Omega_n}w_{nl}\\hat{y}^l_{i-1}+B(y_i^n-H_G^nA_G\\hat{y}{i-1}^n) \\ Q{i+1} &amp;= FQ_iF^T + \\Psi \\end{align} $$ Filtering: $$ \\begin{align} K_i^n &amp;= \\left((Q_i^n+(\\Pi_i^n)^TG)(\\Sigma_{i|i-1}^nG+\\Pi_i^n)^{-1}+G \\right)^{-1} \\ \\hat{x}{i|i}^n &amp;= \\hat{x}{i|i-1}^n + K_i^n(\\hat{y}i^n-G\\hat{x}{i|i-1}^n) \\ \\Sigma_{i|i} &amp;= (I_{MN}-K_i(I_N\\otimes G))\\Sigma_{i|i-1}(I_{MN}-(I_N\\otimes G)K_i^T) \\ &amp;+K_i\\Pi_i^T(I_{MN}-(I_N\\otimes G)K_i^T) \\end{align} $$ Prediction:$$\\begin{align}\\hat{x}{i+1|i}^n &amp;= A\\hat{x}{i|i} \\\\Sigma_{i+1|i} &amp;= (I_N\\otimes A) \\Sigma_{i|i}(I_N\\otimes A^T)+J\\otimes V \\\\Pi_{i+1} &amp;= (I_N\\otimes A)(I_{MN}-K_i(I_N\\otimes G))\\Pi_i F^T \\&amp;+(I_N\\otimes A)K_iQ_iF^T \\&amp;+(J\\otimes A)\\left( I_N\\otimes G-\\bar{D}_H(I_N\\otimes B^T)\\right)\\end{align}$$ where is a stochastic consensus weight matrix; are the estimator gain matrices; and . The error matrix and the noise covariance matrix are: Comparison &amp; Conclusion DIKF is capable of ditributed estimation of the unstable dynamical system with bounded MSE. The simulated MSE of the DIKF has a performance gap of about 2.5dB when compared to the CKF. Note that the distributed gain matrices are computationally expensive, the paper used Monte-Carlo simulate the DIKF with time invariante gain matrices .","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"卡尔曼滤波","slug":"卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"优化算法","slug":"优化算法","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"分布式卡尔曼滤波","slug":"分布式卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"}]},{"title":"web身份认证机制以及Go中的实现","slug":"web身份认证机制以及Go中的实现","date":"2022-03-22T15:56:24.000Z","updated":"2022-03-23T07:35:22.134Z","comments":true,"path":"2022/03/22/web身份认证机制以及Go中的实现/","link":"","permalink":"https://kimanyang.xyz/2022/03/22/web%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8AGo%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"web身份认证机制以及Go中的实现服务端渲染的Session认证模式由于HTTP的无状态性，每个请求间默认是无状态保留的，为了能够识别用户的身份使用了cookie，一般它的大小不大于4KB，由一个Name和Value以及控制其有效期、安全性和适用范围的可选属性构成。不同域名下的cookie相互独立，每次客户端发起请求时会自动把当前域名下所有未过期的cookie一起发送到服务器。 当客户端第一次发起请求的时候，服务器通过响应头的形式向客户端发送一个用于身份认证的cookie，当客户端浏览器每次请求服务器的时候浏览器会自动将身份认证相关的cookie通过请求头的形式发送给服务器以此来验证客户端身份。 需要注意 cookie并不具备安全性，存储在客户端，因此不能够存放隐私数据。整个基于cookie的session认证机制流程如下： 常用的session认证机制需要配合cookie实现，而cookie不支持跨域，在使用时需要额外的配置来实现认证。 前后端分离的JWT认证机制这种机制往往存在于需要跨域请求的场合，JSON Web Token(JWT)是目前最流行的跨域认证解决方案。其工作原理如下所示： 一个加密的JWT由三个部分组成，分别是Header.Payload.Signature，它们之间由点号分割，头部和签名保证Token安全性，比如采用SHA256将盐和用户特定信息进行加密来验证用户的真实性；中间的部分才是真正的用户信息，这部分的加密通常是可逆的比如base64加密，所以仍然不能用户存储重要信息。通常客户端收到JWT后会进行本地存储，然后在每次进行访问的时候将其加在请求的某个地方，通常是和Authorization的首部之中。 总结Cookie&#x2F;Session&#x2F;Token的区别Cookiecookie是一种具体的session实现，是浏览器实现的一种数据存储功能，由于在客户端实现浏览器对其进行了一定的限制。 Session通过上述讨论，我们知道其实session就是一个会话记录，用于区分用户，服务器会临时保存用户的信息用于验证，采用的方法对浏览器来说大多是cookie，但也可以采用别的方式。缺点是： 每次用户请求都需要存储一个session记录，用户数量很多的情况下内存开下巨大 可扩展性较小，多台服务器难以平行扩展，通常需要配置Memcahced专门有一台Session服务器 CORS（跨域资源共享）难以实现，因为cookie并不能跨域使用，需要很多额外配置 CSRF（跨站请求伪造），即用户访问恶意网站被强制执行攻击性代码访问合法网站进行操作，很容易经由cookie实现。 TokenJWT术语Token的一种实现，Token具有如下优点： 无状态、可扩展，不需要服务器存储信息，只需要服务器直到加密算法即可，用户多了可以直接加机器 支持移动设备 跨程序调用，能够和其他设备、APP共享权限 安全，每次客户端请求都需要开发者手动将token放在header中带过去，这就使之不会遭受CSRF攻击 Go框架两种认证方式的具体实现Cookie的使用\\todo Token的使用\\todo 关于Go的跨域\\todo","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"Cookie","slug":"Cookie","permalink":"https://kimanyang.xyz/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"https://kimanyang.xyz/tags/Token/"},{"name":"Session","slug":"Session","permalink":"https://kimanyang.xyz/tags/Session/"},{"name":"身份认证","slug":"身份认证","permalink":"https://kimanyang.xyz/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"}]},{"title":"卡尔曼滤波","slug":"卡尔曼滤波","date":"2022-03-19T15:52:33.000Z","updated":"2022-03-27T11:27:20.055Z","comments":true,"path":"2022/03/19/卡尔曼滤波/","link":"","permalink":"https://kimanyang.xyz/2022/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/","excerpt":"","text":"卡尔曼滤波由于最近要阅读分布式卡尔曼滤波观测器相关的论文，在这里先总结一个基本款的卡尔曼滤波器以及一个扩展滤波器的推导，参考视频教程https://www.bilibili.com/video/BV1ez4y1X7eR。 卡尔曼滤波推导给定状态空间方程：其中是过程噪声，是测量噪声。 我们假定过程噪声满足正态分布，测量噪声也满足正态分布。 由于期望为0，所以协方差矩阵满足：以一个二维的噪声为例：由于均值为0，，于是乎：由于我们没办法给噪声建模，只能根据物理模型和测量结果来对系统状态进行判断：$$\\hat{x}k^-=A\\hat{x}{k-1}+Bu_{k-1} \\z_k = Hx_{km} \\implies \\hat{x}_{km}=H^{-1}z_k\\notag$$其中$\\hat{x}k^-$是先验结果，是我们根据上一次的估计值计算出来的结果，是不带噪声的真实结果而，是测量矩阵，我们用测量值去估计真实值得出的结果就是$\\hat{x}{km}。由于噪声的存在我们得到的两结果都不是真实的，在这里需要用到数据融合：其中K_kH\\in(0,I)，如果它更接近I$则我们更相信测量结果，如果它更接近0则我们更相信计算出来的先验结果。 现在我们的目标转变为寻找一个好的——这被称为卡尔曼增益——从而使得估计值更加接近实际值。 定义实际值与估计值之间的误差为，假设估计误差符合均值为0的正态分布，，那么根据我们之前的推导有：（由于我们所有操作都是线性变换，过程噪声的误差包含其中计算之后仍然是均值为零的正态分布【mark】自己要算一下） 有了这个假设，我们就拥有了对估计结果的criteria，即选取卡尔曼增益使得误差的协方差矩阵的迹尽可能地小。协方差越小则误差更加向均值0集中，则我们的估计结果越好。迹即对角线的和，最小化迹对于协方差矩阵来说便是最小化每个均方差的平方和。 将代入对计算结果进行展开，引入原始模型噪声：结果代入之中：要注意到在这条式子之中随机变量仅仅有先验误差和测量噪声，在实际之中我们通常认为这两者相互独立（【mark】这一步我没有完全理解，需要进行计算验证或其他背景知识） 继续上式的展开，有对称性消去交叉项：$$\\begin{aligned}P &amp;= (I-K_kH)Ee_k^-e_k^{-t}^T+K_kE[v_kv_k^T]K_k^T \\&amp;=(P_k^–K_kHP_k^-)(I-H^TK_k^T)+K_kRK_k^T \\&amp;=P_k^–K_kHP_k^–P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T\\&amp;+K_kRK_k^T\\end{aligned}\\notag其中为先验误差的协方差矩阵，为测量噪声的协方差矩阵。现在我们要做的是最小化，下面计算的迹，注意到互为转置矩阵的两个矩阵迹相等：\\notag对矩阵关于进行求导来求取最小值（当然如果为了严谨得考虑这个函数是一个凸函数，局部最优是全局最优，这里就不加证明了），注意到协方差矩阵为对称矩阵：\\notag$$**remark:**矩阵求导的一些个小结论 自此我们推出了卡尔曼增益的表达式：通常来讲观测矩阵是满秩的、噪声误差和先验估计的协方差矩阵不会是奇异的，卡尔曼增益是有解的。 如果噪声特别大，那么噪声协方差矩阵很大，这会导致更趋向于零矩阵，于是更相信我们计算出来的先验结果 如果噪声特别小，那么结果接近，意味着我们更相信测量出来的结果 现在还有一个问题，我们并不知道是多少。现在将其展开：$$\\begin{aligned}e_k^-&amp;=x_k-\\hat{x}k^- \\&amp;=Ax_k+Bu{k-1}+w_{k-1}-A\\hat{x}{k-1}-Bu{k-1} \\&amp;=A(x_{k-1}-\\hat{x}{k-1})+w{k-1} \\&amp;=Ae_{k-1}+w_{k-1}\\end{aligned}\\notag将上式代入到之中得到：\\notag$$自此我们可以给出卡尔曼滤波器每一步的计算流程： 预测步骤，利用上一步的结果做先验计算： 计算状态先验估计：$\\hat{x}k^-=A\\hat{x}{k-1}+Bu_{k-1}$ 计算先验协方差矩阵： 矫正步骤，通过测量的结果对正式估计结果进行矫正： 计算卡尔曼增益： 给出最后的后验估计： 更新步骤：对本次计算的和估计进行保存，留作下次使用 算法在实现上是十分简洁明了的，但是在推导过程中利用的数据融合思想、迭代算法思想、最优化思想、动态规划思想的使用都十分巧妙。 当然我们还剩下最后的一点问题： 迭代算法的初值以及噪声的协方差矩阵需要给出，目前的算法是随便估计一下，的初值一般取单位阵 卡尔曼滤波器针对的系统是线性系统，滤波器本身也是线性滤波器 扩展卡尔曼滤波器扩展卡尔曼滤波器（Extended Kalman Filter, EKF)针对卡尔曼滤波器只能应用于线性系统方面做出了改进，能够适应非线性系统。 考虑系统：这里的主要问题是经过非线性变换的噪声不一定符合正态分布，扩展卡尔曼滤波采用最简单的泰勒展开局部线性化进行处理。 由于系统有误差，我们无法在真实点进行泰勒展开，于是退而求其次令在上一次的后验估计$\\hat{x}{k-1}处进行线性化。展开如下：$x_k=f(\\hat{x}{k-1},u_{k-1},w_{k-1})+J_A(x_{k-1}-\\hat{x}{k-1})+J_Ww{k-1}\\notag$$由于误差不可得在非线性项里将其近似为0，和为雅可比矩阵，具体参考非线性控制章节的MIMO系统局部线性化。 同样我们对观测函数在进行局部线性化：$$z_k = h(\\tilde{x}_k,v_k)+J_H(x_k-\\tilde{x}k)+J_Vv_k$$由于误差$v{k-1}不可得在非线性项里将其近似为，J_H=\\frac{\\partial h}{\\partial x}和J_V=\\frac{\\partial h}{\\partial v}$为雅可比矩阵。 于是我们的到线性化的系统：$$\\begin{aligned}x_k &amp;= \\tilde{x}{k-1}+J_A(x{k-1}-\\hat{x}{k-1})+J_Ww{k-1} \\z_k &amp;= \\tilde{z}{k-1}+J_H(x_k-\\tilde{x}{k-1})+J_Vv_k\\end{aligned}$$其中$\\tilde{x}{k-1}=f(\\hat{x}{k-1},u_{k-1},0)，\\tilde{z}{k-1}=h(\\tilde{x}{k-1},0)。其中发现有一项x_k-\\tilde{x}_{k-1}$不是很和谐，这就是我们对展开点做出取舍之后的结果，在小范围内仍然有效。 经过这种近似变换，误差的分布仍然是高斯分布，不过相比原来多了一部分区别：有了局部线性化，接下来跟着传统卡尔曼滤波的流程走一遍; 预测步骤，利用上一步的结果做先验计算： 计算状态先验估计 $\\hat{x}k^-=f(\\hat{x}{k-1},u_{k-1},0)$ 计算先验协方差矩阵 矫正步骤，通过测量的结果对正式估计结果进行矫正： 计算卡尔曼增益： 给出最后的后验估计： 更新步骤：对本次计算的和估计进行保存，留作下次使用 自此扩展卡尔曼滤波器介绍完毕。","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"卡尔曼滤波","slug":"卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"扩展卡尔曼滤波","slug":"扩展卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"优化算法","slug":"优化算法","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"}]},{"title":"MPC模型预测控制推导与实现","slug":"MPC模型预测控制推导","date":"2022-03-16T03:07:33.000Z","updated":"2022-03-27T11:27:20.380Z","comments":true,"path":"2022/03/16/MPC模型预测控制推导/","link":"","permalink":"https://kimanyang.xyz/2022/03/16/MPC%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"MPC模型预测控制推导与实现考虑MIMO控制系统，给定代价函数给定正定的和，设计控制器使得代价函数最小。 上述的建模即最基本的最优化控制理念，下面我们考虑模型预测控制。 模型预测控制概念通过模型预测系统在某一段时间内的表现来进行优化控制即模型预测控制(Model Prediction Control)。这种控制方法多用于数位控制，采用离散型的状态空间模型来进行表达：对于一次控制来说，大致有三个步骤，在时刻： 估计、测量当前的系统状态 基于来进行最优化控制:其中状态的未来N个时刻的范围为预测窗口/区间(Predictive Horizon)，控制器输出的未来N个时刻为控制窗口(Control Horizon)，为最终误差项，即预测最末时刻误差代价函数。 仅取作为我们的控制量输出，即每次输出都需要将控制窗口和预测窗口向右移动来进行新一轮计算和控制输出 简单来说就是在每一步都求解一个优化问题，这对控制器计算能力要求十分高；除此以外优化问题还需要进一步考虑系统的约束条件。 二次规划（Quadratic Programming)最优化建模二次规划是常见的凸问题，将代价函数设计为二次规划函数进而求取最小化凸代价函数是常见的一种策略，其基本形式。其中正定。继续考虑我们的离散系统，在时刻定义：$$\\begin{aligned}\\hat{X}_k&amp;=[x(k|k),x(k+1|k),\\cdots,x(k+N|k)]^T \\\\hat{U}k&amp;=[u(k|k),u(k+1|k),\\cdots,u(k+N|k)]^T\\end{aligned}作为状态预测与控制输出预测矩阵。出于简单考虑，定义输出函数即为状态，参考输入为，则基于二次规划的代价函数可以定义为：\\begin{aligned}J&amp;=\\sum^{N-1}{i=0}(x(k+i|k)^TQx(k+i|k)+u(k+i|k)^TRu(k+i|k))\\&amp;+x(k+N|k)^TFx(k+N|k)\\end{aligned}由于我们的优化变量是，所以需要消除代价函数中的项，一种直观的想法是采用迭代计算：通过前面定义的状态预测矩阵和化简上述公式：\\hat{X}_k=x_k+\\hat{U}_k将上述式子简化：\\label{sim}\\begin{aligned}&amp;M\\triangleq ^T \\&amp;C\\triangleq\\\\hat{X}k&amp;=Mx_k+C\\hat{U_k}\\end{aligned}进一步化简我们的代价函数：\\label{costmat}\\begin{aligned}J&amp;=\\sum^{N-1}{i=0}(x(k+i|k)^TQx(k+i|k)+u(k+i|k)^TRu(k+i|k))\\&amp;+x(k+N|k)^TFx(k+N|k) \\&amp;=\\hat{X_k}^T\\hat{X}_k + U_k^TU_k\\&amp;=\\hat{X}_k\\bar{Q}_F\\hat{X}_k+U_k^T\\bar{R}U_k\\end{aligned}将式子代入中可得：$$其中, , 至此代价函数的形式转换为一个标准的二次规划形式问题，包括一个常数项、线性项和二次项。 代码实现由上述的模型预测控制推导，给出如下核心代码： 123456789101112131415161718192021222324252627282930313233343536373839function [M,C,Q_bar,R_bar,G,E,H,U_k] = MPC_Zero_Ref(A,B,N,x_k,Q,R,MPC_Zero_RefmyFun)n = size(A,1); % 获取矩阵的维度np = size(B,2); % 获取控制输入的维度pM = [eye(n);zeros(N*n,n)]; % 初始化 M 矩阵，单位阵+0部分C = zeros((N+1)*n, N*p); % 初始化 C 矩阵tmp = eye(n);for i=1:N rows = i * n + (1:n); % 当前要填满的其实行数 C(rows,:)=[tmp*B,C(rows-n,1:end-p)]; tmp = A*tmp; M(rows,:)=tmp;end% 定义Q_bar和R_barS_q = size(Q,1) % 获取 Q 的维度S_r = size(R,1) % 获取 R 的维度Q_bar = zeros((N+1)*S_q, (N+1)*S_q); % 初始化 Q_bar 矩阵% 获得 Q_barfor i:=0:N Q_bar(i*S_q + 1:(i+1)*S_q,i*S_q+1:(i+1)*S_q)=Q; end% 获得 R_barfor i=0:N-1 R_bar(i*S_r+1:(i+1)*S_r,i*S_r+1:(i+1)*S_r)=R;end% 求解所需矩阵 G E HG = M' *Q_bar*M;E = C' *Q_bar*M;H = C' *Q_bar*C+R_bar;% 二次规划问题最优化求解f = (x_k' * E')';U_k = quadprog(H,f); end","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"模型预测控制","slug":"模型预测控制","permalink":"https://kimanyang.xyz/tags/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/"},{"name":"matlab","slug":"matlab","permalink":"https://kimanyang.xyz/tags/matlab/"},{"name":"二次规划","slug":"二次规划","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/"}]},{"title":"多智能体相关代数图论知识总结","slug":"图论知识总结","date":"2022-03-15T02:12:33.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/03/15/图论知识总结/","link":"","permalink":"https://kimanyang.xyz/2022/03/15/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"图论知识总结本文的 图和图模型术语总结 部分是离散数学中的基础知识，方便 多智能体相关的代数图论 部分随时查阅。文章旨在快速总结补全阅读多智能体领域论文的基础图论知识。 图和图模型术语总结图的类型 类型 边 允许多重边 允许环 简单图 无向 否 否 多重图 无向 是 否 伪图 无向 是 是 简单有向图 有向 否 否 有向多重图 有向 是 是 混合图 有向和无向 是 是 完全图 无向 否 否 所谓多重边指的是两个顶点间存在多条连接的边 所谓完全图指的是任意两个顶点之间都存在直接通路的简单无向图 图的基本术语定义 若和是无向图中的一条边的端点，则称两个顶点和在里邻接。这样的边称为关联顶点和，也可以说连接和 在图中，顶点的所有相邻集合，记作，称为顶点的邻居。若是的子集，则表示图中至少和中一个定点相邻的所有顶点的集合，即 在无向图中，顶点的**度(degree)**指的是与该顶点相关联的边的数目（但顶点上的环为其做出双倍贡献），顶点的度记作 当是带有有向边的图的边时，说邻接到，而且说从邻接，顶点称为的起点，顶点称为的终点，环的起点和终点是相同的 在带有有向边的图里，顶点的入度记作，指以作为终点的边数，顶点的出度记作，是以作为起点的边数 若把简单图的顶点集分成两个不相交的非空集合和，使得图中每一条边都连接中的一个顶点与中的一个顶点（因此中没有边连接中的两个顶点或两个顶点），则称为二分图，称为的一个二分划分 平衡图指每个顶点的出度和入度都相等的图 定理 设是有条边的无向图，则 无向图有偶数个度为奇数的顶点（由1可直接推出） 设是带有有向边的图，那么有： 一个简单图是二分图当且仅当能够对图中每一个顶点赋予两种不同的颜色（算法搜索遍历染色判断二分图） 图的构造相关定义 图的真子图是图，其中且。若，则称图的子图是的真子图 令是一个简单图，图是由顶点集的子集导出的子图，其中边集包含中的一条边当且仅当这条边的两个顶点都在中 图的构造方法 删除或增加图中的边 边的收缩：删除顶点和之间的边后吧两个顶点合并 从图中删除顶点：删除顶点同时移除与之相关联的边 图的并集 连通性通路定义：形式化不给了，非形式化：通路是边的序列，从一个顶点开始沿着边行进到相邻顶点，如果通路不包含相同的边则成为简单通路。如果一条通路开始和结束都是相同的顶点则称为回路 连通性定义： 若无向图每一对不同的顶点之间都有通路则称该图是连通的，否则为不连通的。连通无向图的每一对不同顶点之间都存在简单通路。 若对于有向图中的任意顶点和，都有从到的通路，则该图是强连通的。若有向图的基本无向图（去掉边的方向）是连通的，那么有向图弱连通。 欧拉通路定义图的欧拉回路是包含每一条边的简单回路。图中的欧拉通路是包含的每一条边的简单通路。 充要条件 至少有两个顶点的图具有欧拉回路当且仅当它每个顶点的度都为偶数。 连通多重图具有欧拉通路但无欧拉回路当且仅当它恰有两个度为奇数的顶点。 生成树定义：如果是简单图，则的生成树是包含每个顶点的的子图且为树。有生成树的图必然是联通的，每个连通图也必然有生成树。关于连通定义见连通性一节。 多智能体相关的代数图论多智能体的一致性和多智能体之间的交流结构密切相关，这些交流结构的抽象就是图。 图矩阵一张图G的结构和属性可以通过研究和G相关的矩阵来揭示，这就是代数图论（algerbraic graph theory）。一个N节点的G中边的权重系数可以构成一个邻接矩阵（adjacency matrix）：在多智能体中采用的通常是带权有向图，于是邻接矩阵不一定是对称的。如下图所示的两个顶点，图中所有的边集称为，如果顶点之间的边，则；否则。默认每个节点知道自己的信息，不需要和自己通信，所以有对角元素。 定义一个顶点的加权入度(weighted in-degree)为的第行所有元素之和：$$\\label{indegree}d_i=\\sum^{N}{j=1}a{ij}$$定义节点的加权出度(weighted out-degree)为的第列所有元素之和： Laplacian矩阵拉普拉斯(Laplacian)矩阵，即矩阵在多智能体体系中十分重要。 首先定义入度矩阵，表示以加权入度元素作为主对角线元素的对角矩阵。 矩阵定义为：。 直观上感受一下一个矩阵和矩阵： 写出其邻接矩阵：根据的定义，于是矩阵如下：从其定义可以看出矩阵每一行的所有元素之和为0。 矩阵的特征值和特征向量实数矩阵能够转换为若当标准型，变换矩阵为其左右特征向量组成的矩阵，这部分基础知识不再赘述。由于矩阵行的和为0，有：其中，，c为任意非零常数。 由此我们可以得出矩阵的一个特征值为0，特征向量为。 给出如下一个定理：如果有生成树，则的稚为，有且仅有一个相对应的右特征向量。 我们对几种图的矩阵进行总结： 由于L矩阵行和为0，所有图的第一个特征值都为0 对于所有无向图，其特征值都为实数 N节点完全图的所有非零特征值为 有向树的所有非零特征值 有向N循环图的N个特征值均匀分布在以（1,0）为圆心，1为半径的圆上，且第一个特征值为0 矩阵及代数图论几个引理：有向图至少有一个零特征值，其特征向量为且所有的非零特征值都具有正实部。如果图有有向生成树，则代数重数为1且是唯一的。 对于无向图来说，矩阵的特征值代数重数为1当且仅当图是联通的。最小的非零特征值：对于无向图，如果我们已知是半正定的，那么我们不难验证如下的平方和性质(SOS-property)：其中表示向量的第个分量。对于强连通图和有向平衡图来说，拉普拉斯矩阵正定的条件是满足的，证明略。 进一步我们讨论拉普拉斯矩阵是一个一般的奇异阵的情况，可以获得如下的一些结论。 如果图是强连通的，那么其拉普拉斯矩阵的零特征值存在一个正的左特征向量，且满足：其中。 对于一个强连通图及其拉普拉斯矩阵，我们定义其广义代数连通性：其中和的定义在中已经给出。对于平衡图，我们有：其中是提取括号内的最小非零特征值。 拉普拉斯矩阵对于多智能体的一致性考察十分有用。 假设有、图的邻接矩阵、拉普拉斯矩阵。对于闭环系统，定义一致性为，这种一致性满足当且仅当具有有向生成树。进一步的，最终一致时收敛的值可以由给出，其中是正则化的拉普拉斯矩阵零特征值左特征向量。 除了我们定义的拉普拉斯矩阵，拉普拉斯矩阵可以写作另外一种形式：。如果存在某一个顶点入度为0，那么是奇异矩阵，我们令来使之满足矩阵定义。我们将和称为正则化的邻接矩阵和拉普拉斯矩阵。 正则化的拉普拉斯矩阵具有一个以为右特征向量的零特征值，且所有的特征值都分布在以(1,0)为圆心，1为半径的复平面圆盘上。进一步的，0的代数重数为1当且仅当图具有有向生成树。 随机矩阵对于求解离散多智能体问题来说更加便利。对于一个具有个节点的有向图，其行随机矩阵被定义为，我们定义如果 则，，否则矩阵项为0，同时满足。对于无向图也可以类似的进行定义不过其随机矩阵是一个对称矩阵，这意味着它同时是行随机矩阵和列随机矩阵。显然随机矩阵的行和是1，那么显然它具有特征值1且与之相关的特征向量是。 由盖尔圆盘定理可以得知的所有特征值，要么在以原点为中心的开单位圆盘上，要么等于1。进一步的，当且仅当图具有有向生成树时1的代数重数为1。 假设，那么对于闭环的离散系统来说，一致性可以定义为。其中且时所有顶点的入度中最大的，这种一致性能够满足当且仅当图具有有向生成树。进一步的，最终一致时收敛的值可以通过得到，其中是正则化的特征向量，其特征值为1。","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"多智能体","slug":"多智能体","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"},{"name":"图论","slug":"图论","permalink":"https://kimanyang.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"一致性","slug":"一致性","permalink":"https://kimanyang.xyz/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"}]},{"title":"JS中正则表达式使用总结","slug":"JS中正则表达式使用总结","date":"2022-03-13T04:15:14.000Z","updated":"2022-03-13T05:26:57.134Z","comments":true,"path":"2022/03/13/JS中正则表达式使用总结/","link":"","permalink":"https://kimanyang.xyz/2022/03/13/JS%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"JS中正则表达式使用总结详细的规则参考MDN文档：正则表达式 - JavaScript | MDN (mozilla.org)。 好用的正则工具：在线正则表达式测试 (oschina.net) 使用方法在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。 脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用预先定义的正则规则可获得更好的性能。 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。语法：regexObj.exec(str) test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。语法：regexObj.test(str) match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。语法：str.match(regexp) matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。语法：str.matchAll(regexp) search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。语法：str.search(regexp) replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。语法：&#96;str.replace(regexp split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。语法：str.split([separator[, limit]]) 元字符 边界符（表示匹配边界），^表示开头，$表示结尾 量词（表示重复次数） 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n次到m次（左闭右闭） 字符类（表示特定字符集），[]匹配字符集合，诸如 /[aeiou]/,元音集合 /[a-z]/,/[a-zA-Z]/,/[0-9]/小写字母、大小写数字 [^aeiou],[^a-z]非元音，非小写字母 .通配符，匹配任意字符 x|y选择符，匹配x或y 预定类 说明 \\d 匹配0-9之间的任意数字，[0-9] \\D 匹配所有0-9以外的字符，[^0-9 ] \\w 匹配任意字母、数字和下划线，[A-Za-z0-9_] \\W 匹配任意字母、数字和下划线以外，[^A-Za-z0-9_] \\s 匹配空格（换行符、制表符和空格），[\\t\\r\\n\\v\\f] \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f] 经典例子： 用户名验证：英文字母、数字、下划线和短横线组成的6-16位用户名/^[a-zA-Z0-9-_]&#123;6,16&#125;$/ 用户只能输入中文：/^[\\u4e00-\\u9fa5]+/ 日期格式：^/\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;/ 高级特性 捕获：(xyz)|(abc)，匹配并记忆整个括号中的内容，使得后面的作用符作用于前面的整个表达式 非捕获：(?:foo)+ 12345678let personList = `First_Name: John, Last_Name: DoeFirst_Name: Jane, Last_Name: Smith`;let regexpNames = /First_Name: (\\w+), Last_Name: (\\w+)/mg;let match = regexpNames.exec(personList);do &#123; console.log(`Hello $&#123;match[1]&#125; $&#123;match[2]&#125;`);&#125; while((match = regexpNames.exec(personList)) !== null); ​ 上述代码的(\\w+)采用非捕获(?:\\w+)则不会输出$&#123;match[1]&#125;和$&#123;match[2]&#125;，但是性能会相应提高 正向否定查找：x(?!y)，仅当x后不跟着y时匹配x 反向否定查找：(?&lt;!y)，仅当x前面不是y时匹配x 先行断言：x(?=y)，仅当x后面跟着y时匹配x 后行断言：(?&lt;=y)x，仅当x前面跟着y时匹配x 使用组与命名组 12345678910111213141516let users= `姓氏: 李, 名字: 雷姓氏: 韩, 名字: 梅梅`;let regexpNames = /姓氏: (?&lt;first&gt;.+), 名字: (?&lt;last&gt;.+)/mg;let match = regexpNames.exec(users);/* [ &quot;姓氏: 李, 名字: 雷&quot;, &quot;李&quot;, &quot;雷&quot; ] groups: first:&quot;李&quot; last:&quot;雷&quot; index:0 length:3*/ 标志位 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 s 允许 . 匹配换行符。 u 使用unicode码的模式进行匹配。 y 执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/tags/Javascript/"}]},{"title":"BOM对象相关","slug":"BOM对象相关","date":"2022-03-11T07:38:19.000Z","updated":"2022-03-13T05:26:26.601Z","comments":true,"path":"2022/03/11/BOM对象相关/","link":"","permalink":"https://kimanyang.xyz/2022/03/11/BOM%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/","excerpt":"","text":"BOM对象相关基本概念 BOM(Browser Object Model ) 是浏览器对象模型 window 是浏览器内置中的全局对象，我们所学习的所有 Web APIs 的知识内容都是基于 window 对象实现的 window 对象下包含了 navigator、location、document、history、screen 5个属性，即所谓的 BOM （浏览器对象模型） document 是实现 DOM 的基础，它其实是依附于 window 的属性。 依附于 window 对象的所有属性和方法，使用时可以省略 window 定时器-延时函数和之前所学的setInterval不同 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeou 语法let timer = setTimeout(回调函数, 等待毫秒数) 清除延时函数语法： clearTimeout(timer) 可用于诸如5秒广告消失之类的需求 小技巧，可以通过递归调用来实现类似setInterval的功能： 1234567let myInterval = () =&gt; &#123; //do something repeated //... //recursive call setTimeout(myInterval,1000);&#125;myInterval() 两种定时器对比： setInterval 的特征是重复执行，首次执行会延时 setTimeout 的特征是延时执行，只执行 1 次 setTimeout 结合递归函数，能模拟 setInterval 重复执行 clearTimeout 清除由 setTimeout 创建的定时任务 JS执行机制简述同步与异步机制 同步机制在主线程上执行，形成执行栈 异步任务通过回调函数实现，存在三种类型： 普通事件：click/resize等 资源加载：load&#x2F;error等 定时器，包括setInterval/setTimeout 异步任务相关添加到任务队列中，任务队列也成为消息队列 更详细的内容参考另一篇博文Promise与异步模型 location对象其数据类型是对象，拆分保存了url地址的各个组成部分。location对象的常用属性和方法如下： href属性获取完整的url地址，对其赋值时用于地址的跳转 用例：五秒延时后转到同域下另一个界面 1setTimeout(()=&gt;&#123;location.href=&#x27;页面链接&#x27;&#125;, 5000) search属性获取地址中携带的参数，即?后的部分 hash属性获取地址的哈希值，即符号#后的部分 reload方法用于刷新当前页面，传入参数true时表示强制刷新 navigator对象其数据类型是对象，几率了浏览器自身的相关信息，最常用的用途是通过userAgent检测浏览器版本和平台来决定渲染的页面。 1234567891011// 检测 userAgent（浏览器信息）!(function () &#123;const userAgent = navigator.userAgent// 验证是否为Android或iPhoneconst android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)// 如果是Android或iPhone，则跳转至移动站点if (android || iphone) &#123;location.href = &#x27;http://m.itcast.cn&#x27;&#125;&#125;)() *关于匿名函数调用：javascript 函数前面的一元操作符 (colobu.com)*，这是一种消除编译器歧义的方法。 history对象用于和浏览器地址栏的操作相对应的一些操作，比如前进、后退、历史记录等等，常用的属性方法： history对象方法 作用 back() 后退 forward() 前进 go() 传入参数n为正就前进n步，负就后退n swiper插件的使用本地存储(sessionStorage)的使用localStorage 生命周期永久生效，除非手动删除 否则关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 使用方法： 123localStorage.setItem(key, value)//存储数据localStorage.getItem(key) //获取数据localStorage.removeItem(key) //删除数据 sessionStorage 生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 以键值对的形式存储使用 用法跟localStorage 基本相同","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/tags/Javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-08T15:35:06.928Z","updated":"2022-03-08T15:35:06.929Z","comments":true,"path":"2022/03/08/hello-world/","link":"","permalink":"https://kimanyang.xyz/2022/03/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"DOM-事件相关(3)","slug":"DOM-事件相关(3)","date":"2022-03-08T10:11:14.000Z","updated":"2022-03-10T15:37:53.571Z","comments":true,"path":"2022/03/08/DOM-事件相关(3)/","link":"","permalink":"https://kimanyang.xyz/2022/03/08/DOM-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3(3)/","excerpt":"","text":"DOM事件相关(3)滚动事件scroll事件在页面进行滚动的时候触发，用于监听整个页面的滚动，个人感觉可以拿来做懒加载。除此以外还有一些网页需要检测用户页面滚动到某个区域之后进行一些处理，比如固定导航栏或返回顶部等。 使用方法： 12345678//整个页面,document也可以window.addEventListener(&#x27;scroll&#x27;,()=&gt;&#123; //do somthing&#125;)//某个元素ele.addEventListener(&#x27;scroll&#x27;,()=&gt;&#123; //do somthing&#125;) 加载事件load事件实在外部资源（图片、外联CSS、外联JS）加载完毕时进行触发。老旧代码的script写在头部此时时没办法访问body的DOM元素的，于是有了： 123456&lt;script&gt; window.addEventListener(&#x27;load&#x27;, function () &#123; let div = document.querySelector(&#x27;div&#x27;) console.log(div) &#125;) &lt;/script&gt; 的过时写法。 另外有DOMContentLoaded事件，给 document 加该事件,当初始的 HTML 文档被完全加载和解析完成 之后DOMContentLoaded 事件被触发，而无需等待样式 表、图像等完全加载。 元素大小与位置的获取方法scroll系列 获取宽高： 获取元素内容的总宽高（不包含滚动条），返回值不带单位 scrollWidth和scrollHeight属性 获取位置： 获取元素往左和往上滚动出去看不到的距离 scrollLeft和scrollTop 这两个属性可修改 具体使用方法： 123456window.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; // 在得到页面滚动的距离 scrollTop console.log(document.documentElement.scrollTop) //直接固定了页面滚动距离，其他东西看不见 // document.documentElement.scrollTop = 500&#125;) offset系列使用场景：滚动到某个元素就做某些事，而不是像scroll属性一样需要算好位置才能够做某些事 获取宽高 获取元素自身宽高、包含元素自身设置的宽高、padding、border offsetLeft和offsetHeight 获取位置 获取元素距离自己定位父级的元素左上距离 无定位则以 文档左上角 为准 offsetLeft和offsetTop是只读属性 案例：固定导航栏 当页面滚动到秒杀模块的时候导航栏自动滑入，否则滑出 使用页面滚动事件 检测页面滚动 大于等于 模块位置 则滑入，否则滑出 模板代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .nav &#123; position: fixed; display: none; width: 100%; height: 40px; font-size: 20px; font-weight: 700; line-height: 40px; text-align: center; background-color: blueviolet; z-index: 99; &#125; .content &#123; position: relative; width: 100%; height: 8000px; background-color: pink; &#125; .trigger &#123; position: absolute; top:700px; width: 590px; height: 590px; background-color: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt;这里是导航栏&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;trigger&quot;&gt;出发点&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 脚本实现： 12345678910let nav = document.querySelector(&#x27;.nav&#x27;)let trigger = document.querySelector(&#x27;.trigger&#x27;)window.addEventListener(&#x27;scroll&#x27;, (e) =&gt; &#123; if(document.documentElement.scrollTop &gt;= trigger.offsetTop) &#123; nav.style.display = &#x27;block&#x27; &#125; else &#123; nav.style.display = &#x27;none&#x27; &#125;&#125;) client系列 获取宽高 获取元素可见部分（不包含边框和滚动条等）的宽高 clientWidth和clientHeight 获取位置 获取左边框和上边框宽度 clientLeft和clientTop是只读属性 典型应用：背景窗口变化时触发事件（变色、布局）123456789101112window.addEventListener(&#x27;resize&#x27;, function () &#123; // console.log(111) let w = document.documentElement.clientWidth // console.log(document.documentElement.clientWidth) if (w &gt;= 700) &#123; document.body.style.backgroundColor = &#x27;pink&#x27; &#125; else if (w &gt; 540) &#123; document.body.style.backgroundColor = &#x27;hotpink&#x27; &#125; else &#123; document.body.style.backgroundColor = &#x27;deeppink&#x27; &#125;&#125;) 经典案例：轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; li &#123; list-style: none; &#125; .main &#123; width: 700px; margin: auto; background: #000; &#125; .slides &#123; height: 320px; position: relative; &#125; .slides ul li &#123; /* display: none; */ position: absolute; top: 0; left: 0; opacity: 0; /* 这里实现淡入淡出的关键 */ transition: all .3s; &#125; /*权重20*/ .slides .active &#123; /* display: block; */ opacity: 1; &#125; /*定位，无所谓高度，还挺好的*/ .slides .extra &#123; width: 700px; height: 53px; line-height: 53px; position: absolute; bottom: 0px; background-color: rgba(0, 0, 0, 0.8); z-index: 10; &#125; .slides .extra h3 &#123; width: 82%; margin: 0; margin-right: 20px; padding-left: 20px; color: #98E404; font-size: 28px; float: left; font-weight: 500; font-family: &quot;Microsoft Yahei&quot;, Tahoma, Geneva; &#125; .slides .extra a &#123; width: 30px; height: 29px; display: block; float:left; margin-top: 12px; margin-right: 3px; background-image: url(./assets/icon_focus_switch.png); &#125; /*精灵图样式切换*/ .slides .extra .prev &#123; background-position: 0 0; &#125; .slides .extra .prev:hover &#123; background-position: -30px 0; &#125; .slides .extra .next &#123; background-position: -60px 0; &#125; .slides .extra .next:hover &#123; background-position: -90px 0; &#125; /*下方导航栏列表*/ .indicator ul &#123; margin-left: 4px; overflow: hidden; &#125; .indicator ul li &#123; position: relative; float: left; width: 60px; height: 60px; margin: 10px 4px 10px 5px; text-align: center; cursor: pointer; &#125; .indicator li img &#123; display: block; border: 0; text-align: center; width: 100%; height: 100%; &#125; /*下方轮播栏的激活显示*/ .indicator li .mask &#123; width: 60px; height: 60px; /*为了使其浮动至当前图片上方*/ position: absolute; top:0; left: 0; background-color: rgba(0, 0, 0, 0.4); &#125; .indicator li .border &#123; display: none; width: 54px; position: absolute; bottom: 0; left: 0; z-index: 10; border: 3px solid #98e404; &#125; /*激活样式*/ .indicator .active .mask &#123; display: none; &#125; .indicator .active .border &#123; display: block; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;slides&quot;&gt; &lt;ul&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_01.jpg&quot; alt=&quot;第1张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_02.jpg&quot; alt=&quot;第2张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_03.jpg&quot; alt=&quot;第3张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_04.jpg&quot; alt=&quot;第4张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_05.jpg&quot; alt=&quot;第5张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_06.jpg&quot; alt=&quot;第6张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_07.jpg&quot; alt=&quot;第7张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_08.jpg&quot; alt=&quot;第8张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_09.jpg&quot; alt=&quot;第9张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_10.jpg&quot; alt=&quot;第9张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;extra&quot;&gt; &lt;h3&gt;第1张图的描述信息&lt;/h3&gt; &lt;a class=&quot;prev&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a class=&quot;next&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;indicator&quot;&gt; &lt;ul&gt; &lt;li class=&quot;active&quot;&gt; &lt;img src=&quot;assets/s_01.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_02.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_03.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_04.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_05.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_06.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_07.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_08.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_09.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_10.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let curIdx = 0 let bigPicItems = document.querySelectorAll(&#x27;.slides ul li&#x27;) let smallPicItems = document.querySelectorAll(&#x27;.indicator ul li&#x27;) let text = document.querySelector(&#x27;.extra h3&#x27;) let nextBtn = document.querySelector(&#x27;.next&#x27;) let prevBtn = document.querySelector(&#x27;.prev&#x27;) let main = document.querySelector(&#x27;.main&#x27;) let total = smallPicItems.length /*鼠标经过操作*/ for(let i = 0;i &lt; total;i++) &#123; smallPicItems[i].addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123; bigPicItems[curIdx].classList.remove(&#x27;active&#x27;) smallPicItems[curIdx].classList.remove(&#x27;active&#x27;) smallPicItems[i].classList.add(&#x27;active&#x27;) bigPicItems[i].classList.add(&#x27;active&#x27;) text.innerHTML = `第$&#123;i+1&#125;张图的描述信息` curIdx = i &#125;) &#125; /*按钮操作*/ let shilftPic = (newIdx) =&gt; &#123; smallPicItems[newIdx].classList.add(&#x27;active&#x27;) bigPicItems[newIdx].classList.add(&#x27;active&#x27;) smallPicItems[curIdx].classList.remove(&#x27;active&#x27;) bigPicItems[curIdx].classList.remove(&#x27;active&#x27;) text.innerHTML = `第$&#123;newIdx+1&#125;张图的描述信息` curIdx = newIdx &#125; nextBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; let newIdx = (curIdx + 1) % total shilftPic(newIdx) &#125;) prevBtn.addEventListener(&#x27;click&#x27;,() =&gt; &#123; let newIdx = (curIdx - 1)&lt;0 ? (total - 1) : (curIdx - 1) shilftPic(newIdx) &#125;) /*定时器操作*/ let timer = setInterval(()=&gt;&#123;nextBtn.click()&#125;,1000) main.addEventListener(&#x27;mouseenter&#x27;,()=&gt;&#123; clearInterval(timer) &#125;) main.addEventListener(&#x27;mouseleave&#x27;,()=&gt;&#123; timer = setInterval(()=&gt;&#123;nextBtn.click()&#125;,1000) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 经典案例：手风琴看着挺帅的，但意外地挺好实现，重点在于transition属性的使用。 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &lt;style&gt; ul &#123; list-style: none; &#125; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 1200px; height: 400px; margin: 50px auto; border: 1px solid red; overflow: hidden; &#125; div li &#123; width: 240px; height: 400px; float: left; transition: all 500ms; &#125; div ul &#123; width: 1200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/4.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/5.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; 脚本： 1234567891011121314let lis = document.querySelectorAll(&#x27;li&#x27;)for (let i = 0; i &lt; lis.length; i++) &#123; lis[i].addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123; for (let j = 0; j &lt; lis.length; j++) &#123; lis[j].style.width = &#x27;100px&#x27; &#125; this.style.width = &#x27;800px&#x27; &#125;) lis[i].addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123; for (let j = 0; j &lt; lis.length; j++) &#123; lis[j].style.width = &#x27;240px&#x27; &#125; &#125;)&#125; 经典案例——电梯导航图这是对于scroll&#x2F;offset二者的综合应用，具体实现如下 模板： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .aside &#123; position: fixed; left: 0; top: 50%; transform: translateY(-50%); &#125; .item &#123; height: 40px; line-height: 40px; text-align: center; padding: 0 10px; cursor: pointer; &#125; .active &#123; background-color: red; color: #fff; &#125; .content &#123; width: 660px; margin: 400px auto; &#125; .neirong &#123; height: 300px; margin-bottom: 20px; color: #fff; &#125; .content1 &#123; background-color: red; &#125; .content2 &#123; background-color: blue; &#125; .content3 &#123; background-color: orange; &#125; .content4 &#123; background-color: yellowgreen; &#125;&lt;/style&gt; 脚本： 12345678910111213141516171819202122let items = document.querySelectorAll(&#x27;.aside .item&#x27;)let contents = document.querySelectorAll(&#x27;.content .neirong&#x27;)let total = contents.lengthlet curIdx = 0window.addEventListener(&#x27;scroll&#x27;, (e) =&gt; &#123; let curPos = document.documentElement.scrollTop; items[curIdx].classList.remove(&#x27;active&#x27;) for (let i = 0; i &lt; total; i++) &#123; curIdx = curPos &gt;= contents[i].offsetTop ? i : curIdx &#125; items[curIdx].classList.add(&#x27;active&#x27;)&#125;)for (let i = 0; i &lt; total; i++) &#123; items[i].addEventListener(&#x27;click&#x27;, () =&gt; &#123; items[curIdx].classList.remove(&#x27;active&#x27;) items[i].classList.add(&#x27;active&#x27;) curIdx = i document.documentElement.scrollTop = contents[curIdx].offsetTop &#125;)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"页面事件","slug":"页面事件","permalink":"https://kimanyang.xyz/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/"},{"name":"前端经典案例","slug":"前端经典案例","permalink":"https://kimanyang.xyz/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"}]},{"title":"DOM-事件相关(2)","slug":"DOM-事件相关(2)","date":"2022-03-07T08:28:14.000Z","updated":"2022-03-10T15:37:11.346Z","comments":true,"path":"2022/03/07/DOM-事件相关(2)/","link":"","permalink":"https://kimanyang.xyz/2022/03/07/DOM-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3(2)/","excerpt":"","text":"DOM-事件相关(2)事件对象 保存了事件相关信息（诸如鼠标位置、键盘码等等）的对象，作为回调函数的传参可以在回调事件中进行访问，命名约定俗称为event&#x2F;ev&#x2F;e等等 常用的事件对象属性： type：当前事件类型 clientX/clientY：当前光标相对于浏览器窗口左上角位置 offsetX/offsetY：当前光标相对于当前DOM元素左上角的位置 key：用户按下键盘值的值，当前不提倡使用keyCode 例子图片跟随： 鼠标在页面中移动，使用mousemove事件 鼠标的坐标位置付给图片的left和top(记得添加定位) 12345let img = document.querySelector(&#x27;img&#x27;)document.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123; img.style.left = e.pageX - 50 + &#x27;px&#x27; img.style.top = e.pageY - 40 + &#x27;px&#x27;&#125;) 回车发布信息 使用keydown或者keyup事件 判断key值是否为回车，处理事件和发布按钮事件相同 12345textarea.addEventListener(&#x27;keyup&#x27;, (e) =&gt; &#123; if (e.key === &#x27;Enter&#x27;) &#123; send.click() &#125;&#125;) 事件流 事件流指事件完整执行过程中的流动路径 页面中的div触发事件时会经历捕获阶段和冒泡阶段 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。 当一个元素触发事件后，**会依次向上调用所有父级元素的同名事件**。 事件冒泡是默认存在的。 事件捕获 DOM的根元素开始去执行对应的事件（外到里） 事件捕获需要专门指定 语法： 1DOM.addEventListener(事件类型，事件处理函数，捕获机制) 第三个参数默认false，若为true则为捕获阶段触发（很少用） L0事件监听只有冒泡没有捕获 阻止事件流默认行为诸如表单跳转、链接跳转的清除使用e.preventDefault() 非默认行为由于默认的冒泡模式存在，很容易导致对子元素的点击影响到父元素（比如父元素和子元素都有click，点了子元素导致父元素也触发） 很多时候需要阻止时间流动，于是得把事件限制在当前元素内 组织时间流动得对事件对象进行 语法event.stopPropagation() 示例： 12345678910111213 let fa = document.querySelector(&#x27;.father&#x27;) let son = document.querySelector(&#x27;.son&#x27;) fa.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; console.log(&#x27;我是爸爸&#x27;) // e.stopPropagation() &#125;)son.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; console.log(&#x27;我是儿子&#x27;) // e.stopPropagation()&#125;)document.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是爷爷&#x27;)&#125;) 一些特殊事件的事件流 鼠标经过事件 mouseover和mouseout存在冒泡效果 即鼠标移动到元素上时会触发，移动到子元素上还会触发 mouseenter和mouseleave没有冒泡效果 仅仅在移动到自身的盒子时触发 事件委托事件委托是通过事件流的特征解决一些开发需求的技巧。 优点：通过给父级元素添加事件提高性能 原理：利用事件冒泡的特性 实现：事件对象可以获得真正触发事件的元素 事件流模型初看很没有道理，但是了解了传播原理之后真正利用事件event.target特性可以极大简化代码提高性能。一个例子，对于列表中的每一个元素要进行相同的处理（类似于tab菜单），以前的做法是循环为每一个元素添加相同事件的处理函数，现在仅仅需要对父元素进行事件的添加即可。 123456789101112131415 &lt;ul&gt; &lt;li&gt;我是第1个小li&lt;/li&gt; &lt;li&gt;我是第2个小li&lt;/li&gt; &lt;li&gt;我是第3个小li&lt;/li&gt; &lt;li&gt;我是第4个小li&lt;/li&gt; &lt;li&gt;我是第5个小li&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 不要每个小li注册事件了 而是把事件委托给他的爸爸 // 事件委托是给父级添加事件 而不是孩子添加事件 let ul = document.querySelector(&#x27;ul&#x27;) ul.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; e.target.style.color = &#x27;red&#x27; &#125;)&lt;/script&gt; 核心代码e.target获取触发事件的DOM对象模型。缺点是点父模型会触发所有子对象的事件。在该示例中可以通过直接设置li标签的color属性为黑（增加CSS权重）来使得子元素不继承父元素的样式。 一个例子：动态渲染表格这里采用的不再是每次点击针对性地渲染，而是将数据抽象为一个数据层，将显示抽象为视图层，即mvvc地思想进行页面渲染。 页面如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;h1&gt;新增学员&lt;/h1&gt; &lt;div class=&quot;info&quot;&gt; 姓名：&lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; 年龄：&lt;input type=&quot;text&quot; class=&quot;age&quot;&gt; 性别: &lt;select name=&quot;gender&quot; id=&quot;&quot; class=&quot;gender&quot;&gt; &lt;option value=&quot;男&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;女&quot;&gt;女&lt;/option&gt; &lt;/select&gt; 薪资：&lt;input type=&quot;text&quot; class=&quot;salary&quot;&gt; 就业城市：&lt;select name=&quot;city&quot; id=&quot;&quot; class=&quot;city&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;广州&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;曹县&quot;&gt;曹县&lt;/option&gt; &lt;/select&gt; &lt;button class=&quot;add&quot;&gt;录入&lt;/button&gt; &lt;/div&gt; &lt;h1&gt;就业榜&lt;/h1&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;薪资&lt;/th&gt; &lt;th&gt;就业城市&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt; 表单处理程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 数据层，接口获取 let arr = [ &#123; stuId: 1001, uname: &#x27;欧阳霸天&#x27;, age: 19, gender: &#x27;男&#x27;, salary: &#x27;20000&#x27;, city: &#x27;上海&#x27; &#125;, &#123; stuId: 1002, uname: &#x27;令狐霸天&#x27;, age: 29, gender: &#x27;男&#x27;, salary: &#x27;30000&#x27;, city: &#x27;北京&#x27; &#125;, &#123; stuId: 1003, uname: &#x27;诸葛霸天&#x27;, age: 39, gender: &#x27;男&#x27;, salary: &#x27;2000&#x27;, city: &#x27;北京&#x27; &#125;, ] let tbody = document.querySelector(&#x27;tbody&#x27;) let add = document.querySelector(&#x27;.add&#x27;) let uname = document.querySelector(&#x27;.uname&#x27;) let age = document.querySelector(&#x27;.age&#x27;) let gender = document.querySelector(&#x27;.gender&#x27;) let salary = document.querySelector(&#x27;.salary&#x27;) let city = document.querySelector(&#x27;.city&#x27;) // 渲染函数 把数组里面的数据渲染到页面中 let render = () =&gt; &#123; tbody.innerHTML = &#x27;&#x27; // 在渲染新的数据 // 根据数据的条数来渲染增加 tr for (let i = 0; i &lt; arr.length; i++) &#123; let tr = document.createElement(&#x27;tr&#x27;) tr.innerHTML = ` &lt;td&gt;$&#123;arr[i].stuId&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].uname&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].age&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].salary&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].city&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:&quot; id=&quot;$&#123;i&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; ` tbody.appendChild(tr) &#125; &#125; render() add.addEventListener(&#x27;click&#x27;,() =&gt; &#123; //修改数据层 arr.push(&#123; stuId: arr[arr.length - 1].stuId + 1, uname: uname.value, age: age.value, gender: gender.value, salary: salary.value, city: city.value &#125;) //渲染页面 render() // 复原所有的默认表单数据 uname.value = age.value = salary.value = &#x27;&#x27; gender.value = &#x27;男&#x27; city.value = &#x27;北京&#x27; &#125;) // 删除操作, 删除的也是数组里面的数据 // 不想要在每次重新渲染时都添加函数,可以直接对父元素采用事件委托方式 // 在冒泡地过程中进行事件处理, e.target.tagName返回的是大写 tbody.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; if (e.target.tagName === &#x27;A&#x27;) &#123; arr.splice(e.target.id, 1) // 重新渲染页面 render() &#125; &#125;)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"事件流模型","slug":"事件流模型","permalink":"https://kimanyang.xyz/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"DOM-事件相关(1)","slug":"DOM-事件相关(1)","date":"2022-03-07T07:50:14.000Z","updated":"2022-03-10T15:36:32.633Z","comments":true,"path":"2022/03/07/DOM-事件相关(1)/","link":"","permalink":"https://kimanyang.xyz/2022/03/07/DOM-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3(1)/","excerpt":"","text":"DOM-事件相关(1)一个疑问，定时器的实现方式 undefined根据 JIT会当场停下 基础内容： 什么是事件 事件是在编程时系统内发生的动作或者发生的事情 什么是事件监听 程序检测是否有事件产生，一旦事件触发就立刻使用函数做出响应，也称为注册事件 事件监听三要素 事件源（被谁触发了） 事件类型（以什么方式触发，点击or鼠标经过） 事件处理程序 事件使用例——按钮单击抽签12345678910111213141516171819202122 // 1. 获取元素 div 和 button let box = document.querySelector(&#x27;div&#x27;)let btn = document.querySelector(&#x27;button&#x27;)// 2. 随机函数let getRandom = (min, max) =&gt; &#123; return Math.floor(Math.random() * (max - min + 1)) + min&#125;// 声明一个数组let arr = [&#x27;刘备&#x27;, &#x27;曹操&#x27;, &#x27;孙十万&#x27;]// 3. 事件监听btn.addEventListener(&#x27;click&#x27;, ()=&gt;&#123; // 随机的数字 let random = getRandom(0, arr.length - 1) box.innerHTML = arr[random] // 删除数组里面的元素 splice(从哪里删, 删几个) arr.splice(random, 1) // 如果数组没有了 长度为0，就要禁用按钮 if (arr.length === 0) &#123; btn.disabled = true btn.innerHTML = &#x27;已经抽完&#x27; &#125;&#125;) 事件监听的版本历史 DOM L0 事件源.on事件 = function()&#123;&#125; DOM L2 事件源.addEventListener(事件，事件处理函数) 发展史 DOM L0是 DOM 的发展的第一个版本 DOM L1DOM级别1 于1998年10月1日成为W3C推荐标准 DOM L2使用addEventListener注册事件 DOM L3事件模块在DOM2事件的基础上重新定义了这些事件，也添加了一些新事件类型 事件的几种类型1.鼠标事件 click鼠标点击 mouseenter鼠标经过 mouseleave鼠标离开 2.焦点事件 focus表单获得光标（获得焦点） blur表单失去光标（失去焦点） 3.键盘事件 keydown键盘按下触发 keyup键盘抬起触发 4.文本事件 input用户输入事件 详细可见《JavaScript高级程序设计（第4版）》17章介绍的用法。 综合案例——搜索下拉菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; * &#123; margin:0; padding:0; box-sizing: border-box; &#125; ul &#123; list-style: none; &#125; .area &#123; margin: 100px auto; width: 200px; &#125; input &#123; height: 28px; width: 100%; line-height: 28px; font-size: 12px; padding-left: 10px; border: 1px solid #ccc; outline: none; transition: all .3s; &#125; .area .change_border_input &#123; border: 1px solid #ff6700; &#125; .result_list &#123; width: 100%; line-height: 100%; border: 1px solid #ccc; border-top: 0; display: none; transition: all 0.3s ; &#125; .area .change_border_list &#123; border: 1px solid #ff6700; border-top: 0; &#125; .result_list li &#123; width: 100%; height: 28px; padding-left: 15px; font-size: 12px; line-height: 28px; &#125; .result_list li:hover &#123; background-color: #ccc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;area&quot;&gt; &lt;input type=&quot;search&quot; class=&quot;search&quot; placeholder=&quot;搜索结果&quot;&gt; &lt;ul class=&quot;change_border result_list &quot;&gt; &lt;li&gt;1商品&lt;/li&gt; &lt;li&gt;2商品&lt;/li&gt; &lt;li&gt;3商品&lt;/li&gt; &lt;li&gt;4商品&lt;/li&gt; &lt;li&gt;5商品&lt;/li&gt; &lt;li&gt;6商品&lt;/li&gt; &lt;li&gt;7商品&lt;/li&gt; &lt;li&gt;8商品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; let search = document.getElementsByTagName(&#x27;input&#x27;)[0] let list = document.getElementsByClassName(&#x27;result_list&#x27;)[0] let focus_ev = () =&gt; &#123; list.style.display = &#x27;block&#x27; search.classList.add(&#x27;change_border_input&#x27;) list.classList.add(&#x27;change_border_list&#x27;) &#125; let blur_ev = () =&gt; &#123; list.style.display = &#x27;none&#x27; search.classList.remove(&#x27;change_border_input&#x27;) list.classList.remove(&#x27;change_border_list&#x27;)//还是改不了，再说吧 &#125; search.addEventListener(&#x27;focus&#x27;, focus_ev) search.addEventListener(&#x27;blur&#x27;, blur_ev) &lt;/script&gt;&lt;/body&gt; 综合案例——全选表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;style&gt; * &#123; margin:0; padding: 0; box-sizing: border-box; &#125; table &#123; margin: 100px auto; width: 500px; border-collapse: collapse; border-spacing: 0; text-align: center; border:1px solid #ccc &#125; th &#123; height: 25px; background-color: rgb(27, 7, 161); font: bold 16px; color: white; text-align: center; &#125; td &#123; height: 35px; border: 1px solid #ccc; &#125;&lt;/style&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ckall&quot;&gt; &lt;span class=&quot;ckall_text&quot;&gt;全选&lt;/span&gt; &lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th&gt;商家&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ck&quot;&gt; &lt;td&gt;小米手机&lt;/td&gt; &lt;td&gt;小米&lt;/td&gt; &lt;td&gt;￥1999&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ck&quot;&gt; &lt;td&gt;小米净水器&lt;/td&gt; &lt;td&gt;小米&lt;/td&gt; &lt;td&gt;￥4999&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ck&quot;&gt; &lt;td&gt;小米电视&lt;/td&gt; &lt;td&gt;虾米&lt;/td&gt; &lt;td&gt;￥5999&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; let checkAll = document.querySelector(&#x27;.ckall&#x27;) let checkboxs = document.querySelectorAll(&#x27;.ck&#x27;) let ckallText = document.querySelector(&#x27;.ckall_text&#x27;) let ckAllEvent = () =&gt; &#123; if(checkAll.checked) &#123; ckallText.innerHTML = &#x27;取消&#x27; for(let i = 0;i &lt; checkboxs.length;i++) &#123; checkboxs[i].checked = true; &#125; &#125; else &#123; ckallText.innerHTML = &#x27;全选&#x27; for(let i = 0;i &lt; checkboxs.length;i++) &#123; checkboxs[i].checked = false; &#125; &#125; &#125; checkAll.addEventListener(&#x27;click&#x27;,ckAllEvent) &lt;/script&gt;&lt;/body&gt; 综合案例——增减栏按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;style&gt; *&#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .box &#123; width: 60px; height: 40px; margin:100px auto; &#125; input &#123; float: left; text-align: center; border: 1px solid #ccc; outline: none; &#125; input[type=text] &#123; width: 60%; height: 100%; &#125; input[type=button] &#123; width: 40%; height: 50%; border-left: 0px; cursor: pointer; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;cnt&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; id=&quot;plus&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; id=&quot;minus&quot; disabled=&quot;true&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let plusBtn = document.getElementById(&#x27;plus&#x27;) let minuxBtn = document.getElementById(&#x27;minus&#x27;) let inputText = document.getElementById(&#x27;cnt&#x27;) let cnt = 1,upperBound = 10; let plusEvent = () =&gt; &#123; if(cnt &lt; upperBound) &#123; cnt++; inputText.value = cnt minuxBtn.disabled = false; if(cnt &gt;= upperBound) &#123; plusBtn.disabled = true; &#125; &#125; &#125; let minusEvent = () =&gt; &#123; if(cnt &gt; 1) &#123; cnt--; inputText.value = cnt plusBtn.disabled = false; if(cnt &lt;= 1) &#123; minuxBtn.disabled = true; &#125; &#125; &#125; plusBtn.addEventListener(&#x27;click&#x27;,plusEvent); minuxBtn.addEventListener(&#x27;click&#x27;,minusEvent)&lt;/script&gt; 综合案例——Tab栏切换的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .tab &#123; margin: 100px auto; width: 300px; height: 150px; border: 1px solid #ccc; &#125; .tab .checkbar &#123; width: 80%; height: 15%; &#125; .tab .checkbar button &#123; float: left; width: 20%; height: 100%; border: 1px solid #ccc; background-color: #ccc; border-right: 0; border-bottom: 0; font-size: 14px; line-height: 100%; cursor: pointer; &#125; .tab .checkbar .beChecked &#123; border: 2px solid palevioletred; border-radius: 20%; &#125; .tab .checkbar button:hover &#123; border: 2px solid orange; border-radius: 10%; background-color: azure; &#125; .tab .checkbar .lastBtn &#123; border-right: 1px solid #ccc; &#125; .tab .tabContent &#123; height: 85%; width: 100%; border-top: 1px solid #ccc; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;checkbar&quot;&gt; &lt;button class=&quot;tabbtn beChecked&quot;&gt;按钮1&lt;/button&gt; &lt;button class=&quot;tabbtn&quot;&gt;按钮2&lt;/button&gt; &lt;button class=&quot;tabbtn&quot;&gt;按钮3&lt;/button&gt; &lt;button class=&quot;tabbtn&quot;&gt;按钮4&lt;/button&gt; &lt;button class=&quot;tabbtn&quot; class=&quot;lastBtn&quot;&gt;按钮5&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;empty&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tabContent&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let tabBtns = document.querySelectorAll(&#x27;.tabbtn&#x27;) let content = document.querySelector(&#x27;.tabContent&#x27;) let contents = [ &quot;这是内容1&quot;, &quot;这是内容2&quot;, &quot;这是内容3&quot;, &quot;这是内容4&quot;, &quot;这是内容5&quot;, ] content.innerHTML = contents[0] for(let i = 0;i &lt; tabBtns.length;i++) &#123; tabBtns[i].addEventListener(&#x27;click&#x27;, () =&gt; &#123; content.innerHTML = contents[i] let curSetBtn = document.querySelector(&#x27;.beChecked&#x27;) curSetBtn.classList.remove(&#x27;beChecked&#x27;) tabBtns[i].classList.add(&#x27;beChecked&#x27;) &#125;) &#125;&lt;/script&gt; DOM对象节点的增删改查1.节点查找 父节点查找： parentNode属性 返回最近的父节点，找不到为null 子节点查找 childNodes属性，包括所有子节点（包括文本节点和注释节点） children属性，获得所有元素节点 返回一个伪数组 兄弟节点查找 nextElementSibling属性 previousElementSibling属性 2.节点增加 创建节点：对于节点一般是先创建再追加 &#96;&#96;&#96;jslet ele &#x3D; document.createElement(‘标签名’)123456- 追加节点至父元素中使之在页面显示 - ```js 父元素.appendChild(ele)//父元素最后 父元素.insertBefore(ele,child)//插入到父元素的子元素child之前 深拷贝一个节点， 语法element.cloneNode(flag) 若flag为true则克隆时包含后代节点 若flag为false则不包含后代节点 默认为false 3.删除节点删除元素必须通过父元素进行 1parent.removeChild(child) 不存在父子关系则删除不成功 删除节点和隐藏节点不同，隐藏节点后节点仍然存在 时间对象使用总结首先要实例化一个事件对象，然后调用对象的方法 12let date = new Date()let date = new Date(&#x27;1949-10-01&#x27;) 接口总结： 方法 作用 说明 getFullYear() 获得年份 获取四位年份 getMonth() 获得月份 取值为 0 ~ 11 getDate() 获取月份中的每一天 不同月份取值也不相同 getDate() 获取星期 取值为 0 ~ 6 getHours() 获取小时 取值为 0 ~ 23 getMinutes() 获取分钟 取值为 0 ~ 59 getSeconds() 获取秒 取值为 0 ~ 59 getTime()&#x2F;Date.now() 获取时间戳 六十四位数字","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"DOM事件","slug":"DOM事件","permalink":"https://kimanyang.xyz/tags/DOM%E4%BA%8B%E4%BB%B6/"}]},{"title":"DOM模型","slug":"DOM模型","date":"2022-03-06T00:23:14.000Z","updated":"2022-03-09T14:59:51.579Z","comments":true,"path":"2022/03/06/DOM模型/","link":"","permalink":"https://kimanyang.xyz/2022/03/06/DOM%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"DOM相关基本概念DOM树 将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树 描述网页内容关系的名词 作用：文档树直观的体现了标签与标签之间的关系 DOM对象DOM对象：浏览器根据html标签生成的 JS对象 所有的标签属性都可以在这个对象上面找到 修改这个对象的属性会自动映射到标签身上 DOM的核心思想就是把网页当作对象处理 Document对象是DOM中提供的根对象，提供的属性和方法都是用来访问和操作网页内容的 如何获取DOM对象1.根据CSS选择器来获取DOM元素选择匹配到的第一个元素，语法： 1document.querySelector(&#x27;cssslect&#x27;) 选择匹配的所有元素NodeList集合，语法： 1ducument.querySelecotrAll(&#x27;ul li&#x27;) 对于这个集合无法通过一般数组的push/pop方法进行操作，但是可以数组遍历，被称为伪数组。 2.其他获取方法123456//根据id获取元素document.getElementById(&#x27;nav&#x27;)//根据标签获取一类元素document.getElementByTagName(&#x27;div&#x27;)//根据类名获取元素document.getElementByClassName(&#x27;w&#x27;) 设置&#x2F;修改DOM元素内容DOM对象都是根据标签生成的,所以操作标签,本质上就是操作DOM对象。 就是操作对象使用的点语法。 如果想要修改标签元素的里面的内容，则可以使用如下几种方式： document.write()方法， 只能将文本内容追加到&lt;\\body&gt;标签之前 文本中包含的标签会被解析 对象**.innerText属性修改** 可以将文本内容添加到任意标签位置 文本中包含的标签不会被解析 对象**.innerHTML属性修改** 文本内容添加&#x2F;更新到任意标签位置 文本中包含的标签会被解析 设置&#x2F;修改DOM元素属性1.设置&#x2F;修改元素常用属性常见包括href&#x2F;title&#x2F;src等等，语法： 123let pic = document.querySelector(&#x27;img&#x27;);pic.src = &#x27;./images/b02.jpg&#x27;;pic.title = &#x27;a new picture&#x27;; 一个典型案例的实现： 刷新页面时图片随机显示 2.设置&#x2F;修改元素样式属性可以通过JS设置修改标签元素的样式属性来实现诸如 主要有三种方法： 通过style属性操作CSS，属性若有连接符转换为小驼峰命名 1234let box = document.querySelector(&#x27;.box&#x27;)box.style.backgroundColor = &#x27;red&#x27;box.style.width = &#x27;300px&#x27;box.style.marginTop = &#x27;50px&#x27; 操作类名（className）操作CSS，实现定义好一套类的CSS，更换类名实现更换CSS 1box.className = &#x27;active&#x27; 通过classList操作类控制CSS 123el.classList.add(&#x27;类名&#x27;)//添加类名el.classList.remove(&#x27;类名&#x27;)//移除类名el.classList.toggle(&#x27;类名&#x27;)//切换类名 3.设置&#x2F;修改表单元素属性诸如点击眼睛看到密码等功能，都是通过设置表单的不同属性来实现的。 12el.value = &#x27;username&#x27;el.type = &#x27;password&#x27; 表单属性中添加就有效果，移除就没有效果，一律使用布尔值。常用的一些属性disabled、checked、selected 间歇定时器设置按钮定时器，到时间才能够使能 12345678910111213141516let btn = document.querySelector(&#x27;.btn&#x27;)let i = 60let timer = setInterval( () =&gt; &#123; i-- btn.innerHTML = `我已经阅读用户协议($&#123;i&#125;)` if (i === 0) &#123; //清除定时器 clearInterval(timer) // 开启按钮 btn.disabled = false // 更换文字 btn.innerHTML = &#x27;我同意该协议啦&#x27; &#125;&#125;, 1000)//let timer = setInterval(closure, time),单位是毫秒 实践案例，定时轮播图。 123456789101112131415 // 1. 获取元素 图片 和 h3let pic = document.querySelector(&#x27;.pic&#x27;)let text = document.querySelector(&#x27;.text&#x27;)// i 记录图片的张数let i = 0// 2.开启定时setInterval(() =&gt; &#123; i++ pic.src = data[i].imgSrc // 修改文字内容 text.innerHTML = data[i].title if (i === data.length - 1) &#123; i = -1 &#125;&#125;, 900)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"DOM模型","slug":"DOM模型","permalink":"https://kimanyang.xyz/tags/DOM%E6%A8%A1%E5%9E%8B/"}]},{"title":"CSS笔记(4)","slug":"CSS笔记(4)","date":"2022-03-01T09:08:24.000Z","updated":"2022-03-10T15:32:59.460Z","comments":true,"path":"2022/03/01/CSS笔记(4)/","link":"","permalink":"https://kimanyang.xyz/2022/03/01/CSS%E7%AC%94%E8%AE%B0(4)/","excerpt":"","text":"CSS笔记(4)目标内容 说出3~5个H5新增布局和表单标签 说出CSS3的新增特性 HTML5的新特性H5新增语义化标签 &lt;header&gt; 头部标签 &lt;nav&gt; 导航标签 &lt;article&gt; 内容标签 &lt;section&gt; 文档某个区域 &lt;aside&gt; 侧边栏标签 &lt;footer&gt; 尾部标签 需要注意： 语义化标准主要针对搜索引擎SEO，你要喜欢可以全部div 变迁在页面中可以多次使用 IE9需要用div 多用于移动端 H5新增多媒体标签在不适用插件的情况下支持部分视频格式 1.video标签当前支持三种格式，尽量使用mp4 浏览器 MP4 WebM Ogg IE ok no no Chrome ok ok ok Firefox ok ok ok Safari ok no no Opera ok ok ok video的常见属性： 属性 值 描述 autoplay autoplay 视频自动播放 controls controls 显示播放控件 width 像素 设置宽度 height 像素 设置高度 loop lool 是否循环播放 preload auto（预先加载）none（不预先加载） 规定是否预加载视频，有autoplay则忽略 src url 视频url地址 poster imgurl 等待加载的图片 muted muted 静音播放，谷歌浏览器autoplay需加入此项使能 2.音频audio浏览器支持自己查，三种格式MP3,Wav,Ogg，尽量MP3和Wav H5为input新增的属性类型 属性值 说明 email 限制类型为Email url 限制类型为Url date 限制类型为日期 time 限制类型为时间 month 限制类型为月份 week 限制类型为周 number 限制类型为数字 tel 限制类型为电话 search 搜索框 color 生成颜色选择表单 H5为表单新增的表单属性 属性 值 说明 required required 拥有表单该属性表示内容不能为空必须填 placeholder 提示的文本 表单提示信息，存在默认值将不再显示 autoforcus autofocus 自动聚焦，页面加载完成后是否自动聚焦表单 autocomplete off&#x2F;on 是否为用户基于先前输入自动补全，默认打开，如果需要关闭得在表单里面写样式同时添加name属性 multiple multiple 可以选多个本地文件提交，用于file 1&lt;input type=&quot;search&quot; name=&quot;sear&quot; id=&quot;&quot; required=&quot;required&quot; placeholder=&quot;fuck you&quot; onfocus=&quot;this.placeholder=&#x27;&#x27;&quot; onblur=&quot;this.placeholder=&#x27;fuck you&#x27;&quot;&gt; 有部分js内容，但是上述的代码可以实现单击文本框时placeholder消失 CSS3的新特性新增选择器1.属性选择器 选择符 简介 E[alt] 选择具有alt属性的e元素 E[alt&#x3D;”val”] 选择具有alt属性且值等于val的E元素 E[alt^&#x3D;”val”] 匹配具有alt属性且值以val开头的E元素 E[alt$&#x3D;”val”] 匹配具有alt属性且值以val结尾的E元素 E[alt*&#x3D;”val”] 匹配具有alt属性且值中含有val的E元素 2.结构伪类选择器 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中的最后一个元素E E;nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type(n) 指定类型E的第n个 重点关注一下nth-child(n)，里面的n很多变，用处很大。 n可以是数字、关键字和公式 n如果是数字，就是选择第n个子元素，里面数字从1开始 n如果是关键字，odd为偶数元素，even为奇数元素 n可以是公式：常见的公式如下所示（n从0开始到不超出范围内符合的） 公式 取值 $2 n$ 偶数 $2n+1$ 奇数 $5n$ 5 10 15… $n+5$ 第五个开始到最后 $- n + 5$ 包含第五个的前五个 nth-of-type和nth-child(n)的用法是类似的，但是区别和字面意义一样在排序上不相同，nth-of-type编号是对所有类型为前面的结构伪类的元素进行的，而nth-child编号是对所有元素进行的，如果一个父元素拥有异质的子元素，使用nth-child同时也指定类型是可能选不上的。 3.伪元素选择器伪元素选择器可以帮助我们利用CSS创建新标签元素而不需要HTML标签从而简化HTML结构。前面讲的浮动清除就利用了这个原理。 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 before和after创建一个元素，但是属于行内元素 新创建的元素在文档树中无法找到，称之为伪元素 语法： element::before&#123;&#125; 必须要有content属性 伪元素选择器的权重和标签选择器一样为1 伪元素的使用场景：字体图标1234567891011121314151617 div &#123; position: relative; width: 200px; height: 35px; border: 1px solid red;&#125;div::after &#123; position: absolute; top: 10px; right: 10px; font-family: &#x27;icomoon&#x27;; /* content: &#x27;&#x27;; */ content: &#x27;\\e91e&#x27;; color: red; font-size: 18px;&#125; 伪元素的使用场景：hover掩模在笔记2中的半透明掩膜需要额外添加一个盒子让其脱标并悬浮于当前显示之上，使用伪元素特性则可以直接忽略这点（也不需要使用js）： 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .tudou::before &#123; content: &#x27;&#x27;; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面before遮罩层显示出来 */ .tudou:hover::before &#123; /* 而是显示元素 */ display: block; &#125;&lt;/style&gt; 上述的before属性用after也没啥问题。 伪元素使用场景：双伪元素清除浮动伪元素清除浮动的方法: 1234567.clearfix:after &#123; content: &quot;&quot;; /*伪元素必要属性*/ display: block;/*插入的元素必须为块级*/ height: 0;/*不看见这个元素*/ clear: both;/*左右不允许浮动，核心代码*/ visibility:hidden;/*元素不可见*/&#125; 关于原理，解释的好的博客地址：了解伪元素清除浮动原理_qq_38105488的博客-CSDN博客 12当应用于非浮动块时，它将非浮动块的边框边界移动到所有相关浮动元素外边界的下方。这个非浮动块的垂直外边距会折叠。所以添加一个没有高度的不可浮动块元素它会另起一行直接撑开所有浮动块 双伪元素的强化版本，这种做法相当于： 12345678.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;/*前后转换为块元素并且一行显示*/&#125;.clearfix:after &#123; clear: both;&#125; CSS3盒子模型变动以前计算盒子大小的时候要提前考虑padding值和border算半天，现在可以通过box-sizing来指定盒子模型，即可指定为content-box&#x2F;border-box 盒子模型的变动为两种情况： box-sizing:content-box盒子大小是width(height)+padding+border，即默认情况 box-sizing:border-box则盒子大小就是width(height)，这样就不用去算了,前提是边界合起来不超过盒子大小 对于三角形不友好，如果设置了默认的box-sizing:bordr-box;记得要画三角形的时候重新设置回来。 CSS3过渡的使用（Important）过渡特性可以使得浏览器不需要JavaScript也能够实现动画，当元素从一种样式变换为另一种样式的时候为元素添加效果。 可以美化页面，经常和hover配合使用 过渡的语法1transition:过渡的属性 花费时间 运动曲线 何时开始; 属性：想要变换的css属性，包括宽度、高度、背景颜色、内外边距都可以。如果想要所有属性都过渡就是用一个alt 花费时间：单位是秒（必须写单位）比如0.5s 运动曲线：默认是easy，可以省略 何时开始：可以延迟触发，单位是秒（必须写单位），默认是0，可以省略 谁要过渡给谁加（transition属性加在过渡之前） 123456789101112131415161718 div &#123; width: 200px; height: 100px; background-color: pink; /* transition: 变化的属性 花费时间 运动曲线 何时开始; */ /* transition: width .5s ease 0s, height .5s ease 1s; */ /* 如果想要写多个属性，利用逗号进行分割 */ /* transition: width .5s, height .5s; */ /* 如果想要多个属性都变化，属性写all就可以了 */ /* transition: height .5s ease 1s; */ /* 谁做过渡，给谁加 */ transition: all 0.5s;&#125;div:hover &#123; width: 400px; height: 200px; background-color: skyblue;&#125; 过渡特性的一个案例，血压拉满： 12345678910111213141516171819202122232425262728293031&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .outbox &#123; margin: 20px auto; height: 30px; width: 300px; padding: 2px; border: 1px solid red; border-radius: 10px; &#125; .bar &#123; height: 95%; width: 50%; float: left; background-color: skyblue; transition: all 0.8s; &#125; .bar:hover &#123; width: 100%; background-color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;outbox&quot;&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 其他CSS3小特性 图片模糊filter:函数需要的时候去查就好，用blur()可以模糊 盒子宽度计算函数width:calc()，可以在声明CSS属性时做一些计算，支持四则运算，比如width: calc(100% - 30px);可以永远比父盒子宽度小30像素 一些属性书写顺序规定建议遵循以下顺序： 布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background 文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word 其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"H5标签","slug":"H5标签","permalink":"https://kimanyang.xyz/tags/H5%E6%A0%87%E7%AD%BE/"},{"name":"CSS过渡","slug":"CSS过渡","permalink":"https://kimanyang.xyz/tags/CSS%E8%BF%87%E6%B8%A1/"},{"name":"CSS3新特性","slug":"CSS3新特性","permalink":"https://kimanyang.xyz/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"CSS笔记(3)","slug":"CSS笔记(3)","date":"2022-02-28T08:48:24.000Z","updated":"2022-03-10T15:33:07.954Z","comments":true,"path":"2022/02/28/CSS笔记(3)/","link":"","permalink":"https://kimanyang.xyz/2022/02/28/CSS%E7%AC%94%E8%AE%B0(3)/","excerpt":"","text":"CSS笔记(3)目标列表 使用精灵图 使用字体图标 写出CSS三角 常见CSS用户界面样式 说出常见的布局技巧 精灵图为何使用精灵图为什么需要精灵图:网页中往往会应用很多小的背景图像作为修饰，网页中图像过多时，服务器会频繁地接受和发送请求造成页面加载速度过慢。为了减少请求次数提高页面加载速度从而有了CSS Sprites技术。 如何使用精灵图 主要针对背景图片，把多个小背景图片这个河道一个大的图片中 大图片称为sprites精灵图 移动背景图片位置可以用background-position 移动距离就是目标图x轴和y轴坐标，右x下y 一般情况往上往左移动，所以数值为负值 使用精灵图得准确测量每个小背景图片的大小和位置 12345678910111213.box1 &#123; width: 60px; height: 60px; margin: 100px auto; background: url(images/sprites.png) no-repeat -182px 0;&#125;.box2 &#123; width: 27px; height: 25px; /* background-color: pink; */ margin: 200px; background: url(images/sprites.png) no-repeat -155px -106px;&#125; 字体图标使用场景：显示网页中通用的常用小图标，这些地方使用精灵图有些缺点： 图片文件较大 图片放大缩小会失真 制作完成后更换很复杂 字体图标本质上是字，但是可以显示出图片，需要外部引入相关的字体图标库 优点： 轻量级：字体图标比一系列图像小，减少了服务请求 灵活性：本质上是文字，可以改变颜色产生阴影透明旋转效果 兼容性：支持所有浏览器 但不能替代精灵图，只是部分优化。可以去阿里iconfont字库或者icomoon下载字体图标用。 使用过程： 把下载包地font文件（包括EOT&#x2F;TRUETYPE&#x2F;WOFF&#x2F;SVG）文件放入目录 链接或者直接复制粘贴字体中附加的css文件 根据需要在字库里面复制所需的utf码，在vscode里是乱码但是浏览器能够渲染 阿里的包下下来直接就有教程，不怕不怕啦 CSS三角制作网页中常见的三角形直接用CSS画出来即可，不必做成图片或者字体图标。规律大概是上下被左右压进去。左右是不会冲突的。待考证。 参考网站：The Shapes of CSS | CSS-Tricks - CSS-Tricks 用户界面样式鼠标样式li &#123;cursor: pointer;&#125;，设置或检索在对象上移动鼠标指针采用何种预定义形状。 属性值 描述 default 默认 pointer 手 move 移动 text 文本 not-allowed 禁止 表单样式12345678 input, textarea &#123; /* 取消表单轮廓，点下去表单不会变粗 */ outline: none;&#125;textarea &#123; /* 防止拖拽文本域，富文本框不会被拖大 */ resize: none;&#125; vertical-align属性应用属性值与场景使用场景:用于设置图片或者表单（行内块元素）和文字垂直对齐。 vertical-align:baseline|top|middle|bottom 值 描述 baseline 默认，置于父元素基线之上 top 元素的顶端与行中最高元素顶端对齐 middle 元素置于父元素中部 bottom 元素的顶端与行中最低元素顶端对齐 解决图片底部默认空白缝隙（行内块元素基线对齐导致）解决方法有两种： 给图片添加vertical-align:middle|top|bottom;等（提倡使用） 把图片转换为块级元素display:block; 溢出文字省略号表示1.单行文本溢出显示省略号必须满足三个条件： 123456/* 1.nowrap,不展开，强制文字显示不自动换行 */white-space: nowrap;/* 2.溢出的部分隐藏起来 */overflow: hidden;/* 3. 文字溢出的时候用省略号来显示 */text-overflow: ellipsis; 2.多行文本溢出显示省略号有较大兼容性问题，适合webKit浏览器和移动端 12345678overflow: hidden;text-overflow: ellipsis;/* 弹性伸缩盒子模型显示 */display: -webkit-box;/* 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 4;/* 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 推荐后端限制字数，做起来没那么多事情 几个常用的布局技巧margin负值的运用多个盒子排在一起如果margin是0的话边框会重叠在一起导致中间的边框变为两倍大小看着很难看，于是可以设置margin为负的边框大小： 12345678910111213141516171819 ul li &#123; position: relative; float: left; list-style: none; width: 150px; height: 200px; border: 1px solid red; margin-left: -1px;&#125; /* ul li:hover &#123; 1. 如果盒子没有定位，则鼠标经过添加相对定位即可 position: relative; border: 1px solid blue;&#125; */ul li:hover &#123; /* 2.如果li都有定位，则利用 z-index提高层级 */ z-index: 1; border: 1px solid blue;&#125; 对于hover效果，如果要让其显示在浮动之上，可以添加定位或者直接设置z-index 文字围绕浮动元素巧妙利用（可能也是原本运用）浮动不压住内容的特性形成下图效果： 12345678910111213141516171819202122232425262728 &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 300px; height: 70px; background-color: pink; margin: 0 auto; padding: 5px; &#125; .pic &#123; float: left; width: 120px; height: 60px; margin-right: 5px; &#125; .pic img &#123; width: 100%; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;pic&quot;&gt; &lt;img src=&quot;images/img.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;p&gt;【集锦】热身赛-巴西0-1秘鲁 内马尔替补两人血染赛场&lt;/p&gt;&lt;/div&gt; 行内块巧妙运用例子，制作翻页条 是个例子来着，自己做了一遍就行 CSS三角强化例子，制作斜角切条： 总之自己做了做： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; * &#123; margin:0; padding: 0; &#125; .box &#123; height: 28px; width: 180px; line-height: 28px; margin: 30px auto; border: 1px solid red; &#125; .box .price &#123; float: left; height: 100%; width: 85px; font-size: 16px; text-align: center; margin:0 &#125; .box .before &#123; float: right; background-color: aliceblue; text-decoration: line-through; font-size: 12px; color: #ccc; &#125; .box .after &#123; font-weight: 700; background-color: red; color: aliceblue; &#125; .triangle &#123; float: left; width: 0; height: 0; border-top: 28px solid red; border-right: 10px solid aliceblue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;price after&quot;&gt; $1880 &lt;/div&gt; &lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;price before&quot;&gt;$2680&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS初始化一个CSS初始化的案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 把我们所有标签的内外边距清零 */* &#123; margin: 0; padding: 0&#125;/* em 和 i 斜体的文字不倾斜 */em,i &#123; font-style: normal&#125;/* 去掉li 的小圆点 */li &#123; list-style: none&#125;img &#123; /* border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */ border: 0; /* 取消图片底侧有空白缝隙的问题 */ vertical-align: middle&#125;button &#123; /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */ cursor: pointer&#125;a &#123; color: #666; text-decoration: none&#125;a:hover &#123; color: #c81623&#125;button,input &#123; /* &quot;\\5B8B\\4F53&quot; 就是宋体的意思 这样浏览器兼容性比较好 */ font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\\5B8B\\4F53&quot;, sans-serif&#125;body &#123; /* CSS3 抗锯齿形 让文字显示的更加清晰 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\\5B8B\\4F53&quot;, sans-serif; color: #666&#125;.hide,.none &#123; display: none&#125;/* 清除浮动 */.clearfix:after &#123; visibility: hidden; clear: both; display: block; content: &quot;.&quot;; height: 0&#125;.clearfix &#123; *zoom: 1&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"https://kimanyang.xyz/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"CSS三角与精灵图","slug":"CSS三角与精灵图","permalink":"https://kimanyang.xyz/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS 溢出显示","slug":"CSS-溢出显示","permalink":"https://kimanyang.xyz/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/"}]},{"title":"CSS笔记(2)","slug":"CSS笔记(2)","date":"2022-02-27T14:38:34.000Z","updated":"2022-03-10T15:33:13.490Z","comments":true,"path":"2022/02/27/CSS笔记(2)/","link":"","permalink":"https://kimanyang.xyz/2022/02/27/CSS%E7%AC%94%E8%AE%B0(2)/","excerpt":"","text":"CSS笔记(2)浮动相关目标 为什么需要浮动 浮动的排列特性 3种最常见的布局方式 为什么需要清除浮动 2种清除浮动的写法 切图？ 定位相关目标 为什么需要定位 定位的四种分类 4种定位的各自特点 为什么常用子绝父相布局 写出淘宝轮播图布局 显示隐藏的两种方式以及区别 传统网页布局三种方式标准标签按照规定的默认方式排列 块级元素独占一行从上向下，常用div,hr,p,h1~h6,ul,ol,dl,form,table 行内严肃按照顺序从左到右排列，父元素边缘自动换行，常用span,a,i,em 浮动为什么需要浮动有些布局使用标准进行很难整好，使用浮动可以改变默认的标签排列方式。最典型的应用时使得多个块级元素再一行内排列显示。多个块级元素纵向排列用标准布局，多个块级元素横向排列用浮动布局。 浮动的属性值：1选择器 &#123;float:属性值;&#125; 属性值 描述 none 默认不浮动 left 元素向左浮动 right 元素向右浮动 浮动脱标浮动元素的最重要特性： 脱离标准控制流浮动到指定位置 不再保留预先的位置如果存在多个浮动的盒子，则它们会按照属性值再一行内显示并且顶端对齐排列。浮动的元素相互贴靠不存在缝隙，如果父级宽度无法装下浮动的盒子则多出的盒子会另起一行对齐。 浮动元素具有行内块元素特性任何元素都可以浮动，不管原先是什么模式，浮动后都有行内块元素特性 块级盒子没有宽度，则默认宽度和父级一样宽，但是添加浮动后大小根据内容来决定 浮动的盒子中间没有缝隙，是紧挨着的 行内元素同理 为什么需要清除浮动再父级拥有很多盒子的情况下不方便给出高度，到那时子盒子浮动不占有位置，最后父级盒子高度为0的时候会影响下方标准流盒子。父级0高度盒子不会被内容撑开，理想中应该有多少孩子就撑开多少。 清除浮动本质 清除浮动本质是清除浮动元素造成的影响 如果父盒子自身有高度则不需要清除浮动 清除浮动之后父级会根据子盒子的浮动自动检测高度从而被撑开，就不会影响下方元素了 1选择器&#123;clear:属性值&#125; 存在left&#x2F;right&#x2F;both三个值，实际中几乎只用both，即左右侧都不允许浮动值。 清除浮动的四种方法 额外标签法，w3c推荐做法，对末尾的类设置clear:both属性 123456&lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 父级overflow:hidden属性 1234&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt; &lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;/div&gt; 父级after伪属性 1234567.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125; 父级添加双伪元素 12345678.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125; 相关总结： 清除浮动方式 优点 缺点 额外标签法 通俗易懂书写方便 存在无意义标签 父级overflow 书写简单 盒子溢出的部分会被隐藏，不利于完整展示 父级after伪元素 结构语义化正确 IE兼容性问题 父级双伪元素 结构语义化正确 IE兼容性问题 包括浮动后的通常CSS初始化代码1234567891011121314151617181920/*清除内外边距*/* &#123; margin: 0; padding: 0;&#125;/*清除列表样式*/ul &#123; list-style:none;&#125;/*清除浮动*/.clearfix:before, after &#123; display: table; content: &quot;&quot;;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom:1&#125; 定位为什么需要定位让元素在盒子内自由移动位置并且压住其他盒子，比如一些标签啥的 定位的组成1.定位模式 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 2.边偏移就是定位的盒子移动到最终位置，有top&#x2F;bottom&#x2F;left和right四个属性。 边偏移属性 示例 描述 top top:80px 顶端偏移量，相对于父元素上边线的距离 bottom bottom:80px 底部偏移量，相对于父元素下边线的距离 left left:80px 左侧偏移量，相对于父元素左边线的距离 right right:80px 右侧偏移量，相对于父元素右边线的距离 四种定位具体静态定位static即默认定位方式，不定位的意思 相对定位（重要）相对定位的四个偏移值是指相对于它自身原来的位置而言的 绝对定位（重要）绝对定位是元素在移动位置的时候相对于祖先元素而言的 没有祖先元素或者祖先元素没有定位，则以浏览器作为定位 如果祖先元素有定位（相对、绝对、固定这三种），则以最近一级有定位的祖先元素作为参考标准 绝对定位不再占用原先的位置（类似于浮动的脱标，直接到了浏览器上方） 固定定位（重要）固定定位是元素固定于浏览器可视区的位置。主要应用场景：可以使得浏览器在页面滚动时元素位置不会改变。 1选择器 &#123;position:fixed;&#125; 固定定位的特点： 以浏览器的可视窗口为参照点移动元素 和父元素没有任何关系 不随滚动条滚动 固定定位不再占有原先的位置 固定定位也是脱标的，可以看作一种特殊的绝对定位。 固定定位小技巧：固定在版心右侧位置 固定定位盒子left:50%，走到浏览器可视区（版心）的一半位置 固定定位的盒子margin-left：版心宽度一般距离 番外——粘性定位sticky固定定位和相对定位混合 1选择器 &#123;position: sticky; top: 10px;&#125; 粘性定位特点： 以浏览器的可视窗口为参照点移动元素（固定定位） 粘性定位占有原先定位位置（相对定位特点） 必须添加top&#x2F;left&#x2F;right&#x2F;bottom其中一个才有效 子绝父相的由来定位中最常用的方式就是：子级是绝对定位的话父级要用相对定位 子级绝对定位不会占有位置，可以放到父盒子里的任何一个地方，不会影响其他的兄弟盒子 父盒子需要加定位限制子盒子只能在父盒子内显示 父盒子布局时需要占有位置因此只能是相对定位 相对定位经常用来作为绝对定位的父级，如果父元素不需要占有位置也可以都用绝对定位。 定位相关总结 定位模式 是否脱标 移动位置 是否常用 static 否 不能使用边偏移 基本无 relative 否（占有原先位置） 相对自身位置偏移 多 absolute 是（不占原先位置） 相对父级的边偏移 多 fixed 是（不占原先位置） 相对浏览器可视区偏移 多 sticky 否（占有位置） 相对浏览器可视区偏移 看情况 定位的叠放次序可能会出现盒子重叠，这时候可以使用z-index：数值来改变叠放次序 可以是正整数、负整数或者0，默认是auto，越大越靠上 属性值相同按照书写顺序后来居上 数字后不能加单位 有定位的盒子才能添加z-index 定位的扩展绝对定位的盒子居中绝对定位的盒子无法通过margin:0 auto来居中，但是可以自己计算实现水平和垂直居中，具体的代码要记住： 12345678910.box &#123; width:100px; height:100px; position: absolute; left: 50%; top: 50px; margin-left: -50px;/*是负的一半盒子宽度*/ margin-top: -50px;/*是负的一半盒子高度*/ background-color: pink; &#125; 定位的特殊特性 绝对定位和固定定位也和浮动类似 行内元素添加绝对或者固定定位可以直接设置高度和宽度 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标盒子不会触发外边距塌陷包括了浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并问题。 绝对定位（固定定位）会完全压住盒子但是浮动元素只会压住盒子，不会压住盒子中的内容 三种布局总结 标准方式，用于多个垂直的块级盒子布局 浮动方式，用于多个块级元素一行显示或者左右对齐 定位，具有层叠概念，让元素自由在盒子内部移动 元素的显示与隐藏displaydisplay属性用于设置一个元素应该如何显示，除了转换为块级、行内块元素以外，还可以设置是否显示 display:none;用于隐藏对象，被隐藏后不再占用原先的位置 display:block;除了用于转换块级元素也可用于显示对象 visibilityvisibility用于指定一个元素可见或是隐藏属性值包括visible|collapse|hidden visibility:visible;元素可视 visibility:hidden;元素隐藏 隐藏元素后继续占用原来的位置，所以根据元素是否占用原来位置适当地选择让js控制display或者是visibility overflowoverflow属性制定了如果内容溢出了一个元素的框时会发生什么（超过其指定高度及宽度） overflow:visible内容可见 overflow:hidden内容不可见 overflow:scroll总是显示滚动条 overflow:auto溢出的时候才显示滚动条 对于有定位的盒子要慎用overflow:hidden; 重要案例——透明掩模制作1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .box &#123; position: relative; width: 444px; height: 320px; margin: 20px auto; &#125; .box img &#123; width: 100%; height: 100%; &#125; .mask &#123; position: absolute; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; display: none; &#125; /*当.box:hover 事件发生时使得属于这个.box的mask显示为block，很绕，我宁愿用js干这事*/ .box:hover .mask&#123; display: block; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"https://kimanyang.xyz/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"CSS浮动与定位","slug":"CSS浮动与定位","permalink":"https://kimanyang.xyz/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/"}]},{"title":"CSS笔记(1)","slug":"CSS笔记(1)","date":"2022-02-24T03:08:34.000Z","updated":"2022-03-10T15:33:18.968Z","comments":true,"path":"2022/02/24/CSS笔记(1)/","link":"","permalink":"https://kimanyang.xyz/2022/02/24/CSS%E7%AC%94%E8%AE%B0(1)/","excerpt":"","text":"CSS笔记(1)CSS选择器类型基础选择器 标签选择器 类选择器（多类名使用） id选择器 通配符选择器 复合选择器 后代选择器，所有后代（孙子…都会生效） 1ol li &#123;color: pink;&#125; 子选择器，仅仅生效一代 1.nav&gt;a &#123;color: red;&#125; 并集选择器，literally 1div,p,.pig li &#123;color: pink;&#125; 伪类选择器 链接伪类选择器 1234567891011121314151617/* 1.未访问的链接 a:link 把没有点击过的(访问过的)链接选出来 */a:link &#123; color: #333; text-decoration: none;&#125;/*2. a:visited 选择点击过的(访问过的)链接 */a:visited &#123; color: orange;&#125;/*3. a:hover 选择鼠标经过的那个链接 */a:hover &#123; color: skyblue;&#125;/* 4. a:active 选择的是我们鼠标正在按下还没有弹起鼠标的那个链接 */a:active &#123; color: green;&#125; focus选择器 12345 /* // 把获得光标的input表单元素选取出来 */input:focus &#123; background-color: pink; color: red;&#125; Emmet语法HTML快速生成 标签名+tab可以生成标签 标签名*个数+tab,比如div+*+3+tab 父子级关系的标签直接用&gt;，如ul&gt;li 兄弟级关系的标签直接用+，如div+p 生成带有类名和id的可以用.demo或者#two再按tab，比如div.demo+tab 有顺序的类名可以用自增符号$，比如div*5.demo 模板渲染可以填充内容div&#123;fuck you $&#125;*5.demo 具体使用参考博客 Emmet-HTML&#x2F;CSS代码自动补全语法 (z01.com) CSS快速生成基本靠vs插件就行了，语法没啥用懒得记了 CSS元素显示模式三种显示模式元素（标签）以何种方式进行显示。块元素&lt;div&gt;独占一行，行内元素一行可以放多个&lt;span&gt;，HTML分为两种类型，块元素和行内元素两种类型。 常用块元素h1~h6,p,div,ul,ol,li 块元素特点 独占一行 高度宽度内外边距都可控 默认宽度是容器（父级）的100% 是容器盒子，内部由行内或者块元素 常用行内元素a,strong,b,em,i,del,s,ins,u,span 相邻行内元素再一行上，一行可以显示多个 高宽设置无效 默认宽度即本身宽度 行内元素只能容纳行内元素和文本（链接不能放链接） 兼具行内元素和块元素特点，称为行内块元素，img,input,td 和相邻行内元素（行内块）再一行上，但是之间有空白间隙，一行可以显示多个（行内元素） 默认宽度就是本身内容的宽度（行内元素） 高度行高内外边距可以控制（块级元素） 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块元素 可设置宽度高度 容器的100% 任何标签 行内元素 一行可以放个多个行内元素 不可直接设置宽度高度 本身内容宽度 文本或其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度高度 本身内容宽度 显示模式转换使用标签display，比如想要把超链接范围扩大，或者把块级元素在一行里面放多个。例子如下： 123456789101112131415161718192021a &#123; width: 150px; height: 50px; background-color: pink; /* 把行内元素 a 转换为块级元素 */ display: block;&#125;div &#123; width: 300px; height: 100px; background-color: purple; /* 把 div 块级元素转换为行内元素 */ display: inline;&#125;span &#123; width: 300px; height: 30px; background-color: skyblue; /*把span行内元素转换为行内块元素*/ display: inline-block;&#125; *单行文字垂直居中技巧：行高等于盒元素高度，即line-height和height取一样即可。 CSS背景123456789div&#123; width: 300px; height: 300px; background-color: pink; background-image: url(images/logo.png); background-repeat: no-repeat; background-position: right center; background-position: 10px 20px;/*左上角相对于左上角*/&#125; background-position：x y属性可以使用两种：方位名词和精确单位，精确单位为左上角相对左上角 参数 说明 length 百分数|由浮点数和单位标识符构成的长度值 position top|center|bottom|left|center|right 1234567891011body &#123; background-image: url(images/bg.jpg); background-repeat: no-repeat; background-position: center top; /* 把背景图片固定住 */ background-attachment: fixed;/*默认scroll*/ color: #fff;/*文本颜色*/ font-size: 20px;&#125;/*以上可以采用复合写法*/background: black url(images/bg.jpg) no-repeat fixed center top; 若要使背景半透明，可以对background-color使用rgba色，具体用的时候自己百度 属性 作用 值 background-color 背景颜色 RGB代码或预定义的色值 background-image 背景图片 url路径 background-repeat 是否平铺 repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y background-position 背景位置 length&#x2F;position，先x后y background-attachment 背景附着 scroll&#x2F;fixed 背景简写 简写 背景颜色 图片地址 平铺 滚动 位置 背景色半透明 颜色半透明 background:rgba(a,b,c,d) CSS三大特性CSS层叠性相同选择器给设置相同的样式，其中一个样式会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。层叠性的原则： 样式冲突遵循就近原则，哪个离得近执行哪个 样式不冲突，不层叠 CSS继承性子标签会继承父标签的某些样式，比如文本颜色和字号等等 恰当使用可以简化代码降低CSS样式复杂性 子元素可以继承父元素样式(text-及font-及line-开头元素和color) 在继承时如果没有额外指定（层叠性）那么默认属性值会是父标签的对应样式属性值 CSS优先级当同一个元素被指定了多个选择器则会有优先级的产生。选择器相同则执行层叠性，否则根据选择器的权重进行执行： 选择器 选择器权重 继承或者通用选择器* 0，0，0，0 元素选择器(标签选择器) 0，0，0，1 类选择器、伪类选择器 0，0，1，0 ID选择器 0，1，0，0 行内样式style 1，0，0，0 !important 无穷大 整的这么麻烦核心是为了计算权重的叠加。 1234567891011ul li &#123; color: green;&#125;/* li 的权重是 0,0,0,1 1 */li &#123; color: red;&#125;/* .nav li 权重 0,0,1,0 + 0,0,0,1 = 0,0,1,1 11 */.nav li &#123; color: pink;&#125; 最重要记住继承的权重是0 坑点：连写需要同时具备才会出现效果，权重是连写组合中最大的一个,比如li.active、.one.two CSS盒子模型（重要）目标 准确阐述盒子模型的4个组成部分 利用边框复合写法给元素添加边框 计算盒子的实际大小 利用盒子模型布局模块 给盒子设置圆角边框 给盒子添加阴影 给文字添加阴影 核心在于模型本身、浮动和定位 网页布局的基本过程： 准备好相关网页元素，网页元素本身基本都是盒子Box 利用CSS设置好盒子的样式，然后摆放到相应位置 往盒子中添加内容 核心本质就是利用CSS摆盒子。 盒子模型组成分为四个部分border,content,padding和margin。 border边框 content内容 padding内边距，控制边框到内容的距离 margin外边距，控制两个盒子之间的距离 除了content其他都有四个二级属性top&#x2F;left&#x2F;right&#x2F;bottom 边框相关边框由三部分组成：边框宽度、样式和颜色，具体的： 1border:border-width || border-style || border-color 属性 作用 border-width 定义边框粗细，单位是px border-style 定义边框的样式 border-color 边框的颜色 具体属性值可自行查阅手册，style用得比较多的是solid&#x2F;dashed&#x2F;dotted。同样的属性具有符合写法： 12345678910111213 div &#123; width: 300px; height: 200px; /* border-width: 5px; border-style: solid; border-color: pink; */ /* 边框的复合写法 简写: */ border: 5px solid pink; /* 上边框 */ border-top: 5px solid pink; /* 下边框 */ border-bottom: 10px dashed purple;&#125; 同时如果两个盒子连接（外边距为0）的话，可能会出现边框变粗的情况，这时候可以使用border-collapse:collapse使之合并。 需要注意的是边框会增加盒子本身的大小，比如设置了300*200的盒子，给了10像素边框，那么实际的盒子大小是320*220（左右上下各加10）。 内边距相关用于控制内容和内边框的距离，简写属性可以有一到四个值： 值的个数 表达意思 padding:5px; 上下左右5像素内边距 padding:5px 10px; 上下5，左右10 padding:5px 10px 20px; 上下5，左右10，下20 padding:5px 10px 20px 30px; 上向左右分别5、10、20、30 和边框类似，内边距同样会增加盒子的大小 外边距相关用于控制盒子和盒子之间距离，意思和内边距完全一致，不再重复，不同的是外边距不会增加盒子的大小。 外边距典型应用使得块级盒子水品居中，但是得满足两个条件： 盒子必须指定了宽度 盒子左右外边距设置为auto 1.header&#123;width:960px;margin:0 auto;&#125; 常见写法： margin-left:auto; margin-right:auto margin:auto; margin:0 auto; 注意：上述方法只能适用于块级元素，对于行内元素和行内块元素水平居中则应该给其父元素添加text-align:center，同时竖直居中则是将行高设的和高度相同即可。 外边距合并 相邻块元素垂直外边距合并：使用margin定义块元素的垂直外边距时候可能会出现外边距的合并，选择一个大的作为外边距，尽量只给一个盒子设置外边距： 嵌套的块元素垂直外边距塌陷：对于两个嵌套关系（父子关系）的块元素，父元素上外边距同时子元素也有上外边距，此时父元素会塌陷为较大的外边距值 ​ 清除内外边距网页元素常常有自己的默认内外边距，不同浏览器不同，于是还是得自己手动清除。通常来说上手写css第一个就是： 1234* &#123; margin: 0; padding: 0;&#125; 圆角边框使用border-radius属性 123456789101112131415161718192021222324252627282930/*以矩形中心画圆消除角*/div &#123; width: 300px; height: 150px; background-color: pink; border-radius: 10px;&#125;.yuanxing &#123; width: 200px; height: 200px; background-color: pink; /* border-radius: 100px; */ /* 50% 就是宽度和高度的一半 等价于 100px */ border-radius: 50%;&#125;.juxing &#123; width: 300px; height: 100px; background-color: pink; /* 圆角矩形设置为高度的一半 */ border-radius: 50px;&#125;.radius &#123; width: 200px; height: 200px; /* border-radius: 10px 20px 30px 40px; */ /* border-radius: 10px 40px; */ border-top-left-radius: 20px; background-color: pink;&#125; 阴影盒子阴影box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3); 各个参数具体作用： 值 描述 h-shadow 相对水平位置，可负值 v-shadow 相对垂直位置，可负值 blur 可选，模糊距离 spread 可选，阴影尺寸 color 可选，阴影颜色 inset 可选，外部阴影改为内部 文字阴影text-shadow，类似拥有： 值 描述 h-shadow 相对水平位置，可负值 v-shadow 相对垂直位置，可负值 blur 可选，模糊距离 color 可选，阴影颜色","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://kimanyang.xyz/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS盒模型","slug":"CSS盒模型","permalink":"https://kimanyang.xyz/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"}]},{"title":"LRU和LFU缓存设计","slug":"LRU和LFU缓存设计","date":"2022-02-18T15:11:14.000Z","updated":"2022-03-10T15:39:49.153Z","comments":true,"path":"2022/02/18/LRU和LFU缓存设计/","link":"","permalink":"https://kimanyang.xyz/2022/02/18/LRU%E5%92%8CLFU%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"STL双向链表容器(List)的使用及LRU和LFU缓存设计创建方法 123456789using namespace std;/*类似与vector*/list&lt;int&gt; vals;list&lt;int&gt; vals(10);list&lt;int&gt; vals(10,5);/*origin移动到target位置*/vals.splice(target_iterator,vals,origin_iterator);/*moveToHead功能*/vals.splice(vals.begin(),vals,origin_interator); List使用 成员函数 具体功能 begin() 首个迭代器 end() 末尾迭代器 front() 首个元素引用 back() 末尾元素引用 size() 包含元素个数，复杂度$O(1)$ push_front()push_back() 首部（尾部）插入元素 splice() （重要）将一个元素移动到另一个位置 push_front()push_back() 首部（尾部）删除元素 LRU设计请你设计一个满足LRU最近最少使用缓存约束的数据结构。 实现LRUCache: 以正整数作为容量，capacity初始化缓存 int get(int key)方法根据关键字key获取缓存的值，否则返回- void put(int key, int val)在关键字存在则变更val，否则插入键值对。如果插入操作使得关键字数量超过capacity则逐出最久未使用(未被查询)的关键字 要求所有操作的时间复杂度都是$O(1)$。分析要求可以看出给定。 做法是采用一个链表加哈希表，链表存储先后顺序，链表能够达成$O(1)$的删除，而哈希表能够达成$O(1)$的索引，具体实现如下，一般会要求自己整个链表，链表内容为键值对的主要原因是在哈希表中删除的时候需要索引其键： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class BiList&#123;public: int value; int key; BiList* prev; BiList* next; BiList():key(0),value(0),prev(nullptr),next(nullptr)&#123;&#125; BiList(int k,int v):key(k),value(v),prev(nullptr),next(nullptr)&#123;&#125;&#125;;class LRUCache &#123;private: int cap; int cursize; BiList* head; BiList* tail; unordered_map&lt;int, BiList*&gt; dict;public: LRUCache(int capacity) &#123; this-&gt;cap = capacity; this-&gt;cursize = 0; this-&gt;head = new BiList(); this-&gt;tail = new BiList(); head-&gt;next = tail; tail-&gt;prev = head; &#125; int get(int key) &#123; if(!dict.count(key))&#123; return -1; &#125; BiList* tmp = dict[key]; movetoHead(tmp); return tmp-&gt;value; &#125; void put(int key, int value) &#123; if(!dict.count(key))&#123; BiList* node = new BiList(key,value); nodeAdd(node); dict[key] = node; cursize++; if(cursize &gt; cap)&#123; BiList* tmp = tail-&gt;prev; nodeDelete(tmp); dict.erase(tmp-&gt;key); delete tmp; cursize--; &#125; &#125;else&#123; BiList* tmp = dict[key]; tmp-&gt;value = value; movetoHead(tmp); &#125; &#125;private: void nodeAdd(BiList* node)&#123; node-&gt;prev = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = node; head-&gt;next = node; &#125; void nodeDelete(BiList* node)&#123; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next = nullptr; node-&gt;prev = nullptr; &#125; void movetoHead(BiList* node)&#123; nodeDelete(node); nodeAdd(node); &#125;&#125;; 但是可以使用C++现成的链表，代码更加简洁，打的速度可以更快而且不用自己释放内存： 12345678910111213141516171819202122232425262728293031class LRUCache &#123;private: using pii = pair&lt;int, int&gt;; unordered_map&lt;int, list&lt;pii&gt;::iterator&gt; hash; list&lt;pii&gt; cache; int capacity;public: LRUCache(int capacity) &#123; this-&gt;capacity = capacity; &#125; int get(int key) &#123; if(!hash.count(key)) return -1; cache.splice(cache.begin(),cache,hash[key]); return hash[key]-&gt;second; &#125; void put(int key, int value) &#123; if(hash.count(key)) &#123; (hash[key])-&gt;second = value; cache.splice(cache.begin(),cache, hash[key]); &#125; else &#123; auto kv = pii(key,value); cache.push_front(kv); hash[key] = cache.begin(); if(cache.size() &gt; capacity) &#123; hash.erase(cache.back().first); cache.pop_back(); &#125; &#125; &#125;&#125;; LFU设计请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。 void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。 当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。 函数 get 和 put 必须以$ O(1) $的平均时间复杂度运行。 不同于LRU缓存，LFU缓存可以采用双哈希表或者哈希表与哈希集合（二叉平衡树）实现。todo","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LRU","slug":"LRU","permalink":"https://kimanyang.xyz/tags/LRU/"},{"name":"LFU","slug":"LFU","permalink":"https://kimanyang.xyz/tags/LFU/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"}]},{"title":"BitSet数据结构设计","slug":"BitSet数据结构设计","date":"2022-02-18T08:31:14.000Z","updated":"2022-03-10T15:31:45.473Z","comments":true,"path":"2022/02/18/BitSet数据结构设计/","link":"","permalink":"https://kimanyang.xyz/2022/02/18/BitSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"BitSet数据结构设计请你实现 Bitset 类。 Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。 void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。 void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。 void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。 boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。 boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。 int count() 返回 Bitset 中值为 1 的位的 总数 。 String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。 可以不进行压缩，题目没有限制空间，但是限制了时间，不能够对flip使用遍历方式实现，需要给一个懒加载的标记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Bitset &#123;private: vector&lt;int&gt; datas; int l = 0; int bitcount = 0; int ones = 0; //永远是实际的个数，根据懒标记决定是否取补 bool reversed = false;public: Bitset(int size) &#123; bitcount = size; datas.assign(size, 0); &#125; void fix(int idx) &#123; if(datas[idx] != 1 &amp;&amp; !reversed) &#123; ones++; datas[idx] = 1; &#125; else if(datas[idx] == 1 &amp;&amp; reversed) &#123; ones--; datas[idx] = 0; &#125; &#125; void unfix(int idx) &#123; if(datas[idx] != 0 &amp;&amp; !reversed) &#123; ones--; datas[idx] = 0; &#125; else if(datas[idx] == 0 &amp;&amp; reversed) &#123; ones++; datas[idx] = 1; &#125; &#125; void flip() &#123; reversed = reversed ? false : true; &#125; bool all() &#123; return reversed ? ones == 0 : ones == bitcount; &#125; bool one() &#123; return reversed ? ones != bitcount : ones &gt; 0; &#125; int count() &#123; return reversed ? bitcount - ones : ones; &#125; string toString() &#123; string ret = &quot;&quot;; for(auto&amp; n:datas) &#123; if(reversed) &#123; ret += n == 1 ? &quot;0&quot; : &quot;1&quot;; &#125; else &#123; ret += n == 1 ? &quot;1&quot; : &quot;0&quot;; &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"BitSet","slug":"BitSet","permalink":"https://kimanyang.xyz/tags/BitSet/"},{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://kimanyang.xyz/tags/STL/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"lambda表达式、C++优先队列使用方式与多路归并总结","slug":"多路归并与C++优先队列使用方式总结","date":"2022-02-18T07:40:24.000Z","updated":"2022-03-10T15:28:52.409Z","comments":true,"path":"2022/02/18/多路归并与C++优先队列使用方式总结/","link":"","permalink":"https://kimanyang.xyz/2022/02/18/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E4%B8%8EC++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"lambda表达式、C++优先队列使用方式与多路归并总结虽然多次写过优先队列，但是每次写都需要查询C++的具体写法，有些还涉及到一些没有听说过的C++11特性，因此在本文给出多道类似题型的总结并一次性把设计优先队列的几种写法总结下来。顺便在开头复习一下在优先队列中可以使用的lambda表达式的相关知识。 前置知识之C++11特性lambda表达式基本形式lambda表达式也可以叫闭包、匿名函数啥的，基本的构造方法如下： 1[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; 逐项解释下内部各项的实际意义： capture list :捕获列表，表示在lambda表达式中所能捕获的外部变量 params list: 形参列表 mutable：指示符，说明捕获的变量可否修改 exception：异常处理 return type: 返回类型 function body：函数体 也有常见地几种省略形式： 声明const类型地表达式，捕获列表的值不能被修改 1[capture list] (params list) -&gt; return type &#123;function body&#125; 这里省略了返回类型，但是编译器可以自己推导，面向auto编程就完事了 1[capture list] (params list) &#123;function body&#125; 无参函数，一般也可以叫做过程 1[capture list] &#123;function body&#125; 一个使用的例子： 123456auto mylambda = [](int a, int b) -&gt; bool &#123; return a &lt; b;&#125;if(mylambda(1,2)) &#123; std::cout&lt;&lt;&quot;fuck you&quot;;&#125; else &#123; std::cout&lt;&lt;&quot;fuck me&quot;;&#125; 捕获外部变量的方式目前我们没有详细讲解捕获的外部变量是否可以被函数内部修改，同参数的传递有值传递和引用传递方式一样，lambda表达式捕获外部变量的方式也有值捕获和引用捕获，除此以外还有隐式捕获和混合捕获方式。 1.值捕获对于被值捕获的变量，lambda的内部函数体无法改变值，一个具体的例子如下： 1234string fuck = &quot;fuck&quot;;auto f = [fuck]&#123;std::cout &lt;&lt; fuck &lt;&lt; endl;&#125;;fuck = &quot;good&quot;;f();//输出fuck 可见值捕获会在闭包内部创建一个捕获对象的副本，从而使得后续的改变无法对闭包内部的值产生影响，调用闭包时输出的仍然是捕获时对象的值。这种做法会带来额外的性能开销。需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。如果要进行修改需要把函数改为mutable，具体如下： 1234string fuck = &quot;fuck&quot;;auto f = [fuck]()mutable &#123; fuck = &quot;good&quot;;std::cout &lt;&lt; fuck; &#125;; // 不会报错std::cout &lt;&lt; fuck &lt;&lt; endl; // 输出：fuckf(); // 输出：good 2.引用捕获对于引用捕获，要在函数的外部加上引用指示符&amp;，类似的例子： 1234string fuck = &quot;fuck&quot;;auto f = [&amp;fuck]&#123;std::cout &lt;&lt; fuck &lt;&lt; endl;&#125;;fuck = &quot;good&quot;;f();//输出good 此时闭包捕获外部对象的引用，无论是在闭包内对变量的修改抑或是在外部直接对变量进行修改都会是的变量的值发生改变。 3.隐式捕获大部分语言实际上都采用隐式捕获让编译器自行判断捕捉啥变量，C++支持两种隐式捕获，全值捕获和全引用捕获，分别用[=]和[&amp;]表示。给出示例： 123456789101112string fuck1 = &quot;fuck you&quot;;string fuck2 = &quot;fuck me&quot;;auto f1 = [=]&#123;std::cout&lt;&lt;fuck1&lt;&lt;&quot; &quot;&lt;&lt;fuck2&lt;&lt;endl;&#125;;auto f2 = [&amp;]&#123;std::cout&lt;&lt;fuck1&lt;&lt;&quot; &quot;&lt;&lt;fuck2;&#125;;fuck1 = &quot;hello&quot;;fuck2 = &quot;world&quot;;f1();//输出 fuck you fuck mef2();//输出 hello world 4.混合捕获顾名思义就是既有值捕获也有引用捕获，具体来说有如下几种： 代码形式 捕获说明 [] 要求闭包不捕获任何外部变量 [var1, var2 …] 捕获对应变量名变量 [this] 以值捕获形式获取this指针（能不能修改？应该不能） [&#x3D;] 自动值捕获 [&amp;] 自动引用捕获 [&#x3D;,&amp;x] 对于x引用捕获，其他默认值捕获 [&amp;,&#x3D;x] 对于x值捕获，其他默认引用捕获 lambda表达式参数几点注意 参数列表和函数不同，不能有默认参数 不支持可变的参数，即**不是基本变量得加个const**在参数名之前 所有参数必须有参数名 嵌套使用的应用实例1234567891011//lambda表达式的嵌套int m = [](int x) &#123; return [](int y) &#123; return y * 2; &#125;(x)+6;&#125;(5);std::cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; std::endl; //输出m:16，即5*2 + 6//lambda表达式使用lambda表达式作为传参和返回值（开始魔幻起来了，但对脚本语言属于常规操作）auto gFunc = [](int x) -&gt; function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;auto lFunc = gFunc(4);std::cout &lt;&lt; lFunc(5) &lt;&lt; std::endl;auto hFunc = [](const function&lt;int(int)&gt;&amp; f, int z) &#123; return f(z) + 1; &#125;;auto a = hFunc(gFunc(7), 8); STL中优先队列的写法写在之前先抛开STL的优先队列，让我们对最大堆最小堆的原理有一个清晰的认识，常规的最大堆写法一般使用一个数组容器实现： 12345678910111213141516171819202122232425262728293031323334353637383940vector&lt;int&gt; heap;//获取最大值int top() &#123; return heap[0];&#125;//插入值，新数字在最后，并进行上浮void push(int k) &#123; heap.push_back(k); swim(heap.size()-1);&#125;//删除最大值，把最后一个数字移到开头并进行下沉void pop() &#123; heap[0] = heap.back(); heap.pop_back(); sink(0);&#125;//核心操作，下沉void swim(int pos) &#123; while(pos &gt; 1 &amp;&amp; heap[pos/2] &lt; heap[pos]) &#123; swap(heap[pos/2], heap[pos]); pos /= 2; &#125;&#125;//核心操作，上浮void sink(int pos) &#123; int N = heap.size(); while(2 * pos &lt;= N) &#123; int i = 2 * pos; if(i &lt; N &amp;&amp; heap[i] &lt; heap[i + 1]) ++i;//选取叶子中小的那个 if(heap[pos] &gt;= heap[i]) break;//已经沉到底了 swap(heap[pos],heap[i]); pos = i; &#125;&#125; 相关API top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素 emplace 原地构造一个元素并插入队列 pop 弹出队头元素（即消除top，使用top()再用pop()等同于Java的poll） swap 交换内容（很少用到） 最基本的一种写法，只能适应基本的数据结构： 简单写法12345678//默认是大顶堆priority_queue&lt;int&gt; a; //升序的小顶堆 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序的大顶堆 priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q; greater和less作为仿函数重载了操作符()从而使得数据结构的比较特性得到实现。 结构体自定义写法这里介绍两种，一种是结构体内的重载实现比较，一种是定义比较结构体 方法11234567891011121314struct mystruct //运算符重载&lt;&#123; pair&lt;int, int&gt; p; //构造函数列表初始化 mystruct(int a, int b) &#123; p.first = a; p.second = b; &#125; //重载操作符 bool operator&lt;(const mystruct&amp; a) const &#123; return this-&gt;p.first &lt; a.p.first; //大顶堆 &#125;&#125;; 具体使用时： 12345mystruct a(1,2);mystruct b(2,3);priority_queue&lt;mystruct&gt; pq;pq.push(a);pq.push(b); 这种方法的数据结构比较受限，很多时候数据结构是别人给的未必能够直接跑到别人的类里面去重载操作符，所以用的还是比较少。 方法2我在合并K个升序列表中使用的定义方法 1234567//重载仿函数struct cmp &#123; bool operator ()(ListNode* a, ListNode* b)&#123; return (a-&gt;val) &gt; (b-&gt;val); &#125;&#125;;priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp &gt; q; 此处详细说明一下，比较函数是用于优先队列底层容器vector中元素的比较，小顶堆重载时用大于号，大顶堆重载时用小于号，q.top()是内部元素最小的链表指针。具体使用时对于这道题如下所示： 1234567891011121314151617181920ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode dummy = ListNode(-1); ListNode* cur = &amp;dummy; for(auto&amp;&amp; node:lists) &#123; if(node)&#123; q.push(node); &#125; &#125; while(!q.empty())&#123; ListNode* l1 = q.top(); q.pop(); cur-&gt;next = l1; cur = cur-&gt;next; l1 = l1-&gt;next; if(l1)&#123; q.push(l1); &#125; &#125; return dummy.next;&#125; 方法3根据C++11中引入的特性，使用lambda表达式，和sort函数中的使用如出一辙，给出二者代码进行一下比较： 自定义排序 1234567vector&lt;pair&lt;int, int&gt;&gt; frac; /**...some operation...**/sort(frac.begin(), frac.end(), [&amp;](const auto&amp; x, const auto&amp; y) &#123; return x.first * y.second &lt; x.second * y.first;&#125;); 自定义优先队列 12345//vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2作为捕获列表的参数，当然也可以不加区分地使用[&amp;]auto cmp = [&amp;nums1, &amp;nums2](const pair&lt;int, int&gt; &amp; a, const pair&lt;int, int&gt; &amp; b) &#123; return nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];&#125;;priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp) &gt; pq(cmp); 这里需要简单解释的是decltype(cmp)这一写法。由于cmp是自动推导出来的lambda表达式，它的类型实际上应该是一个函数（仿函数），decltype(expr)的结果根据expr的结果不同而不同：expr返回左值，得到该类型的左值引用；expr返回右值，得到该类型。和方法二略有不同的一点还在于初始化时要传入参数cmp，因为lambda表达式这种特殊的类（不同于struct和class）没有默认自身的构造函数，所以需要通过传入已有的lambda对象示例进行拷贝构造，使得优先队列内部能够使用。 多路归并样板题目上面的内容主要为了这部分做一点点铺垫，相关性不是很大，因为在多路归并算法中大量使用了优先队列，于是需要先总结一下优先队列的知识。 经典题目：丑数(264)给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。 解法1优先队列使用一个优先队列和哈希集合判断。 1234567891011121314151617181920212223class Solution &#123; using LL = long long;public: int nthUglyNumber(int n) &#123; unordered_set&lt;LL&gt; inNum; vector&lt;int&gt; tab = &#123;2,3,5&#125;; priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq; pq.push(1); for(int i = 1;i &lt;= n;++i) &#123; LL k = pq.top(); pq.pop(); if(i == n) return k; for(auto&amp; num : tab) &#123; LL t = num * k; if(!inNum.count(t)) &#123; pq.push(t); inNum.insert(t); &#125; &#125; &#125; return -1; &#125;&#125;; 解法2动态规划12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[1] = 1; int p2 = 1, p3 = 1, p5 = 1; for (int i = 2; i &lt;= n; i++) &#123; int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5; dp[i] = min(min(num2, num3), num5); if (dp[i] == num2) &#123; p2++; &#125; if (dp[i] == num3) &#123; p3++; &#125; if (dp[i] == num5) &#123; p5++; &#125; &#125; return dp[n]; &#125;&#125;; 扩展题313超级丑数，思路完全相同 12345678910111213141516171819202122232425class Solution &#123;private: using ll = long long;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; vector&lt;ll&gt; dp(n + 1);dp[1] = 1; int pcnt = primes.size(); vector&lt;int&gt; pointers(pcnt,1); vector&lt;ll&gt; mins(pcnt,0); for(int i = 2;i &lt;= n;++i) &#123; ll curMin = INT_MAX; for(int k = 0;k &lt; pcnt;++k) &#123; mins[k] = ll(dp[pointers[k]]) * primes[k]; curMin = min(curMin, mins[k]); &#125; dp[i] = curMin; for(int k = 0;k &lt; pcnt;++k) &#123; if(mins[k] == curMin) &#123; pointers[k]++; &#125; &#125; &#125; return dp[n]; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://kimanyang.xyz/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"优先队列","slug":"优先队列","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"多路归并","slug":"多路归并","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://kimanyang.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"排序方法总结","slug":"排序方法总结","date":"2022-02-16T08:16:24.000Z","updated":"2022-03-10T15:29:17.417Z","comments":true,"path":"2022/02/16/排序方法总结/","link":"","permalink":"https://kimanyang.xyz/2022/02/16/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"排序方法总结常用的排序总结 算法 平均时间复杂度 最差时间复杂度 空间复杂度 稳定性 插入排序 $O(n^2)$ $O(n^2)$ $O(1)$ 是 选择排序 $O(n^2)$ $O(n^2)$ $O(1)$ 是 冒泡排序 $O(n^2)$ $O(n^2)$ $O(1)$ 是 快速排序 $O(n\\log n)$ $O(n^2)$ $O(\\log n)$ 否 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(\\log n)$ 是 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(\\log n)$ 是 桶排序和希尔排序就暂时不考虑了。 手撕快速排序（Quick Sort)采用左闭右开的二分写法： 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); quickSort(nums,0,n); return nums; &#125; void quickSort(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if(r - l &lt;= 1) return; int part = partition(nums,l, r); quickSort(nums,l,part); quickSort(nums,part, r); &#125; int partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int midIdx = (r - l)/2 + l; swap(nums[l],nums[midIdx]); int first = l, last = r - 1, mid = nums[l]; while(first &lt; last) &#123; while(first &lt; last &amp;&amp; nums[last] &gt; mid) last--; if(first &lt; last) &#123;nums[first] = nums[last];first++;&#125; while(first &lt; last &amp;&amp; nums[first] &lt; mid) first++; if(first &lt; last) &#123;nums[last] = nums[first];last--;&#125; &#125; nums[first] = mid; return first; &#125;&#125;; 这里强调一下取随机中点作为partition还是很有必要的，毕竟给了个专门卡快排的示例 模板快速选择，根据快排原理进行找到第k大的数,采用左开右闭写法 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; return quickSelect(nums,0,nums.size(), k - 1); &#125; int quickSelect(vector&lt;int&gt;&amp; nums, int l, int r, int idx) &#123; int part = partition(nums,l, r); if(part == idx) &#123; return nums[part]; &#125; else &#123; if(part &lt; idx) &#123; return quickSelect(nums,part,r,idx); &#125; else &#123; return quickSelect(nums,l,part,idx); &#125; &#125; &#125; int partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int midIdx = ((r - l) &gt;&gt; 1) + l; swap(nums[l],nums[midIdx]); int first = l, last = r - 1, mid = nums[l]; while(first &lt; last) &#123; while(first &lt; last &amp;&amp; nums[last] &lt; mid) last--; if(first &lt; last) &#123;nums[first] = nums[last];first++;&#125; while(first &lt; last &amp;&amp; nums[first] &gt; mid) first++; if(first &lt; last) &#123;nums[last] = nums[first];last--;&#125; &#125; nums[first] = mid; return first; &#125;&#125;; 附优先队列写法： 1234567891011121314151617181920class Solution &#123;public: string kthLargestNumber(vector&lt;string&gt;&amp; nums, int k) &#123; auto cmp = [&amp;](const string s1, const string s2)-&gt;bool &#123; if(s1.size() &gt; s2.size()) &#123; return true; &#125; else if(s1.size() &lt; s2.size()) &#123; return false; &#125; else &#123; return s1 &gt; s2; &#125; &#125;; priority_queue&lt;string, vector&lt;string&gt;, decltype(cmp) &gt; pq(cmp); for(auto&amp; str:nums) &#123; pq.push(str); if(pq.size() &gt; k) &#123;pq.pop();&#125; &#125; return pq.top(); &#125;&#125;; 手撕归并排序容易理解版本（左闭右开）12345678910111213141516171819202122232425262728293031323334func merge(arr1, arr2 []int) (ret []int) &#123; for len(arr1) &gt; 0 &amp;&amp; len(arr2) &gt; 0 &#123; if arr1[0] &gt; arr2[0] &#123; ret = append(ret, arr1[0]) arr1 = arr1[1:] &#125; else &#123; ret = append(ret, arr2[0]) arr2 = arr2[1:] &#125; &#125; for len(arr1) &gt; 0 &#123; ret = append(ret, arr1[0]) arr1 = arr1[1:] &#125; for len(arr2) &gt; 0 &#123; ret = append(ret, arr2[0]) arr2 = arr2[1:] &#125; return&#125;func MergeSort(arr []int) (ret []int) &#123; if len(arr) &lt;= 1 &#123; return arr &#125; mid := len(arr) / 2 l := len(arr) left := MergeSort(arr[0:mid]) right := MergeSort(arr[mid:l]) ret = merge(left, right) return&#125; 利用双指针和单个额外数组版本Go版本的左闭右闭 123456789101112131415161718192021222324252627282930313233343536func MergeSort(arr []int, temp []int, st, end int) &#123; if st &gt;= end &#123; return &#125; l := end - st mid := (l &gt;&gt; 1) + st MergeSort(arr, temp, st, mid) //假设此时st/mid有序了 MergeSort(arr, temp, mid+1, end) //假设此时mid+1/st有序了 //两个有序数组归并 p1 := st p2 := mid + 1 k := st for p1 &lt;= mid &amp;&amp; p2 &lt;= end &#123; if arr[p1] &lt; arr[p2] &#123; temp[k] = arr[p1] p1++ &#125; else &#123; temp[k] = arr[p2] p2++ &#125; k++ &#125; for p1 &lt;= mid &#123; temp[k] = arr[p1] k++ p1++ &#125; for p2 &lt;= end &#123; temp[k] = arr[p2] k++ p2++ &#125; for k := st; k &lt;= end; k++ &#123; arr[k] = temp[k] &#125;&#125; C++版本的左闭右开 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret(n, 0); mergeSort(nums,ret,0,n); return nums; &#125; void mergeSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, int l, int r) &#123; if(r - l &lt;= 1) return; int mid = (r-l)/2+l; mergeSort(nums,tmp,l,mid); mergeSort(nums,tmp,mid,r); int p1 = l, p2 = mid, k = l; while(p1 &lt; mid &amp;&amp; p2 &lt; r) &#123; if(nums[p1] &lt; nums[p2]) &#123; tmp[k] = nums[p1]; p1++; &#125; else &#123; tmp[k] = nums[p2]; p2++; &#125; k++; &#125; while(p1 &lt; mid) &#123; tmp[k] = nums[p1]; p1++;k++; &#125; while(p2 &lt; r) &#123; tmp[k] = nums[p2]; p2++;k++; &#125; for(int i = l;i &lt; r;++i) &#123; nums[i] = tmp[i]; &#125; &#125;&#125;; 手撕堆排序Golang版本的堆构建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func swap(arr *[]int, idx1, idx2 int) &#123; (*arr)[idx1], (*arr)[idx2] = (*arr)[idx2], (*arr)[idx1]&#125;//若子树满足堆条件，那adjust过的大树也满足堆条件func adjust(arr *[]int, last, idx int) &#123; cur_idx := idx left, right := 2*idx+1, 2*idx+2 if left &lt; last &amp;&amp; (*arr)[cur_idx] &lt; (*arr)[left] &#123; cur_idx = left &#125; if right &lt; last &amp;&amp; (*arr)[cur_idx] &lt; (*arr)[right] &#123; cur_idx = right &#125; if cur_idx != idx &#123; swap(arr, cur_idx, idx) adjust(arr, last, cur_idx) &#125;&#125;func enHeap(arr *[]int) &#123; //构建堆，从最右的非叶子节点开始可提高速度 last := len(*arr) for start := (len(*arr) - 1 - 1) / 2; start &gt;= 0; start-- &#123; adjust(arr, last, start) &#125;&#125;func heapPush(arr *[]int, num int) &#123; *arr = append(*arr, num) enHeap(arr)&#125;func heapPop(arr *[]int) (ret int) &#123; ret = (*arr)[0] swap(arr, 0, len(*arr)-1) adjust(arr, len(*arr)-1, 0) *arr = (*arr)[:len(*arr)-1] return&#125;func HeapSort(arr *[]int) &#123; enHeap(arr) //将当前堆最大（小）的数移到末尾并交换，对除末尾以外的数进行调整使之满足堆条件 for i := len(*arr) - 1; i &gt;= 0; i-- &#123; swap(arr, 0, i) adjust(arr, i, 0) &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"快速排序","slug":"快速排序","permalink":"https://kimanyang.xyz/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"https://kimanyang.xyz/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://kimanyang.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分法","slug":"二分法","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"(二)正则表达式解析算法详解","slug":"由实例开始构造正则引擎(2)正则算法详细介绍","date":"2022-01-26T11:58:24.000Z","updated":"2022-03-27T11:27:20.072Z","comments":true,"path":"2022/01/26/由实例开始构造正则引擎(2)正则算法详细介绍/","link":"","permalink":"https://kimanyang.xyz/2022/01/26/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(2)%E6%AD%A3%E5%88%99%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"正则表达式解析算法详解概述与背景知识本文将详细描述一个简单的正则引擎所需的所有算法，包括: 递归下降分析，构造正则表达式的抽象词法解析树 McMaughton-Yamada-Thompson算法，实现正则结构词法树转换成 前文讲述过的*到转换*进一步扩充，采用子集构造法 我们之前一笔带过的消除重复状态的Hopcrpft算法，也可称为到的转换 在开始讲解这些算法之前，先定义一下在这个系列中所使用的正则表达式类型为纯正则表达式，所描述的语法并不会超过乔姆斯基三型文法（正规文法）的表示范围。对扩展正则表达式不做要求。首先给出我们的正则表达式的扩展巴克斯范式文法表示，一个表达式由可选的多个“项(term)”并联而成，每个项由可选的多个因子(factor)(子因子和重复*、多次重复+、可选?)构成，每个子因子由字符(char)或者被括号括起来的表达式构成。 1234expr ::= term(\"|\"term)*term ::= factor*factor ::= (subfactor|subfactor (\"*\"|\"+\"|\"?\"))subfactor ::= char | \"(\" expr \")\" 为了更好地理解构造解析器的过程，这里没有引入过多的token，demo版本功能局限于匹配Ascii码表示范围内的非保留字符(左右小括号、星号、加号、问号)的正则表达式，很容易在这基础上进行扩充。 最后在开始之前，我们给出关于和在集合论基础上的形式化定义，这些定义有助于我们更好地理解算法，当然只要理解非确定与确定的区别在于后继转移状态是否唯一也完全足够了。 NFA（非确定有限状态自动机）： ——有限的状态集合 ——输入字母表，输入符号集合(假设空边不在中) ——转换映射，。具体来说，表示了从出发沿着边所能够到达的状态集合 ——开始状态，，有且仅有一个 ——终止状态集合， DFA（确定有限状态自动机）： ——有限的状态集合 ——输入字母表，输入符号集合(假设空边不在中) ——转换函数，。具体来说，表示了从出发沿着边所能够到达的唯一状态 ——开始状态，，有且仅有一个 ——终止状态集合， 递归下降分析我们以一个简单的正则表达式串为例讲解递归下降分析算法，我们这里采用自顶向下的最左推导方法。 给定正则表达式b?(ab+)|cd*，用表示规则的串联，则可以获得如下的词法解析树： 123456789101112131415161718192021222324252627graph TDvbar((\"|\"));add1((\"@\"));add2((\"@\"));add3((\"@\"));q((?));star((*));plus((+));char1((b));char2((a));char3((b));char4((c));char5((d));vbar --left--&gt; add1;vbar --right--&gt; add2;add1 --left--&gt;add3;add3 --left--&gt; q;q--left--&gt;char1;add3 --right--&gt;char2;add1 --right--&gt;plus;plus --left--&gt; char3;add2 --left--&gt;char4;add2 --right--&gt; star;star --left--&gt; char5; 接下来我们可以设计一个递归算法的雏形来表示递归下降构造树的过程，伪代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374token parse_expr();token parse_term();token parse_factor();token parse_char();/**文法 expr ::= term(\"|\"term)* 的解析过程 例如 term1 | temr2 | term3 的树为 expr(alt2(|)) / \\ alt1(|) term3 / \\ term1 term2**/token parse_expr() { t = parse_term(); while(cur_char == '|') { cur_char = get_next_char(); p = parse_term(); alt = new Tree_node_with_child_t_and_p(); t = alt; } return t;}/**文法 term ::= factor+ 的解析过程 例如 f1f2f3的树为(其中f1 f2 f3指三个factor) + / \\ + f3 / \\ f1 f2 **/token parse_term() { t = parse_factor(); while(currentChar == '(' || inalphabet(cur_char)) { cur_char = get_next_char(); p = parse_factor(); concat = new Tree_node_with_concat_child_t_and_p(); t = concat; } return t;}/**文法 factor ::= (subfactor|subfactor (\"*\"|\"+\"|\"?\")) 的解析过程 例如： a+ b? c* d的语法树分别为： oneMore option closure d / / / a b c**/token parse_factor() { t = parse_subfactor(); while(cur_char == '*' || cur_char == '+' || cur_char == '?') { cur_char = get_next_char(); case '*': subtype = new Tree_node_with_closure_and_child_t(); case '+': subtype = new Tree_node_with_oneMore_and_child_t(); case '?': subtype = new Tree_node_with_option_and_child_t(); t =subtype; } return t;}/**文法 subfactor ::= char | \"(\" expr \")\" 的解析过程 此处要么得到单个字符作为token返回，要么直接回到开始的表达式解析**/token parse_subfactor() { t = nullptr; if(cur_char == '(') { cur_char = get_next_char(); t = parse_expr(); cur_char = get_next_char();//这里忽略左右括号，并不单独给予token } else { t = new Tree_node_with_char_nochild(); cur_char = get_next_char(); //叶子节点可以跳过解析下一字符 } return t;} 这样我们手写的分析器就将所有的token都获取下来了，正式代码需要注意一下递归边界条件，在了解整个流程之后我们再定义一下所有的token类型： 12345678enum TokenType { CHAR, //字符 ALTER, // '|'连接符 CONCAT, //代表factor之间的连接关系，图中以'@'表示 KLEEN, //克林闭包，即符号'*' OPTION, //可选关系，即符号'?' P_KLEEN, //一个以上匹配的克林闭包，即符号'+'} Thompson算法现在我们已经将正则表达式字符串转换为一颗抽象语法解析树（AST）了，下面介绍通过Thompson算法将解析树转换为一个。该算法是语法制导的，也就是说它沿着正则表达式的语法解析树自底向上递归地进行处理，对于每一个子表达式，该算法构造一个只有一个接收状态的。再前一篇文章中有提到过这种构造法，现在我们详细复习一遍并给出伪代码实现。 基本规则 对于空边，构造如下: 1234graph LR;st((start));en{end};st -- 空边 --&gt; en; 对于字符集子表达式构造如下： 1234graph LR;st((start));en{end};st -- 字符集 --&gt; en; 归纳规则 规则的串联 12345678graph LR;st1((start));en1{end};st2((start));en2{end};st1 -- 子状态1 --&gt; en1;en1 -- 空边 --&gt; st2;st2 -- 子状态2 --&gt; en2; 规则的并联 123456789101112131415161718graph LR;st((start));en{end};st1((start));en1{end};st2((start));en2{end};st3((start));en3{end};st -- 空边 --&gt; st1;st -- 空边 --&gt; st2;st -- 空边 --&gt; st3;st1 --子状态1 --&gt;en1;st2 --子状态2 --&gt;en2;st3 --子状态3 --&gt;en3;en1 --空边--&gt;en;en2 --空边--&gt;en;en3 --空边--&gt;en; 规则的克林闭包 12345graph LR;st((start));en{end};st --子状态--&gt; en;en --空边 --&gt;st; 实例分析采用我们在递归下降分析中使用的例子b?(ab+)|cd*以及现成的语法分析树： 123456789 | / \\ @ @ / \\ / \\@ + c * / \\ / / ? a b d / b 通过后序遍历可以逐步构造出我们所需要的每一个状态，在对每一个子树的规则实施规纳规则时首先把子树规则的开始和结束状态转为普通状态。 遍历到b，对应着一个基本规则即接受b的规则 再到?，对应着串联一个左子树规则(接受b的规则)再并联一个空边的基本规则 再到a，对应这一个基本规则即接受a的规则 再到@符号，对应将左子树的规则和右子树的规则串联 再到b，对应着一个基本规则即接受b的规则 再到+，对应着左子树规则(接受b的规则)串联一个左子树(接受b的规则)规则的克林闭包 再到@，对应着左子树规则和右子树规则串联 再到c，对应着一个基本规则即接受c的规则 再到d，对应着一个基本规则即接受d的规则 再到*，对应着左子树规则(接受d的规则)的克林闭包 再到@，对应着左子树规则和右子树规则串联 最后来到根节点|，对应着左子树规则和右子树规则的并联 通过上述算法我们构造出了一个含有大量冗余状态和空边的，具体的状态机形式如下图所示： 1234567891011121314151617181920212223242526graph LR;st((start));st1((1));st3((3));st4((4));st5((5));st6((6));st7((7));st8((8));st9((9));st10((10));st11((11));st12((12));st13((13));st14((14));en{end};st -- 空边 --&gt;st1;st --空边 --&gt;st11;st1 --b--&gt;st3;st1 -- 空边 --&gt;st3;st3 --空边--&gt;st4;st4 -- 空边 --&gt; st5;st5 -- a --&gt;st6;st6--空边--&gt;st7;st7--b--&gt;st8;st8--空边--&gt;st9;st9--b--&gt;st10;st10 --空边--&gt;st9;st10 -- 空边 --&gt;en;st11 -- c --&gt; st12;st12 -- 空边 --&gt;st13;st13 -- d --&gt;st14;st14 --空边 --&gt;st13;st13 --空边--&gt;st14;st14 -- 空边 --&gt;en; 可以发现串联操作形成了大量的空边，在这里我们可以初步将这些串联操作引起空边相邻状态合并来消除空边而不影响状态机的正确性。 子集构造法在前一篇博文中我们介绍了如何消除空边的算法，但是并不能保证获得的不带空边的状态机一定会成为确定的状态机。下面先从理论上介绍完全消除不确定性的完整的子集构造法(subset construction)，再对上述例子实施子集构造法。 算法理论我们规定输入的非确定有限状态自动机是，最终输出的确定有限状态自动机是，通过子集构造法，中的每一个状态最终会是中的状态的集合。首先我们定义三种在上的操作，规定的状态集合为，设而，三种操作为： ，指从状态开始只通过空边所能够到达的上状态集合 ，指从集合中某个状态开始只通过空边所能够到达的上状态集合，即 ，指从集合中某个状态开始通过的边能够到达的上状态集合(不能走空边) 算法的流程如下： 其中指的是根据子集构造法最终能够构造出来的状态集。开始前将初始状态的加入状态集合。随后进行归纳的广度优先搜索，将经由能够到达的状态集合的作为的一个状态并不加标记，直到最终的所有状态都是被标记的。 实例分析示例给出正则表达式b?abb?|cd由Thompson算法得到的非确定有限状态自动机： 1234567891011121314151617graph LR;st((start));st1((1));st3((2));st4((3));st5((4));st6((5));st7((6));st8((7));st9((8));en{end};st -- ε --&gt; st1;st -- ε --&gt; st7;st1 -- b --&gt; st3;st1 -- ε --&gt;st3;st7 -- c --&gt; st8;st3 -- a --&gt; st4;st4 -- b --&gt; st5;st5 -- b --&gt; st6;st5 -- ε --&gt; st6;st8 -- d --&gt; st9;st9 -- ε --&gt;en;st6 -- ε --&gt;en; 对于上述的状态机模型我们采用子集构造法，首先定义字符集和状态转换表，可以看出状态总共有10个，字符集，于是有如下的状态转换表（一个状态的包括其自身）： a b c d start {st,1,2,6} {3} {2} {7} 状态1 {1,2} {3} {2} 状态2 {2} {3} 状态3 {3} {4} 状态4 {4,5,end} {5} 状态5 {5,end} 状态6 {6} {7} 状态7 {7} {8} 状态8 {8,end} end {end} 开始时刻我们的 集合下标tag表示被标记 标记初始的状态，遍历字符集， 查表状态{st, 1，2，6}经由可达状态的有{3}，于是将{3}不加标记加入状态集合中，同时将边{st, 1,2,6}经由a到{3}加入转换函数 查表状态{st, 1，2，6}经由可达状态的有{2}，于是将{2}不加标记加入状态集合中，直接将边{st, 1,2,6}经由b到{2}加入转换函数 查表状态{st, 1，2，6}经由可达状态的有{7}，于是将{7}不加标记加入状态集合中，同时将边{st, 1,2,6}经由c到{7}加入转换函数 查表状态{st, 1，2，6}经由d可达状态啥也没有 此时我们的，取出状态{3}，遍历字符集 查表状态{3}经由a/c/d啥也到达不了，经由b可以到达的状态的有{4，5，end}，于是将{4,5,end}不加标记加入状态集合中，同时将边{3}经由b到{4,5,end}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag}{ 2} {7} {4,5,end} }$，取出状态{7}，遍历字符集 查表状态{7}经由a/b/c啥也到达不了，经由b可以到达的状态的有{end,8}，于是将{end,8}不加标记加入状态集合中，同时将边{7}经由d到{end,8}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}_{tag} {2} {4,5,end} {end,8} }$，取出状态{2},遍历字符集 状态2经由b/c/d啥也到达不了，经由a到达的{3}已经在集合中了，于是将{2}经由a到达{3}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end} {end,8} }$，取出状态{4,5,end}，遍历字符集 查表状态{4,5,end}经由a/c/d啥也到达不了，经由b到达的{5,end}，于是将{5,end}不加标记地加入状态集合中，同时将边{4,5,end}经由b到{5,end}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end}_{tag} {end,8} {5,end} }$，取出状态{end,8}遍历字符集，所得的{end,8}已在集合中，没有可得状态 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end}{tag} {end,8}{tag} {5,end} }$，取出最后一个状态{5,end}，遍历字符集，所得的{end,5}已在集合中，没有可得状态 至此算法结束，我们得到了一个状态集合$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end}{tag} {end,8}{tag} {5,end}_{tag} }，以及它们对应的边和转换函数，在算法执行过程中我们可以直接将含有end状态的新状态标记为DFA$的终止状态，让我们重新命名这几个状态并将其转换函数表展现出来： 状态 状态 a b c d {st,1,2,6} A B D C {3} B E {7} C F {2} D B {4,5,end} E G {end,8} F {5,end} G 根据上述的状态转换表得到下面的b?abb?|cd对应图: 1234567891011graph LR;A((A));B((B));C((C));D((D));E{E};F{F};G{G};A --a --&gt;B;A --b --&gt;D;A --c --&gt;C;B -- b --&gt; E;C -- d --&gt;F;D -- a --&gt;B;E -- b --&gt;G; 子集构造法在其自身运行的过程中已经完成了我们在第一篇博客中所说的的消除空边的要求以及消除不确定性的要求，因此也不需要额外运行消除空边的算法了，但单纯消除空边并模拟带回溯来验证正则表达式在某些场景下效率可能并不低，所以先前所说的算法也存在应用场景。具体可以参考3.7.5节的和效率的分析，对于构建高效的正则引擎或者不同场景下的正则引擎优化很有帮助。 在这里额外说明一下，存在算法可以直接通过正则表达式的语法分析树获得其对应，可以参考《编译原理》第二版（即大家都很熟悉的龙书）的3.9.2节内容。 Hopcrpft算法该算法用于最小化一个的状态数，正如我们在前一篇博文中所描述的解析C语言数字的正则表达式可以有 ([+-]?\\\\\\\\d+)|([+-]?((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?)\\\\\\\\d+ ([+-]?(\\\\\\\\d+(\\\\\\\\.\\\\\\\\d*)?|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?\\\\\\\\d+)? 两种，显然第二种更短，两个正则表达式对应的也很可能是不同的。进一步地，我们在做题求解自动机的过程中已经发现了存在一些相同的状态可以进行化简，Hopcrpft算法可以在的时间复杂度以内做到这件事。下面我们就介绍与化简相关的理论知识。 算法理论不加证明地给出一个结论：任何正则语言都有一个唯一的（不计同构）状态数目最小的，而且从任意一个接受相同语言的出发，通过分组合并等价的状态，我们总是可以构建得到状态数目最小的。 首先定义在中两个状态什么情况下是可区分的，这对于我们理解什么状态可以进行合并十分有帮助。 可区分性：如果我们从两个状态和出发，沿着标号为的路径到达了两个状态，这两个状态之中只有一个是终止状态，那么我们称这个串能够区分状态和。如果对于两个状态和存在这样的串，那么这两个状态就是可区分的。 显然一个空串能够区分非终止状态和非终止状态 我们的算法所要做到的事情是将一个中的状态进行分组，组内的状态不可相互区分，将整个组作为最小的一个状态。算法大致思想如下： 输入： ， 输出：，，和接收相同的语言且状态数最小 初始时刻，我们将中的状态分为两个组，分别为非接受组（包含所有非终止状态）和接受组（包含所有终止状态）。从我们的当前划分出的组中选择一个状态组，选定某个输入符号检查是否可以用于区分状态组中的某些状态，对于能够区分的我们就划分为多个组使得组内的状态在作用下都到达相同的状态。重复上述分割过程直到无法继续分割。我们把某一步的算法得到的分割方法定义为，初始划分为定义为。算法完成时的分割方法定义为。下面给出算法流程： 如先前所说划分两个组接受组和非接受组作为初始划分 如下图所示进行划分构造 如果则直接令；否则用替换并重复步骤2。 在分划出的的每个组选定一个状态作为该组的代表，这些代表构成了的状态，对于这些状态： 的开始状态是包含了开始状态的组 的终止状态是包含了终止状态的组 令是中某个组的代表，并令中在输入上离开的转换到达状态。令为所在组的代表，那么在中存在一个从到在输入上的转换。 有两个要点需要注意： 状态最小化的原理：要使得算法成立且最终得到的结果是最小化的，我们不做证明给出两个性质： 仍然位于的同一组状态不可能被任意串区分 不同子组之间的状态时可区分的 死状态的消除：最小化算法可能产生带有所有输入符号上都指向自己的非接受状态，这种状态可能使得识别无法提早退出，被称为死状态 实例分析考虑正则表达式a|abb|a*b+，通过Thompson算法获得的形式为： 123456789101112131415161718graph LR;st((0));st1((1));st2((2));st3((3));st4((4));st5((5));st6((6));st7((7));st8((8));en((end));st --ε--&gt; st1;st -- ε --&gt;st3;st -- ε --&gt;st7;st1 -- a --&gt; st2;st3 -- a --&gt;st4;st4 -- b --&gt; st5;st5 -- b --&gt;st6;st7 -- a --&gt;st7;st7 -- b --&gt;st8;st8 -- b --&gt;st8;st2 -- ε --&gt;en;st6 -- ε --&gt;en;st8 -- ε --&gt;en; 经过子集构造法可以获得如下的: 12345678910111213graph LR;st1((0137));st2{247};st3((7));st4{8};st5{68};st6{58};st1 -- a --&gt; st2;st1 -- b --&gt; st4;st2 -- a --&gt; st3;st2 -- b --&gt; st6;st3 -- a --&gt;st3;st3 -- b --&gt;st4;st4 -- b --&gt; st4;st5 -- b --&gt; st4;st6 -- b --&gt; st5; 对于上图的，其初始划分为：{0137,7} {247,8,58,68}，对于每个组内的状态，我们遍历字母表和，出现不同的状态就区分，经过多次迭代可以得到最终的区分依次是：","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"}]},{"title":"(一)字符串正则匹配的动态规划与编译原理思路","slug":"由实例开始构造正则引擎(1)字符串正则匹配的动态规划与编译原理思路","date":"2022-01-21T13:08:34.000Z","updated":"2022-03-27T11:27:20.368Z","comments":true,"path":"2022/01/21/由实例开始构造正则引擎(1)字符串正则匹配的动态规划与编译原理思路/","link":"","permalink":"https://kimanyang.xyz/2022/01/21/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(1)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF/","excerpt":"","text":"字符串正则匹配的动态规划与编译原理思路题目引入下面两道力扣题目分别代表了两种不同类型的状态机，第一种是正则表达式到到的转换，第二种是正则表达式到到的转换，选取这两道可以对状态机的设计有更深刻的认识（面试必不会考但是自己写正则引擎总得会一点）。 10.正则表达式匹配（hard)给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 .匹配任意单个字符 *匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 44.通配符匹配(hard)给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ? 和 * 的通配符匹配。 ? 可以匹配任何单个字符。 * 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和*。 动态规划解法10.正则表达式匹配（hard)字符串匹配问题通常都可以看成是二维动态规划问题，类似的题型包括子序列匹配之类的。用表示中前个字符能否和中前个字符匹配。在进行状态转移时，考虑的第个字符匹配情况： 如果的第个字符是一个小写字母，那么我们必须在中匹配一个相同的小写字母，即：$$dp[i][j]=\\left{\\right.\\notag$$如果的第个字符与的第个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符， 如果的第个字符是，那么可以对的第个字符进行0到任意次数匹配。进一步想，字母与星号的组合在匹配过程中只会出现两种情况： 匹配最末字符，使用该组合继续匹配 不进行匹配，丢弃该组合 由此可以写出模式串为时的如下的状态转移方程：$$dp[i][j]=\\left{\\right.\\notag$$ 最后只要遇到是则可以成功匹配 总结上述的三点可以获得如下的状态转移方程：$$dp[i][j]=\\left{\\begin{aligned}&amp;p[j]\\ne ‘*’=\\left{\\right.\\&amp;otherwise=\\left{\\right.\\end{aligned}\\right.\\notag$$其中判断二者是否匹配，只有是.或者时两个字符匹配。 代码实现如下： 1234567891011121314151617181920212223242526272829class Solution { public: bool isMatch(string s, string p) { int m = s.size(), n = p.size(); auto match = [&amp;](int i, int j) { if(i == 0) return false; if(p[j-1] == '.') return true; return s[i-1]=p[j-1]; }; vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); dp[0][0]=1; for(int i = 0;i &lt;= m;++i) { for(int j = 1;j &lt;= n;++j) { if(p[j-1] == '*') { dp[i][j] |= dp[i][j-2]; if(matches(i,j-1)) { dp[i][j] |= dp[i-1][j]; } } else { if(matches(i,j)) { dp[i][j] |= dp[i-1][j-1]; } } } } return dp[m][n] }} 44.通配符匹配(hard)模仿上述题目，我们分析题目要求的状态转移方程： 用表示中前个字符能否和中前个字符匹配。 当和匹配且不为通配符时，能否成功匹配取决于能否成功匹配。 当为通配符*时 要么和末尾匹配，取决于是否成功匹配 要么不匹配，取决于是否成功匹配 如果能匹配，那带*的也能继续匹配 边界条件写出状态转移方程：$$dp[i][j]=\\left{\\begin{aligned}&amp;p[j-1]\\ne’‘,s[i-1]\\Leftrightarrow p[j-1]\\implies dp[i][j]=dp[i-1][j-1] \\&amp;p[j-1]=’‘\\implies dp[i][j]=dp[i][j-1]||dp[i-1][j]||dp[i][j-1]\\end{aligned}\\right.\\notag$$ 1234567891011121314151617181920class Solution {public: bool isMatch(string s, string p) { int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1)); dp[0][0] = true; for(int i = 0;i &lt;= m;++i) { for(int j = 1;j &lt;= n;++j) { if(i &gt; 0 &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '?')) { dp[i][j] = dp[i-1][j-1]; } else if(p[j-1] == '*') { dp[i][j] = dp[i][j] || dp[i][j-1]; if(i &gt; 0) dp[i][j] = dp[i][j] || dp[i-1][j-1]; if(i &gt; 0) dp[i][j] = dp[i][j] || dp[i-1][j]; } } } return dp[m][n]; }}; 非确定有限状态自动机解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*用于构造NFA图的节点结构*/type Node struct { C byte //当前节点接受的字符 Parent *Node //正向生成时的母节点，用于生成自由长度0节点的可跨越边 Children map[byte][]*Node //子节点个数，一个字节可以对应多个索引（NFA） End bool //是否为终止节点 Size int //节点长度，如果携带的是*则长度为0，否则为1（只能匹配一个）}/* 核心功能实现，递归生成NFA 函数签名： @param: now 当前要递归生成的节点的根 @param: str 模式串，递归中无修改 @param: idx 当前匹配的坐标,是now要生成节点对应的字符*/func generatePattern(now *Node, str string, idx int) int { //到达当前末尾 if len(str) &lt;= idx { now.End = true return now.Size } vnow := now //用于下一次更新的节点 switch str[idx] { case '*': now.Size = 0 //无限匹配自由长度为0 now.addVertex(now.C, now) //自己可以接受自己 default: node := new(Node) //创建下一字符节点 node.C = str[idx] now.addVertex(str[idx], node) //当前字符节点后继添加 node.Parent = now //当前节点父节点设为node node.Size = 1 //节点自由长度为1 vnow = node //当前节点可以更新为新的节点 } //如果是*则不用创建新节点 ret := generatePattern(vnow, str, idx+1) //后续已无节点（或者只有x*匹配),则当前节点也可作为终止态 if ret == 0 { now.End = true } //给当前的后继节点配野爹 addParent := now for addParent.Parent != nil { //对于正常节点,vnow是我的后继，如果当前节点的长度为零，那我的后继也是我父母节点的后继 if addParent.Size == 0 { //debug(toString(vnow), \" -&gt; \", toString(addParent.Parent)) addParent.Parent.addVertex(vnow.C, vnow) //父母添加一条到我后继节点的边 addParent = addParent.Parent //递归匹配到 } else { break } } return now.Size + ret}/*为节点n添加一条经由c到达child的边，回溯时会进行新的创建*/func (n *Node) addVertex(c byte, child *Node) { m := n.Children //没有后继列表就创建一个 if m == nil { m = make(map[byte][]*Node) n.Children = m } list := m[c] //当前字符不存在就创建一个 if list == nil { list = make([]*Node, 0) } //遍历当前的可达状态，如果存在目标状态则退出 for _, v := range list { if v == child { m[c] = list return } } //状态不存在，更新列表 list = append(list, child) m[c] = list}//递归检查是否能够匹配func check(now *Node, str string, idx int) bool { if len(str) &lt;= idx { return now.End } list := now.Children['.'] for _, v := range now.Children[str[idx]] { list = append(list, v) } for _, v := range list { r := check(v, str, idx+1) if r { return true } } return false}//使用示例，判断s是否能被接受func isMatch(s string, p string) bool { begin := new(Node) //创建start节点 begin.C = '&gt;' begin.Size = generatePattern(begin, p, 0) //递归构造模式串有穷状态自动机 return check(begin, s, 0)} 所构造的图片： 状态机分别为c*..b*a*a.*a..*c和mis*is* 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950graph LR; id0xc4200809c0((&gt;)); id0xc4200809f0((c)); id0xc4200809f0 -- c --&gt; id0xc4200809f0; id0xc420080a80((.)); id0xc420080ab0((.)); id0xc420080b10((b)); id0xc420080b10 -- b --&gt; id0xc420080b10; id0xc420080ba0((a)); id0xc420080ba0 -- a --&gt; id0xc420080ba0; id0xc420080c00((a)); id0xc420080c30((.)); id0xc420080c30 -- . --&gt; id0xc420080c30; id0xc420080cc0((a)); id0xc420080cf0((.)); id0xc420080d50((.)); id0xc420080d50 -- . --&gt; id0xc420080d50; id0xc420080de0{c}; id0xc420080d50 -- c --&gt; id0xc420080de0; id0xc420080cf0 -- . --&gt; id0xc420080d50; id0xc420080cf0 -- c --&gt; id0xc420080de0; id0xc420080cc0 -- . --&gt; id0xc420080cf0; id0xc420080c30 -- a --&gt; id0xc420080cc0; id0xc420080c00 -- . --&gt; id0xc420080c30; id0xc420080c00 -- a --&gt; id0xc420080cc0; id0xc420080ba0 -- a --&gt; id0xc420080c00; id0xc420080b10 -- a --&gt; id0xc420080ba0; id0xc420080b10 -- a --&gt; id0xc420080c00; id0xc420080ab0 -- b --&gt; id0xc420080b10; id0xc420080ab0 -- a --&gt; id0xc420080c00; id0xc420080ab0 -- a --&gt; id0xc420080ba0; id0xc420080a80 -- . --&gt; id0xc420080ab0; id0xc4200809f0 -- . --&gt; id0xc420080a80; id0xc4200809c0 -- c --&gt; id0xc4200809f0; id0xc4200809c0 -- . --&gt; id0xc420080a80; id0xc420080780((&gt;)); id0xc4200807b0((m)); id0xc420080810((i)); id0xc420080870((s)); id0xc420080870 -- s --&gt; id0xc420080870; id0xc420080900{i}; id0xc420080930{s}; id0xc420080930 -- s --&gt; id0xc420080930; id0xc420080900 -- s --&gt; id0xc420080930; id0xc420080870 -- i --&gt; id0xc420080900; id0xc420080810 -- s --&gt; id0xc420080870; id0xc420080810 -- i --&gt; id0xc420080900; id0xc4200807b0 -- i --&gt; id0xc420080810; id0xc420080780 -- m --&gt; id0xc4200807b0; 上述Go代码的C++版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class NFAnode{ public: char ch; NFAnode* parent; unordered_map&lt;char,vector&lt;NFAnode*&gt;&gt; children; bool isEnd; int size; void addVertex(char ch, NFAnode* child) { auto&amp; m = this-&gt;children; auto&amp; list = m[ch]; for(auto&amp; v:list) { if(v == child) { m[ch] = list; return; } } list.push_back(child); m[ch] = list; }};class Solution {private:public: bool isMatch(string s, string p) { NFAnode* begin = new NFAnode(); begin-&gt;ch = '@'; begin-&gt;size = genneratePatern(begin,p,0); return checkHelper(begin,s,0); } int genneratePatern(NFAnode* now, string str,int idx) { if(str.length() &lt;= idx) { now-&gt;isEnd = true; return now-&gt;size; } NFAnode* vnow = now; if(str[idx] == '*') { now-&gt;size = 0; now-&gt;addVertex(now-&gt;ch,now); } else { NFAnode* node = new NFAnode(); node-&gt;ch = str[idx]; now-&gt;addVertex(str[idx],node); node-&gt;parent = now; node-&gt;size = 1; vnow = node; } int ret = genneratePatern(vnow, str, idx + 1); if(ret == 0) { now-&gt;isEnd = true; } NFAnode* addParent = now; while(addParent-&gt;parent != nullptr) { if(addParent-&gt;size == 0) { addParent-&gt;parent-&gt;addVertex(vnow-&gt;ch,vnow); addParent = addParent-&gt;parent; } else { break; } } return now-&gt;size + ret; } bool checkHelper(NFAnode* now, string str, int idx) { if(str.length() &lt;= idx) { return now-&gt;isEnd; } auto list = now-&gt;children['.']; for(auto&amp; v:now-&gt;children[str[idx]]) { list.push_back(v); } for(auto&amp; v:list) { bool r = checkHelper(v,str,idx+1); if(r) {return true;} } return false; }}; 读者们如果无法理解代码也没有关系，下一篇文章会详细讨论递归下降构造词法树到最终进行状态机匹配的过程。 从正则到或者到转换罗列知识可能比较难以理解，我们先直观地从简单的题目开始一步一步展示算法实现的过程。 状态机经典题目——65.有效数字有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 给定一个字符串，判断是否为有效数字字符串。 正则表达式解法：显然问题可以直接由正则表达式解决，首先将规则构造为正则表达式也有利于我们进一步的状态机分析。 代码如下： 12345678const regex Solution::pattern(\"[+-]?(?:\\\\\\\\d+\\\\\\\\.?\\\\\\\\d*|\\\\\\\\.\\\\\\\\d+)(?:[Ee][+-]?\\\\\\\\d+)?\");class Solution {public: static const regex pattern; bool isNumber(string str) { return regex_match(str, pattern); }}; 分析上述的表达式： 一个整数的正则表达：[+-]?\\\\\\\\d+ 一个小数的正则表达:[+-]?((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)) 组合起来再带上可选的e和E:(小数|整数)[eE]整数 展开来便是([+-]?\\\\\\\\d+)|([+-]?((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?)\\\\\\\\d+ 需要注意C++的字符串中添加双斜杠\\\\\\\\是为了转义第二个斜杠，实际内存中还是一个\\，即\\\\\\\\d表示标准正则语法中的\\d。（两层套娃） 正则化简从化简的角度理解会更容易一些，也可以给出一些普适的结合律交换律来化简。这里先给出上述正则的简化表达，这也是一部分题解中给出的正则表达式： 1([+-]?(\\\\\\\\d+(\\\\\\\\.\\\\\\\\d*)?|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?\\\\\\\\d+)? 从正则到我们将上述抽象的正则表达式一步一步转换为状态机模型，这里的算法被称为Thompson算法。 首先我们确定正则表达式中的字符集，对于我们要进行解析的这个正则表达式来说，字符集为[+-.deE]。 其次我们分析正则表达式中的构造方法，并将其对应到中。五种构造方法分别为： 字符集接受，即一个规则集合，比如[+-]和小括号内的所有内容： 1234graph LR;st((start));en{end};st -- 字符集 --&gt; en; 规则的串联，即正则表达式中两个规则直接链接构造的新规则 12345678graph LR;st1((start));en1{end};st2((start));en2{end};st1 -- 字符集1 --&gt; en1;en1 -- 空边 --&gt; st2;st2 -- 字符集2 --&gt; en2; 规则的并联，即正则表达式中两个或以上规则以|链接 123456789101112131415161718graph LR;st((start));en{end};st1((start));en1{end};st2((start));en2{end};st3((start));en3{end};st -- 空边 --&gt; st1;st -- 空边 --&gt; st2;st -- 空边 --&gt; st3;st1 --字符集1 --&gt;en1;st2 --字符集2 --&gt;en2;st3 --字符集3 --&gt;en3;en1 --空边--&gt;en;en2 --空边--&gt;en;en3 --空边--&gt;en; 规则的重复（1次及以上），即正则表达式中的X+一个或以上匹配，为了后续分析方便采用复制状态的表示： 123456789graph LR;st((start));en{end};st1((start));en1{end};st --子状态1--&gt; en;en --空边--&gt; st1;st1 --子状态1--&gt; en1;en1 --空边--&gt;en; 规则的可选，即正则表达式中的X?,只需要将起始状态和终止状态相连接。 12345graph LR;st((start));en{end};st --子状态--&gt; en;st --空边 --&gt;en; 对于4的特殊情况X*匹配零次及以上，则直接令end同时拥有起始和终止两个状态即可。至此我们根据已有的知识构造题目正则表达式所对应的，空边用null表示则有： 1234567891011121314151617181920212223242526272829303132333435363738graph LR;st((start));st1((state1));st2((state2));st3((state3));st4((state4));st5((state5));st6((state6));st7((state7));st8((state8));st9((state9));st10((state10));st11((state11));st12((state12));en{end};st -- +- --&gt; st1;st --null --&gt;st1;st1 -- null --&gt;st2;st1 -- null --&gt;st6;st2 -- digit --&gt;st3;st3 -- digit --&gt;st3;st3 -- . --&gt; st4;st3 -- null --&gt;st5;st4 -- digit --&gt; st5;st4 -- null --&gt;st5;st5 -- digit --&gt;st5;st5 -- null --&gt;st9;st6 -- . --&gt; st7;st7 -- digit --&gt; st8;st8 -- digit --&gt;st8;st8 -- null --&gt;st9;st9 -- eE --&gt;st10;st9 -- null --&gt;en;st10 -- +- --&gt;st11;st10 -- null --&gt; st11;st11 -- digit --&gt;st12;st12 -- digit --&gt;st12;st12 -- null --&gt; en; 出于展示简便没有完全按照上述的形式得出上图展示的的模型，做了一些较为直观的冗余空边化简。 的非确定性消除非确定性的消除主要有两点：1.消除空边 2. 将转换为。 消除空边不作证明地给出以下的算法过程： 找到所有的有效状态 有效状态指存在非(空)边输入的状态。同时起始状态也是有效状态，另外如果一个状态可以通过空边到达结束状态，那么该状态也应该变成结束状态。在我们的例子中，有效状态有状态1、状态3、状态7、状态4、状态8、状态5、状态10、状态11和状态12。状态5、8和12应该被标记为结束状态。 添加必要的边 这一步为核心算法。我们针对每一个有效状态实行如下算法： 寻找该状态的**闭包，一个状态的闭包指的是：从该状态出发仅仅通过边能够到达的所有状态**。 将所有从这个闭包中输出的边的出发点全部复制到当前状态上。 我们以初始节点为例实施该算法，可以看到初始节点通过空边能够到达的状态包括状态1、2和6。实施算法后的图变为： 1234567891011121314151617181920212223242526272829303132333435363738394041graph LR;st((start));st1((state1));st2((state2));st3((state3));st4((state4));st5((state5));st6((state6));st7((state7));st8((state8));st9((state9));st10((state10));st11((state11));st12((state12));en{end};st -- +- --&gt; st1;st --null --&gt;st1;st -- digit --&gt;st3;st -- . --&gt; st6;st1 -- null --&gt;st2;st1 -- null --&gt;st6;st2 -- digit --&gt;st3;st3 -- digit --&gt;st3;st3 -- . --&gt; st4;st3 -- null --&gt;st5;st4 -- digit --&gt; st5;st4 -- null --&gt;st5;st5 -- digit --&gt;st5;st5 -- null --&gt;st9;st5 -- digit --&gt;st5;st6 -- . --&gt; st7;st7 -- digit --&gt; st8;st8 -- digit --&gt;st8;st8 -- null --&gt;st9;st9 -- eE --&gt;st10;st9 -- null --&gt;en;st10 -- +- --&gt;st11;st10 -- null --&gt; st11;st11 -- digit --&gt;st12;st12 -- digit --&gt;st12;st12 -- null --&gt; en; 对所有的有效状态实施该算法后，最后我们需要删除所有无效状态和空边。算法应用的结果如下： 1234567891011121314151617181920212223242526272829graph LR;st((start));st1((state1));st3{state3};st4((state4));st5{state5};st7((state7));st8{state8};st10((state10));st11((state11));st12{state12};st -- digit --&gt; st3;st -- +- --&gt; st1;st -- . --&gt; st7;st1 -- digit --&gt;st3;st1 -- . --&gt;st7;st3 -- digit --&gt; st3;st3 -- . --&gt;st4;st3 -- eE --&gt;st10;st4 -- digit --&gt;st5;st4 -- eE --&gt; st10;st5 -- digit --&gt;st5;st5 -- eE --&gt; st10;st7 -- digit --&gt;st8;st8 -- digit --&gt;st8;st8 -- eE --&gt; st10;st10 -- +- --&gt; st11;st10 -- digit --&gt;st12;st11 -- digit --&gt;st12; 注意到我们将状态3、5、8和12标记为结束状态，而最终的结束状态作为无效状态清除。 这个算法实际上就是我们在之前的正则表达式匹配中应用的算法。可以看到我们得到的已然是一个，不是所有时候都可以这么理想直接得到一个的，我们仍然需要算法将转换为。图中的状态仍然不是最简的，比如状态5和状态8就是重复的。述的正则表达式的简化也可以通过先将复杂正则表达式的写出后再进行重复状态合并来获得，重复状态指的是具有相同的入度字符集和出度字符集的状态。 从到在下一节我们会详细讨论编译原理中的子集构造法, 解决题目65：现在我们可以直接根据写出状态机的代码，遍历循环简单实现可以通过if语句跳转实现，这里介绍一种实际中使用的表驱动方法，代码直接采用官方的题解。 首先列举我们的状态和字符集边： 12345678910111213141516171819enum State { STATE_START, //初始状态 STATE_INT_SIGN, //状态1 STATE_INTEGER, //状态3 STATE_POINT, //状态4 STATE_POINT_WITHOUT_INT, //状态7 STATE_FRACTION, //状态5和状态8，重复可以直接合并 STATE_EXP, //状态10 STATE_EXP_SIGN, //状态11 STATE_EXP_NUMBER, //状态12 STATE_END //结束状态}; enum CharType { CHAR_NUMBER, //digit CHAR_EXP, //eE CHAR_POINT, //. CHAR_SIGN, //+- CHAR_ILLEGAL //其他非法字符 }; 接下来我们打表，基本上表驱动的表都是用哈希表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//状态转移表unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer{ { STATE_INITIAL, {//对应由初始状态出发的3条边到达的状态 {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, {CHAR_SIGN, STATE_INT_SIGN} } }, { STATE_INT_SIGN, {//对应由状态1出发的2条边到达的状态 {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT} } }, { STATE_INTEGER, {//对应由状态3出发的3条边到达的状态 {CHAR_NUMBER, STATE_INTEGER}, {CHAR_EXP, STATE_EXP}, {CHAR_POINT, STATE_POINT} } }, { STATE_POINT, {//对应由状态4出发的2条边到达的状态 {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP} } }, { STATE_POINT_WITHOUT_INT, {//对应由状态7出发的1条边到达的状态 {CHAR_NUMBER, STATE_FRACTION} } }, { STATE_FRACTION,{//对应由状态5和8出发的2条边到达的状态 {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP} } }, { STATE_EXP,{//对应由状态10出发的2条边到达的状态 {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SIGN, STATE_EXP_SIGN} } }, { STATE_EXP_SIGN, {//对应由状态11出发的1条边到达的状态 {CHAR_NUMBER, STATE_EXP_NUMBER} } }, { STATE_EXP_NUMBER, {//对应由状态12出发的1条边到达的状态 {CHAR_NUMBER, STATE_EXP_NUMBER} } }};//终止状态集unordered_set&lt;State&gt; endStates = { STATE_INTEGER, STATE_POINT, STATE_FRACTION, STATE_EXP_NUMBER, STATE_END} 最后实现核心功能： 1234567891011121314bool isNumber(string s) { int len = s.length(); State st = STATE_INITIAL; for (int i = 0; i &lt; len; i++) { CharType typ = toCharType(s[i]); if (!transfer[st].count(typ)) { return false; } else { st = transfer[st][typ]; } } return endStates.count(st);} 小结综上我们通过三道题简单入门了一下正则表达式编译原理，涉及知识仅仅限于求解题目，限于篇幅和作者水平没有进一步讨论。下一篇文章将具体给出正则表达式到到到再到消除多余状态的每一步算法原理。","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"}]},{"title":"Rabin-Karp字符串编码","slug":"Rabin-Krap字符串编码","date":"2022-01-19T03:22:14.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/01/19/Rabin-Krap字符串编码/","link":"","permalink":"https://kimanyang.xyz/2022/01/19/Rabin-Krap%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/","excerpt":"","text":"Rabin-Karp字符串编码基本介绍Rabin-Karp算法作为一种简单实用的哈希算法将字符串映射为一个整数。假设字符串字符不超过, 那么选取一个大于等于的整数作为，就可以将字符串看成是一个进制的整数，将其转换为十进制数字后就得到了字符串对应的编码。 假设给定的字符串,包含的字符种类为4，那么字符集。取 , 那么字符串可以看成是七进制的数字$(0123)7，转换为十进制数为66。给出如下的一般化的编码公式：$\\label{rk}encode(s) = \\sum{i=0}^{\\vert S\\vert-1}s[i]*base^{\\vert S\\vert-i-1}$$其中表示字符串长度，为对应字符位的编码，不加证明地给出关于的一个结论： 给定基底和字符集，两个字符串和相等，当且仅当它们的长度相等且编码值相等。 对于所有长度为的字符串通过比较它们的编码值可以判断它们两两之间是否相等。但对于较长的字符串很容易出现编码值超过一般语言的整数类型可表示的范围，这就需要对编码值取模，这使得中的单射性质被破坏，哈希算法可能出现哈希冲突。但是如果所取得模数足够大，那么哈希碰撞的可能性会极大降低。 如果选定单个模数，那么只有在随机产生个字符串的时候才有超过50%的几率会发生哈希碰撞。通过选择多个模数，在取多个模数结果相等时才判断相等那碰撞概率可以降到微乎其微的程度。 在正常算法题中我们只需要选定一个模数，一般选取一个质数比如，有必要多选的话再加一个。对于基底一般也选择一个质数，比如如果字符集为小写字符集，则，可以选择略大的质数31或者29。 算法实现下面针对小写字符集的Robin-Karp给出C++的算法实现： 123456789101112class Solution {public: int RobinKarpEncode(string s) { int n = s.size(); int endcode = 0; int base = 31, mod = 1000000007; for(int i = 0;i &lt; n;++i) { encode = ((long long)encode * base + (s[i] - 97)) % mod; } return encode; }}; 算法并不需要每次都去计算，这需要调用到快速幂算法，但仍然称不上快速。注意到每一次都可以重复利用到前一次的信息，假设前位的编码值为，那么第位的编码值可以表示为：可以理解为每一位都乘上基底再加上个位数构成新的编码，体现了动态规划的思想。整体的动态转移方程可以写作：$$\\label{dyn}\\left{\\right .$$同时需要注意的是未进行取模之前的乘积可能会超过int类型的取值，需要暂时地用到long long进行存储。 模板题型最长快乐前缀：「快乐前缀」是在原字符串中既是非空前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串 s，请你返回它的 最长快乐前缀。 如果不存在满足题意的前缀，则返回一个空字符串。 来源：力扣链接：https://leetcode-cn.com/problems/longest-happy-prefix 题解： 12345678910111213141516public: string longestPrefix(string s) { int n = s.length(); int mod = 100000007, base = 29, happy_pre = 0; int prefix = 0, suffix = 0, mul = 1; for(int i = 1;i &lt; n;++i) { prefix = ((long long)prefix * base + s[i-1] - 97) % mod; suffix = (suffix + (long long)(s[n-i] - 97) * mul) % mod; if(prefix == suffix) { happy_pre = i; } mul = (long long)mul * base % mod; } return s.substr(0, happy_pre); }}; 这里顺便复习一下取模的一些重要性质： ，取模的加法结合律 ，取模的乘法结合律 ，取模的乘方性质 对于代码中进行后缀计算的部分，我们使用了上述的规律 对于前缀，根据以及取模的加法结合律由下式递推计算出最终结果：对于后缀，给出如下的递推公式：$$\\left{\\begin{aligned} suffix[k] &amp;= s[k] % mod &amp;k=0\\ suffix[k] &amp;= (suffix[k-1]+mul[k] * (s[k] - 97))%mod \\ \\ &amp;k&gt;0\\ mul[k] &amp;= mul[k-1] * base % mod \\end{aligned}\\right .$$这里利用到了取模的乘法结合律（对 取模等于对内部各自取模相乘,由于字符编码较小取模之后仍然等于自身)，再同前缀方式一样利用取模的加法结合律获得后缀编码的计算方式。 恢复空格哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/re-space-lcci 示例： 12345输入：dictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]sentence = \"jesslookedjustliketimherbrother\"输出： 7解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。 这道题目我们首先得到当前的动态转移方程（完全背包问题，一个单词可以匹配无穷多次):$$\\left{能够匹配时全都不能匹配时\\right .$$完全背包的二重循环的伪代码如下： 12345678910vector&lt;int&gt; dp(n + 1, n);dp[0] = 0;for(int i = 1;i &lt;=n;++i) { dp[i] = dp[i-1] + 1; for(int j = i;j &gt;= 1;--j) { if(s[j-1:i-1] 能够匹配) { dp[i] = min(dp[i], dp[j-1]); } }} 我们的问题现在转换为如何能够快速知道s[j-1:i-1]是否在字典之中，如果采用暴力遍历字典必会超时，于是可以采用本文中所说的Rabin-Karp算法对字典预处理为哈希值的集合，在通过Rabin-Karp算法逐项匹配的特性快速计算哈希值，从而求解，完整代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {using LL = long long; //命名空间，和define作用一样private: static constexpr LL P = (1LL &lt;&lt; 31) - 1; //常数表达式，模数 static constexpr LL BASE = 41; //常数表达式，基底 //Rabin-Karp算法的实现，从后往前进行，直接用long long类型防止计算溢出 //这种实现方便我们在完全背包的循环中进行哈希值的计算而无需后缀计算的局部变量 LL getHash(const string &amp;s) { LL hashValue = 0; for (int i = s.size() - 1; i &gt;= 0; --i) { hashValue = hashValue * BASE + s[i] - 'a' + 1; hashValue = hashValue % P; } return hashValue; }public: int respace(vector&lt;string&gt;&amp; dictionary, string sentence) { unordered_set&lt;LL&gt; stringHash; //字典预处理为哈希值集合 for(auto&amp; word:dictionary) { stringHash.insert(getHash(word)); } int n = sentence.size(); vector&lt;int&gt; dp(n + 1, n); dp[0] = 0; for(int i = 1;i &lt;=n;++i) { dp[i] = dp[i-1] + 1; LL curhash = 0; for(int j = i;j &gt;= 1;--j) { //利用Rabin-Karp的逐项计算方式寻找匹配的子串，并进行动态规划的状态更新 curhash = (curhash * BASE + (sentence[j-1]- 'a' + 1)) % P; if(stringHash.count(curhash)) { dp[i] = min(dp[i], dp[j-1]); } } } return dp[n]; }}; 实际使用中的一种写法即上文第二道模板题使用的写法。 123456789101112using LL = long long;static constexpr LL P = (1LL &lt;&lt; 31) - 1;static constexpr LL BASE = 41;LL getHash(const string &amp;s) { LL hashValue = 0; for (int i = s.size() - 1; i &gt;= 0; --i) { hashValue = hashValue * BASE + s[i] - 'a' + 1; hashValue = hashValue % P; } return hashValue;} 多费点内存，少烧点脑子。 Rabin-Karp、Trie树以及KMP算法的优劣比对 KMP适合单个模式串与多个串进行匹配，不存在冲突的问题，但是多个模式串与单个目标串匹配时没有优势 Trie树可用于多个模式串与单个目标串匹配，可以给出更丰富的目标串信息（比如经典的路由解析算法可以采用Trie树进行）从而实现诸如前缀匹配、范围查找等方法，同时如果数据集是动态数据集，Trie树的插入操作也足够友好，同样不存在冲突问题具有稳定的复杂度。但缺点是占用内存较大（也存在压缩的算法）写起来比较复杂，工程实现上缺少轮子可以直接用，而且对于不同的编码诸如unicode编码还需要更多地考虑，实际工程中很少使用 本文介绍的Rabin-Karp算法不仅可以匹配多个串，相比于单纯的hash好处在于可以直接逐个单词匹配，和Trie树比起来内存占用少（因为无需为每个字典字符开辟指针节点，直接用long long或者int都能解决），时间复杂度相仿，但是存在着哈希冲突的问题。这种时候多采用几个模数就行了，在工程上是完全可以接受的，于是hash类的算法在工程中的应用更加广泛","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"},{"name":"Rabin-Karp","slug":"Rabin-Karp","permalink":"https://kimanyang.xyz/tags/Rabin-Karp/"},{"name":"哈希算法","slug":"哈希算法","permalink":"https://kimanyang.xyz/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"https://kimanyang.xyz/tags/KMP/"}]},{"title":"矩阵快速幂与状态机DP总结","slug":"矩阵快速幂与状态机DP总结","date":"2022-01-19T03:16:24.000Z","updated":"2022-03-27T11:27:20.069Z","comments":true,"path":"2022/01/19/矩阵快速幂与状态机DP总结/","link":"","permalink":"https://kimanyang.xyz/2022/01/19/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BADP%E6%80%BB%E7%BB%93/","excerpt":"","text":"状态机DP总结对于多状态的DP问题，往往可以根据给出的规则集写出相应的状态转移方程，如果是线性的DP问题其时间复杂度为，状态转移方程维数通常为2，压缩后为1。对于这类问题算法比赛中还可以通过矩阵快速幂算法使得时间复杂度降低到，在计算科学中甚至可以通过矩阵分解将时间复杂度进一步降低，这种抽象方法具有很强的扩展潜能。 本文由快速幂到矩阵快速幂逐步介绍，进一步通过例题逐步抽象出问题模型和方法。 矩阵快速幂快速幂自己实现一个double pow(double x,int n)返回x的n次方，实现代码如下： 12345678910111213141516171819double myPow(double x, int n) { long long N = n; if(N &gt;= 0) { return fastPow(x,N); } double tmp = fastPow(x,-N); return 1.0/tmp;}double fastPow(double x, long long n) { double ans = 1.0; while(n){ if( (n&amp;1) == 1){ ans *=x; } x *=x; n = n&gt;&gt;1; } return ans;} 简单举个具体例子，k的11次幂，可以分解为：$$\\begin{aligned}ans &amp;= kkkkkkkkkkk \\&amp;=k*(k^5)(k^5) \\&amp;=k(k*(k^2)^2)(k(k^2)^2) \\\\end{aligned}\\notag$$只需要经过次即4次乘方即可获得结果，不需要乘11次。具体来说就是每次为单数的时候都多乘一次，否则直接自己平方即可，可以起到加速运算的作用。具体不多做解释，直接扩展到矩阵乘法中。 矩阵拓展假设我们有如下的矩阵：要给定算法求，相应的算法如下： 1234567891011121314151617181920212223//基本原理同快速幂，单纯改变乘法，而且没有逆运算一说vector&lt;vector&lt;int&gt;&gt; fastMatrixPow(vector&lt;vector&lt;int&gt;&gt; mat, int n) { vector&lt;vector&lt;int&gt;&gt; ans = {{1,0,0},{0,1,0},{0,0,1}}; while(n != 0) { if((n&amp;1) == 1) ans = multiply_mat(ans,mat); mat = multiply_mat(mat,mat); n = n &gt;&gt; 1; } return ans;}//基础知识点，如何安排循环顺序能够使得cache命中率更高提高矩阵乘法速度vector&lt;vector&lt;int&gt;&gt; multiply_mat(vector&lt;vector&lt;int&gt;&gt; x,vector&lt;vector&lt;int&gt;&gt; y) { int n = x.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n,0)); for(int i = 0;i &lt; n;++i) { for(int j = 0;j &lt; n;++j){ for(int k = 0;i &lt; n;++k) { ret[i][j] += x[i][k] * y[k][j]; } } } return ret;} 上述矩阵乘法如此简陋速度肯定是不够快的，建议参考一下Eigen库里整的工业化模板元编程黑魔法。 模板题——Tribonacci Sequence给定递推公式且，将该递推公式改成离散的状态空间模型写作向量形式，变作能控标准型（草）:根据左乘结合律容易推导出：令,问题转换为求解 次方，复用我们在矩阵拓展一节的代码可以得到： 123456int tribonacci(int n) { vector&lt;vector&lt;int&gt;&gt; M = {{1,1,1},{1,0,0},{0,1,0}}; vector&lt;vector&lt;int&gt;&gt; ans = fastMatrixPow(M, n-2); //f(n) = ans[0][0] * f(2) + ans[0][1] * f(1) + ans[0][2] * f(0) return ans[0][0] + ans[0][1];} 如果结果最终过大还要采用long long类型和模数，用各种矩阵分解去整出复杂度的计算也不是不行，这还是交给数值计算科学库吧。 记忆化搜索、状态机DP和矩阵快速幂552.学生出勤记录可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： A：Absent，缺勤 L：Late，迟到 P：Present，到场 如果学生能 同时满足: 缺勤次数严格小于2 连续迟到小于3次 答案可能很大，所以返回对 109 + 7 取余 的结果。。 记忆化搜索：单纯爆搜的枚举深搜函数可以写成： 1234567891011121314151617/* *@param: u 当前剩余的决策位数 *@param: a_cnt 剩余可用的Absetn次数 *@param: l_cnt 当前结尾的Late连续次数 *@param: cur_str 当前的方案字符串 *@param: set 结果集*/int dfs(int u, int a_cnt, int l_cnt, string cur_str, vector&lt;string&gt;&amp; set) { if(a_cnt &gt;= 2) return 0; if(l_cnt &gt;= 3) return 0; if(u == 0) {set.push_back(cur_str);return 1;} int ans = 0; ans += dfs(u-1,a_cnt + 1, 0,cur_str.push_back('A'),set);cur_str.pop_back(); ans += dfs(u-1,a_cnt,l_cnt + 1,cur_str.push_back('L'),set);cur_str.pop_back(); ans += dfs(u-1,a_cnt,0,cur_str.push_back('P'),set);cur_str.pop_back(); return ans} 这样很容易超时，事实上很多字符串已经被记录过了，可以使用当前方案字符串缓存哈希表或者更好的状态数组直接记录结果，由于我们只需要知道最终的结果数目，所以也不需要当前方案的缓存和结果集，修改后的记忆化搜索代码如下所示： 1234567891011121314151617181920212223static constexpr MOD = 10000000007;int solution(int n) { vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache(n + 1, vector&lt;int&gt;(2,vector&lt;int&gt;(3,-1))); return dfs(n, 0, 0, cache);}/* *@param: u 当前剩余的决策位数 *@param: a_cnt 剩余可用的Absetn次数 *@param: l_cnt 当前结尾的Late连续次数 *@param: cache 当前搜索的历史记忆结果*/int dfs(int u, int a_cnt, int l_cnt, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; cache) { if(a_cnt &gt;= 2) return 0; if(l_cnt &gt;= 3) return 0; if(u == 0) {return 1;} if(cache[u][a_cnt][l_cnt] != -1) return cache[u][a_cnt][l_cnt]; int ans = 0; ans += dfs(u-1,a_cnt + 1, 0) % MOD; ans += dfs(u-1,a_cnt,l_cnt + 1) % MOD; ans += dfs(u-1,a_cnt,0) % MOD; cache[u][a_cnt][l_cnt] = ans; return ans} 状态机线性DP通过对记忆化搜索的分析，可以发现下一位的决策依赖于当前位的决策，我们给定一个三维的DP数组，第一维表示决定的位数，第二维表示当前的a_cnt，第三维表示末尾连续的l_cnt。那么表示前天有个以及结尾有个的情况。边界状态。 如果第天的出勤记录是，则结尾的会清零，于是： 如果第天的出勤记录是，则结尾的清零，同时要求前一天的为0： 如果第天的出勤记录是，则要求前一天的小于2： 对应C++形式： 12345678910111213141516171819202122232425262728class Solution {public: static constexpr int M = 1'000'000'007; int checkRecord(int n) { vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;long long&gt;&gt;(2, vector&lt;long long&gt;(3))); dp[0][0][0] = 1; for(int i = 1;i &lt;= n; ++i) { //以P结尾的出勤记录数量，结尾只有0 dp[i][0][0]=(dp[i][0][0] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2])%M; dp[i][1][0]=(dp[i][1][0] + dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2])%M; //以A结尾的出勤记录数量,结尾只有0 dp[i][1][0]=(dp[i][1][0] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2])%M; //以L结尾的出勤数量，因要求连续于是与k-1有关 dp[i][0][1]=(dp[i][0][1] + dp[i-1][0][0])%M; dp[i][0][2]=(dp[i][0][2] + dp[i-1][0][1])%M; dp[i][1][1]=(dp[i][1][1] + dp[i-1][1][0])%M; dp[i][1][2]=(dp[i][1][2] + dp[i-1][1][1])%M; } int ans = 0; for(int j = 0;j &lt; 2;j++) { for(int k = 0;k &lt; 3;++k) { ans = (ans + dp[n][j][k])%M; } } return ans; }}; 这里就不给出空间压缩的版本了，由于dp[i]仅仅与dp[i-1]有关，空间复杂度是可以压缩到的。 矩阵快速幂对线性DP的优化从上述的状态转移方程我们能够抽象出对应的离散状态转移矩阵，首先我们定义如下的状态，以idx作为状态编号，使用： 最终的答案是，将状态整理成列向量，再由前述状态转移方程对照（暂时去除模数)： 1234567891011121314 dp[i][0][0]+=dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2];//dp[n][0] = dp[n-1][0] + dp[n-1][1] + dp[n-1][2] dp[i][1][0]+=dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2];//dp[n][3] = dp[n-1][3] + dp[n-1][4] + dp[n-1][5] dp[i][1][0]+=dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2];//dp[n][3] = dp[n-1][0] + dp[n-1][1] + dp[n-1][2] dp[i][0][1]+=dp[i-1][0][0];//dp[n][1] = dp[n-1][0] dp[i][0][2]+=dp[i-1][0][1];//dp[n][2] = dp[n-1][1] dp[i][1][1]+=dp[i-1][1][0];//dp[n][4] = dp[n-1][3] dp[i][1][2]+=dp[i-1][1][1];//dp[n][5] = dp[n-1][4] 写出如下矩阵状态方程:再有初值条件,定义矩阵 可以获得如下的计算式：。套用我们在矩阵快速幂中的模板 ， 12345678910111213141516171819202122232425262728293031static constexpr int mod = 1'000'000'007;//矩阵快速幂vector&lt;vector&lt;int&gt;&gt; fastMatrixPow(vector&lt;vector&lt;int&gt;&gt; mat, int n) { vector&lt;vector&lt;int&gt;&gt; ans = { {1,0,0,0,0,0}, {0,1,0,0,0,0}, {0,0,1,0,0,0}, {0,0,0,1,0,0}, {0,0,0,0,1,0}, {0,0,0,0,0,1} }; while(n != 0) { if((n&amp;1) == 1) ans = multiply_mat(ans,mat); mat = multiply_mat(mat,mat); n = n &gt;&gt; 1; } return ans;}//基础知识点，如何安排循环顺序能够使得cache命中率更高提高矩阵乘法速度vector&lt;vector&lt;int&gt;&gt; multiply_mat(vector&lt;vector&lt;int&gt;&gt; x,vector&lt;vector&lt;int&gt;&gt; y) { int n = x.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n,0)); for(int i = 0;i &lt; n;++i) { for(int j = 0;j &lt; n;++j){ for(int k = 0;i &lt; n;++k) { ret[i][j] += x[i][k] * y[k][j]; } } } return ret;} 1220.统计元音字母给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串： 字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’） 每个元音 ‘a’ 后面都只能跟着 ‘e’ 每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’ 每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’ 每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’ 每个元音 ‘u’ 后面只能跟着 ‘a’ 由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 官方给出的n=2情况的示例，可以据此直接写出状态机： 12345/\"ua\"\"ea\"\"ia\"//\"ae\"\"ie\"/ /\"ei\"\"oi\"/ /\"io\"/ /\"iu\"\"ou\"/ 状态机线性DP有了前面一道题的铺垫，根据题目给出的示例，我们可以很容易看出这道题的状态转移方程：初始边界条件。那么代码就很清晰了： 1234567891011121314151617181920212223class Solution {private: static constexpr int MOD = 1'000'000'007; using ll = long long;public: int countVowelPermutation(int n) { vector&lt;ll&gt; dp0(5, 1); vector&lt;ll&gt; dp1(5, 0); for(int i = 2;i &lt;= n;++i) { dp1[0] = (dp0[1] + dp0[2] + dp0[4]) % MOD; dp1[1] = (dp0[0] + dp0[2]) % MOD; dp1[2] = (dp0[1] + dp0[3]) % MOD; dp1[3] = (dp0[2]) % MOD; dp1[4] = (dp0[2] + dp0[3]) % MOD; dp0 = dp1; } int ret = 0; for (int i = 0;i &lt; 5;++i) { ret = (ret + dp0[i]) % MOD; } return ret; }}; 矩阵快速幂对线性DP的优化根据的状态转移方程可以写出如下的状态转移矩阵： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using LL = long long;using Mat = vector&lt;vector&lt;LL&gt;&gt;;class Solution {public: Mat multiply(const Mat &amp; matrixA, const Mat &amp; matrixB, LL mod) { int m = matrixA.size(); int n = matrixB[0].size(); Mat res(m, vector&lt;LL&gt;(n, 0)); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { for (int k = 0; k &lt; matrixA[i].size(); ++k) { res[i][j] = (res[i][j] + matrixA[i][k] * matrixB[k][j]) % mod; } } } return res; } Mat fastPow(const Mat &amp; matrix, LL n, LL mod) { int m = matrix.size(); Mat res(m, vector&lt;LL&gt;(m, 0)); Mat curr = matrix; for (int i = 0; i &lt; m; ++i) { res[i][i] = 1; } for (int i = n; i != 0; i &gt;&gt;= 1) { if (i &amp; 1) { res = multiply(curr, res, mod); } curr = multiply(curr, curr, mod); } return res; } int countVowelPermutation(int n) { LL mod = 1e9 + 7; Mat factor = { {0, 1, 0, 0, 0}, {1, 0, 1, 0, 0}, {1, 1, 0, 1, 1}, {0, 0, 1, 0, 1}, {1, 0, 0, 0, 0} }; Mat res = fastPow(factor, n - 1, mod); long long ans = 0; for (int i = 0; i &lt; 5; ++i) { ans = (ans + accumulate(res[i].begin(), res[i].end(), 0LL)) % mod; } return ans; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"动态规划","slug":"动态规划","permalink":"https://kimanyang.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态机DP","slug":"状态机DP","permalink":"https://kimanyang.xyz/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://kimanyang.xyz/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"Stability Theorems for Non-autonomous Systems","slug":"Stability Theorems for Non-autonomous Systems","date":"2022-01-01T03:29:01.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/01/01/Stability Theorems for Non-autonomous Systems/","link":"","permalink":"https://kimanyang.xyz/2022/01/01/Stability%20Theorems%20for%20Non-autonomous%20Systems/","excerpt":"","text":"Stability Theorems for Non-autonomous SystemsComparison FunctionsDefinition of class functionsA continuous function is said to belong to class if it is strictly increasing and . It is of class if and as Definition of class functionsA continuous function is said to belong to class if, for each fixed , the mapping belong to class with respect to and, for each fixed , the mapping is decreasing with respect to and as . examples: , class but not class , class , class , class , , class . Lemma(Properties)Let on and and denotes the inverse of : is defined on and belongs to is defined on and belongs to class belongs to class belongs to class belongs to class LemmaLet be a continuous positive definite function defined on a domain that contains the origin. Let for some . Then there exist defined on such that:If , and are defined on . Moreover, if is radially unbounded, then . example:Consider a quadratic positive definite function:We know that:and so we can define and . Non-autonomous Systems is piecewise continuous in and locally Lipschitz in for all and all . The origin is an equilibrium point at if Definition:The equilibrium point of the non-autonomous system is: Stable: If such that stands Uniformly Stable: stable and is independent of Asymptotically Stable: stable and such that as , Uniformly Asymptotically Stable: if is independent of and the convergence is uniformly in , that is: Globally Uniformly Asymptotically Stable: if can be chosen to satisfies and : It’s easier to define uniform stability and uniform asymptotic stability using comparison functions: is uniformly stable if there exists a class- function and a constant such thatfor all and for every initial condition such that uniformly asymptotically stable: if there exists a class such that:for all and for every initial condition such that globally uniformly asymptotically table: if uniformly exponentially stable: if for some :for all and for every initial condition such that . example:Consider a nonlinear system:Its solution is:Missing or unrecognized delimiter for \\left \\begin{aligned} x(t) &amp;= x(t_0)exp\\left{\\int_{t_0}^t(6\\tau\\sin\\tau-2\\tau)d\\tau \\right}\\\\ &amp;=x(t_0)exp\\left{6\\sin t-6t\\cos t-t^2-6\\sin t_0+6t_0\\cos t_0-t_0^2 \\right} \\end{aligned} \\notag Note We have:Missing or unrecognized delimiter for \\left \\Vert x(t)\\Vert\\le\\Vert x(t_0)\\Vert\\cdot \\exp\\left{ 15-6\\sin t_0+6t_0\\cos t_0-t_0^2 \\right}\\triangleq c(t_0)\\cdot\\Vert x(t_0)\\Vert \\notag For any , choose . Then we obtain:which implies that the origin is stable. We study the sensitivity of the system solutions due to the changes in . Let . We examine at .Missing or unrecognized delimiter for \\left \\begin{aligned} x(t_0+\\pi)=x(t_0)\\exp\\left{(4k+1)(6-\\pi)\\pi \\right} \\end{aligned} \\notag Thus we have:Missing or unrecognized delimiter for \\left \\frac{x(t_0+\\pi)}{x(t_0)}=\\exp\\left{(4k+1)(6-\\pi)\\pi \\right}\\to\\infty,as\\ k\\to\\infty \\notag Therefore, given any , there is no independent of that could satisfy the uniform stability definition. example:consider the following system, defined for :Its solution is . Because the origin is uniformly stable with . The origin is also asymptotically stable, but not uniformly asymptotically stable, because the convergence rate depends on . Time-Dependent Positive Definite FunctionsDefinition: is said to be positive semidefinite if is said to be positive definite if , for some positive definite function . is said to be decrescent if , for some positive definite function . is radially unbounded if as examples:Let . Find . Find and . Find and TheoremLyapunov Stability for Non-autonomous SystemLet the origin be an equilibrium point of and be a domain containing . Suppose is piecewise continuous in and locally Lipschitz in for all and . Let be a continuously differentiable function such that:for all and , where and are continuous positive definite functions on . Then, the origin is uniformly stable. Further theoremSuppose the assumptions of the previous theorem are satisfied with:for all and , where is a continuous positive definite function on . Then, the origin is uniformly asymptotically stable. Moreover, if and are chosen such that and , then every trajectory starting in satisfiesfor some class function . Finally, if and is radially unbounded, then the origin is globally uniformly asymptotically stable. example:Consider the following nonlinear system:We consider the following Lyapunov function candidate(“你们别问我这是怎么来的，反正就这样”——梅老师原话)：Since:Hence, is positive definite, decrescent, and radially unbounded. The derivative of along the system trajectories is given by:Hence the origin is globally uniformly asymptotically stable (exponentially stable) Linear Time-Varying Systems the solution can be represented as: TheoremThe equilibrium point of the linear system is globally uniformly asymptotically stable (GUAS) if and only if:for some positive constants and . Remark that: for linear systems GUASExponential stability for linear time-varying system, GUAS cannot be characterized by the location of the eigenvalues of . example: For each , . Yet the origin is unstable. is given by: Corollary:The system is uniformly asymptotically stable if there exists such that:Proof: Let , then: Corollary:Assume that there exists which is continuously differentiable and symmetric, and there exist such that:Further assume for some , continuous and symmetric such that:Then the system is globally uniformly asymptotically stable. Proof: Let is positive definite and decrescent. And : Corollary:Assume that at any time , the eigenvalues of all have negative real parts. In addition, if is bounded, and , then is globally uniformly asymptotically stable. Barbalat’s Lemma(very important)How about the asymptotically stability when is only negative semi-definite? For autonomous system, LaSalle’s invariance theorem can be used. But it is not valid for non-autonomous systems. Barbalat’s Lemma is a purely mathematical result concerning the asymptotically properties of functions and their derivatives. an example: can convergence of ? Definition: Uniform Continuity(一致连续)A function is said to be uniformly continuous if: Lemma(Barbalat):If the differentiable function: has a finite limit as . is uniformly continuous. ( is bounded) Then . Note: A sufficient condition for a differentiable function to be uniformly continuous is that its derivative be bounded. Lemma(“Lyapunov-Like”):If a scalar function satisfies the following conditions: is lower bounded is negative semidefinite () is uniformly continuous ( is bounded) then . example:In adaptive control, we will often encounter the following non-autonomous system:where is a bounded continuous function, and are two states of the closed-loop system, representing the tracking error and parameter error. Consider the quadratic scalar function:Its derivative:is negative semi-definite. Check . Note that , which implies that . Therefore and are bounded. With being bounded, we can conclude that is also bounded. From Barbalat’s Lemma, we can conclude that , that is, . Theorem(La Salle-Yoshizawa):Let be an equilibrium point of and suppose that is locally Lipschitz in and uniformly in . Let be a continuously differentiable function such that:, where and are class $\\mathcal{K}\\inftyW(x)$ is a continuous function. Then all solutions of satisfy:$$\\lim\\limits{t\\to\\infty}W(x(t))=0\\notag$$In addition, if is positive definite, is globally uniformly asymptotically stable. Proof: (Revisit if has a finite limit, uniformly continuous, then so if has a finite limit, is uniformly continuous, then ) Note, , so is monotonous non-decreasing. From we know and thus:so monotonous non-decreasing function has upper bound, thus it has a finite limit. Since and is bounded, is bounded. Assume that . Note that a continuous function is uniformly continuous on a closed set. is uniformly continuous in . For all , we have:Then is uniformly continuous in , and thus is also uniformly continuous in . From Barbalat’s Lemma, . Theorem( norm)For function of time, the norm is given by:for , while:We say that when . Corollary 0.1If and $\\dot{x}\\in\\mathbb{L}\\infty\\lim\\limits{t\\to\\infty}x(t)=0$. Proof: Define:Since , we can get has a finite limit as . Furthermore:From the fact that $x,\\dot{x}\\in\\mathbb{L}\\infty\\ddot{f}(t)\\in\\mathbb{L}\\infty\\dot{f}\\lim\\limits{t\\to\\infty}\\dot{f}(t)=0\\lim\\limits{t\\to\\infty}x(t)=0$. Boundedness and Ultimate BoundednessThe concept of stability in the sense of Lyapunov are formulated with respect to an equilibrium point. Often, systems are designed to operate in the presence of disturbances and other uncertainties. Until now we have used Lyapunov theory to study the behavior of the system about the equilibrium point. What happens when the system does not have any equilibrium point ? We will see that Lyapunov analysis can be used to show boundedness of the solution of the state equation. example: Its solution is given by:The solution satisfies:which shows that the solution is uniformly bounded. Further, for any number , it can be easily seen that:The bound , which again is independent of , gives a better estimate of the solution after a transient period has passed. In this case, the solution is said to be uniformly ultimately bounded and is called the ultimate bound. This can be also done via Lyapunov analysis without the explicit solution of th state equation. /Todo Here/ DefinitionThe solution of are Uniformly Bounded (UB): if there exists a , independent of such that: Globally Uniformly Bounded (GUB): if can be arbitrarily large Uniformly Ultimately Bounded (UUB): with ultimate bound , if there exists (independent of ) such that: Globally Uniformly Ultimately Bounded (GUUB): if can be arbitrarily large. Remark: For a Lyapunov function candidate , if we have such that: Input-to-state StabilityFor a linear time-variant system with Hurwitz. The solution is given by:Using the bound:we conclude that:And it is GUAS. This doesn’t hold for a general nonlinear system example when , the equilibrium point is GAS. Yet, when and , the solution is given by:which is unbounded. It even has a finite escape time. Definition of Input to State Stability(ISS)The system is is said to be input-to-state stable if there exist and such that for any initial state and any bounded input , the solution exists for all and satisties: Remarks: For any bounded input , the state will be bounded As increases, the state will be ultimately bounded by a class function of If as then as Since for of the unforced system is GUAS. TheoremLet be a function such that:. and . Then the system is ISS with . LemmaSuppose that is and globally Lipschitz in , uniformly in . If the unforced system has a globally exponentially stable equilibrium point at , then the system is ISS. Cascade System","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"非自治系统","slug":"非自治系统","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"Stability of Autonomous System","slug":"Stability of autonomous system","date":"2021-12-25T08:23:01.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2021/12/25/Stability of autonomous system/","link":"","permalink":"https://kimanyang.xyz/2021/12/25/Stability%20of%20autonomous%20system/","excerpt":"","text":"Stability of Autonomous SystemConsider the autonomous system:along is locally Lipschitz map from . Assume that , i.e. , is an equilibrium point. Definition:The equilibrium point of (1) is stable: if, for each there is , such that unstable: if it is not stable asymptotically stable: if it is stable and can be chosen such that: . exponentially stable: if there exists two real constants such that . exponentially asymptotically. Note that does not necessarily imply stability: one can construct an example where trajectories converge to the origin, but only after a large detour that violates the stability definition. Stability of autonomous system.assets\\homoclinic_orbit.PNG) Exanple: Consider exponentially converge to with a rate . In fact . Example: and . Its solution is which is asymptotically stable but not exponentially stable. marginally stable: if is stable but not asymptotically stable. globally asymptotically/exponentially stable: if it holds for all initial states. Positive Definite Functions–”Energy-Like” FunctionsDefinition: A function is said to be: positive definite if and positive semidefinite if and negative definite(resp. negative semi definite) if is positive definite(resp. definite semi positive). Example: The simplest and perhaps the most important class of positive definite functions is a quadratic form:V is PD , Q is PD V is PSD , Q is PSD Example: Let is PD when and PSD when . Example: Consider the pendulum system with state equations: Define . State space: . one can compute the following energy function(kinetic and potential energy):The derivative of with respect to is:Canveats: Positive definite function can be seen as an abstraction of the total “energy” stored in the system All the Lyapunov stability theorems focus on the study of the time derivative of a positive definite function along the trajectories of the system. Stability Theorems for Autonomous SystemsTheorem: Lyapunov’s stability theoremLet be an equilibrium point for and be a domain containing . Let be a continuously differentiable function such that: which means is positive definite which means is negative semidefinite Then is stable. Moreover, if which meas is negative definite then is asymptotically stable. Example:Consider the pendulum example without friction:Assume the following energy function:Clearly and .Thus the origin is stable. Since we can also conclude that the origin is not asymptotically stable. Next we consider the pendulum example with friction:Consider:Then which is negative semidefinite. We can only conclude that the origin is stable. But actually the system is asymptotically stable. The chosen Lyapunov function candidate fails to show this fact. Replace the term by the more general quadratic form for some positive definite matrix . We define:where and . The time derivative along the system is:$$\\begin{aligned}\\dot{V}(x)&amp;=\\frac{1}{2}\\begin{bmatrix}\\dot{x}1 \\ \\dot{x}2\\end{bmatrix}+a\\sin x_1\\cdot x_2 \\&amp;=\\begin{bmatrix}p{11} &amp; p{12} \\ p_{12} &amp; p_{22} \\end{bmatrix}+a\\sin x_1\\cdot x_2 \\&amp;=p_{11}\\cdot x_1x_2-p_{12}x_1(a\\sin x_1+bx_2)+p_{12}x_2^2-p_{22}x_2[a\\sin x_1+bx_2]+a\\sin x_1\\cdot x_2 \\&amp;=(p_{11}-p_{12}b)x_1x_2-p_{12}a\\cdot x_1\\sin x_1-(p_{22}b-p_{12})x_2^2+(1-p_{22})a\\sin x_1\\cdot x_2\\end{aligned}\\notag\\dot{V}=-\\frac{ab}{2}x_1\\cdot\\sin x_1-\\frac{b}{2}x_2^2\\le0$$when , the system is negative definite. Thus we can conclude that the origin is asymptotically stable. This example emphasizes an important feature: the Lyapunov theorem;s conditions are only sufficient Example:Let’s study the following nonlinear system:with the equilibrium point at the origin. Consider the following positive definite function:Its derivative along the system is: is negative definite over the ball . Therefore, the origin is locally asymptotically stable. Theorem-Globally Asymptotically Stable(GAS)Let be an equilibrium point for . Let be a continuously differentiable function such that: and ( PD) (radially unbounded,径向无界) (ND) Then is globally asymptotically stable(GAS) Example: is radically unbounded and is not radically unbounded Global Asymptotic stability:Consider . Stability of autonomous system.assets/gloablStability.PNG) Caveat: The reason for radial boundedness condition is to assure that the contour curves correspond to closed curves. If the curves are not closed, it is possible for state trajectories to drift away from the equilibrium point, even though the state keeps going through contours corresponding to smaller and smaller ’s. The Invariance Principle(不变集原理)Definition:A set is an invariant set with respect to ifA set is a positively invariant set with respect to if: approaches a set as if (有限时间内距离小于任意正值)where . (边界严格定义) Example: Equilibrium Points are invariant set. the whole space with . limit cycle (极限环) A trajectory of a system is called close if it is not a constant but returns to its starting point, i.e., there exists some such that . An isolated closed orbit is called a limit cycle. There are three types of limit cycles: Stable Limit Cycle: all trajectories in vicinity(邻域) of the limit cycle converge to it as ; Unstable Limit Cycle: all trajectories in vicinity of the limit cycle diverge to it as ; Semi-stable Limit Cycle: some trajectories in vicinity of the limit cycle converge to it, while others diverge from it as . Theorem-La Salle’s TheoremLet be a compact positively invariant set. be a continuously differentiable function such that in . . be the largest invariant set in . ( and can stand identically in itself,) Then every solution starting in approaches as . Example: Consider the pendulum example without friction:Differentiable function with We chose , thus and . Consider the pendulum example with friction:Differentiable function . We chose , . Thus Remark: Besides often yielding conclusions on asymptotic stability when is only negative semi-definite, the invariant set theorem also allow us to extend the concept of Lyapunov function so as to describe convergence to dynamic behaviors more general than equilibrium, e.g., convergence to a limit cycle. When is the origin ? Corollary 4.1Let be an equilibrium point of . Let be a positive definite function containing the origin such that in . Let and suppose that no solution can stay identically in , other than the trivial solution . Then, origin is asymptotically stable. Corollary 4.2Let be an equilibrium point of . Let be a , radically unbounded, positive definite function such that for all . Let and suppose that no solution can stay identically in , other than the trivial solution . Then is GAS. ExamplesExample: Still consider pendulum example with friction, chose . From , use corollary 4.1 can prove the asymptotically stable of the origin. Example: Consider the following first-order system:together with the adaptive control lawTaking , we can obtain:The line is an equilibrium set. We want to show that the trajectories approach this equilibrium set as , which means the adaptive controller regulates . Consider the following Lyapunov function candidate:where is a constant. The derivative of along the trajectories is given by:Step 1 : Define the set , which is an invariant set. Step 2: The set Step 3: The largest invariant set . From La Salle’s Theorem, we can conclude that . Moreover, since is radially unbounded, the conclusion is global. Example: Consider the following nonlinear system:The origin is an equilibrium point. Also, the set of points defined by the circle continue an invariant set. Solution 1: Assume that . We have:Solution 2: We now investigate the stability of the limit cycle using La Salle’s Theorem. To this end, consider the following function (not PD function):which represents a measure of the “distance” to the limit cycle. Then we have:Step 1: Chose Step 2: Find Clearlay . Step 3: Find , the largest invariant set in . . Thus choosing such that . includes the limit cycle but not the origin. The application of La Salle’s theorem with shows that every motion starting in converges to the limit cycle, and therefore the limit cycle is stable. Assume . satisfies will converges to the limit cycle, thus the origin is unstable. Linear Systems and LinearizationConsider the time-invariant linear system: Caveats: Some reasons for investigating stability of LTI systems via Lyapunov method: The Lyapunov analysis permits studying linear and nonlinear systems under the same framework, where LTI is a special case. We will introduce a very useful class of Lyapunov functions that appears frequently in the literature. We will study the stability of nonlinear systems via linearization of the state equation and try to get some insights into the limitations associated with this process. Consider a quadratic Lyapunov function candidate:where is positive definite. The derivative along LTI system:where is a symmetric matrix defined by called (Lyapunov equation). Lypunov TheoremA matrix is Hurwitz, that is, for all eigenvalues of , if and only if, for any given there exists a that satisfies the Lyapunov equation:Moreover, if is Hurwitz, then is the unique solution (9). When it comes to nonlinear system , we using linearization. We have:where is Jacobian matrix:$$A=\\frac{\\partial f(x)}{\\partial x}\\bigg|{x=0}=\\bigg|{x=0}$$and as . Consider the following Lyapunov function candidate:The derivative of along the trajectories is given by:Since is Hurwitz, . Regarding the other term, note that:Therefore such that . Hence :When Note that:It follows that:Choosing such that , is negative definite. Therefore is locally asymptotically stable. Theorem-Lyapunov’s indirect methodLet be an equilibrium point for the nonlinear system where is and is a neighborhood of the origin. Let Then, The origin is asymptotically stable if for all eigenvalues of The origin is unstable if for one ore more eigenvalues of We have no conclusion for some in nonlinear system. Example:It has two equilibrium points: and .","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"自治系统","slug":"自治系统","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"Nonlinear and Adaptive Control of Robotic Manipulators","slug":"Nonlinear and Adaptive Control of Robotic Manipulators","date":"2021-12-23T05:35:41.000Z","updated":"2022-03-27T11:27:20.379Z","comments":true,"path":"2021/12/23/Nonlinear and Adaptive Control of Robotic Manipulators/","link":"","permalink":"https://kimanyang.xyz/2021/12/23/Nonlinear%20and%20Adaptive%20Control%20of%20Robotic%20Manipulators/","excerpt":"","text":"Nonlinear and Adaptive Control of Robotic ManipulatorsThe dynamic equations of a robot manipulator in closed form are always written in the form of Euler-Lagrange equation. A dynamic system with degree of freedom can be described by the EL equation aswhere is the vector of generalized coordinates, is the symmetric positive definite inertia matrix, is the vector of Coriolis and centrifugal forces, is the vector of gravitational force, and is the vector of control force. And it has the following properties: Properties: is positive definite and ; . is skew symmetric where is the regressor and is an unknown but constant vector. 1. Position ControlControl Objective: , . Define the errors: , . The error dynamics:Define , , such that we obtain the following autonomous system:Design the following control input:where and are positive definite matrices. Then the closed-loop system is:Consider the following Lyapunov function candidate:Its derivative isSince is skew symmetric . And we haveTill now, we can consider the following Lyapunov function candidate:Its derivative is:which is negative semidefinite. Note the closed-loop system is autonomous, we can use LaSalle’s Theorem. Define . Let be a solution that belongs identically to . $x_2\\equiv0\\implies\\dot{x}2\\equiv0\\implies x_1\\equiv0E\\lim \\limits{t\\rightarrow\\infty}\\tilde{q}(t)=0,\\lim \\limits_{t\\rightarrow\\infty}\\dot{\\tilde{q}}(t)=0$. With Damping: in which is positive semidefinite, the control law can still work. Definition of Potential: if then the Lyapunov function is and and we can design some control law.(Final exam question) 2. Tracking ControlControl Objective: , , , and are bounded. Define the tracking errors: and . The error dynamics:Design the following control input(the inner of and are non-autonomous)Then the closed-loop system is:Then the closed-loop system is:Consider the following Lyapunov function candidateIts derivative along (13) is :Since our system is non-autonomous, LaSalle’s Theorem can not be used. From (15), , which implies that . Note that:Since and is bounded, we can get from (13) that $\\ddot{\\tilde {q}}(t)\\in\\mathcal{L}\\infty\\ddot{V}\\in\\mathcal{L}\\infty\\lim \\limits{t\\rightarrow 0}\\dot{V}(t)=0\\lim \\limits{t\\rightarrow\\infty}\\dot{\\tilde{q}}(t)=0$. Unfortunately, from the study sketched above, it is not possible to derive any immediate conclusion about the asymptotic behavior of the position error . 3. Sliding Mode Control (for tracking control)Define a sliding surface:and an auxiliary variable:Then we have:So we define the following control input:$$\\tau=g(q)+M(q)\\ddot{q}_r+C(q,\\dot{q})\\dot{q}r-KsM(q)\\dot{s}+C(q,\\dot{q})s=-KsV=\\frac{1}{2}s^TMs$$which is negative definite. Therefore the origin is exponentially stable, i.e., $\\lim \\limits{t\\rightarrow\\infty}s(t)=0s=\\dot{\\tilde{q}}(t)+\\lambda\\tilde{q}(t)$ we know that the system is input-to-state stable(ISS). final exam question Design controller . Then we have . 4. Adaptive Control （&amp;Robust)When there exist parametric uncertainties, sliding mode control law can not be implemented directly. Note that:Since is unknown, we propose the following control input:Thus using (26) for (19):Consider the following Lyapunov function candidate:Its derivative along (27) is:Design we have wich negative semidefinite. Robust Adaptive Control: 5. Backstepping Control for Robotic Manipulators(不考)Consider the following system for a robotic manipulator:where and represent respectively, the vector of link positions and motor angles, is the positive diagonal matrix representing the joint stiffness, and is the positive diagonal matrix representing the actuator inertia. Define and . The above dynamics can be described as:","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"自适应控制","slug":"自适应控制","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/"},{"name":"控制系统设计","slug":"控制系统设计","permalink":"https://kimanyang.xyz/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"机械臂","slug":"机械臂","permalink":"https://kimanyang.xyz/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"}]},{"title":"Adaptive Control","slug":"Adaptive Control","date":"2021-12-17T14:12:23.000Z","updated":"2022-03-27T11:27:20.069Z","comments":true,"path":"2021/12/17/Adaptive Control/","link":"","permalink":"https://kimanyang.xyz/2021/12/17/Adaptive%20Control/","excerpt":"","text":"Adaptive ControlBasic Steps Characterize the desired behavior of the closed-loop systems Determine a suitable control law containing adjustable parameters find a mechanism(an adaptation law) for adjusting those parameters Analyze the convergence properties and implement the control law Some approachesGain SchedulingSelf-Tuning Controller(STC) Combines a controller with an on-line plant parameter estimator Performs simultaneous (实时) parameters identification and control Uses Certainty Equivalence Principle: controller parameters are computed from the estimates of the plant parameters as if they were the true ones Model Reference Adaptive Control(MRAC) Plan: containing unknown parameters and having a known structure Reference model: specifying the desired output of the control system Feedback control law: containing adjustable parameters Adaptation mechanism: updating the adjustable parameters Indirect and Direct Adaptive ControlIndirected Adaptive Control:The process model and possible the disturbance characteristics are first determined. The controller parameters are designed on the basis of this information. Directed Adaptive Control:The controller parameters are changed directly without the characteristics of the process and its disturbances first being determined *Some Examples of Adaptive ControlConsider the following first-order scalar system:where is an unknown parameter, is the state and is the control input. Control Object: Design , such that all signals in the closed-loop system are bounded and tracks the state of the following reference model given by:$$\\dot{x}{ref}=-a{ref}x_{ref}+b_{ref}u_c$$where (Input-to-State Stable) and are unknown parameters, and is the reference input command which is bounded and piecewise continuous. We proposed the control law:$$u^*=k_1^x+k_2^u_c\\dot{x}=(a+k_1^*)x+k_2^u_c$$If $a+k_1^=-a_{ref}k_2^*=b_{ref}e=x-x_{ref}ak_1^*$ Direct Adaptive Control: what is like ? Indirect Adaptive Control: we got , what is like? Direct MRAC Design for Scalar SystemConsidering system: where and are unknown parameters but the sign of is known. Construct the same reference model given by(2), we have:$$\\begin{aligned}\\dot{x} &amp;= ax+b(k_1^x+k_2^u_c) \\&amp;=(a+bk_1^*)x+k_2^u_c\\end{aligned}k_1^=\\frac{-a-a_{ref}}{b},k_2^*=\\frac{b_{ref}}{b}u=\\hat{k_1}(t)x+\\hat{k_2}(t)u_c(t)$$there $\\hat{k}1\\hat{k}2k_1^*k_2^*$\\dot{x}=(a+b\\hat{k}1(t))x+\\hat{k}2(t)u_c(t)\\begin{aligned}\\dot{x} &amp;= (a+b\\hat{k}1(t))x+\\hat{k}2(t)u_c(t)-a{ref}x + b{ref}u_c+a{ref}x-b{ref} \\&amp;=-a{ref}x + b{ref}u_c+(a_{ref}+a+b\\hat{k}1)x + (b\\hat{k}2-b{ref})u_c \\&amp;=-a{ref}x+b_{ref}u_c+b(\\hat{k}1-k_1^*)x+b(\\hat{k}2-k_2^*)u_c \\&amp;=-a{ref}x+b{ref}u_c+b\\tilde{k}_1(t)x+b\\tilde{k}_2(t)u_c\\end{aligned}$$where and . Define the tracking error:Then from (14) and (2), the error dynamics is:$$\\dot{e}=\\dot{x}-\\dot{x}{ref}=-a{ref}e+b\\tilde{k}_1(t)x+b\\tilde{k}_2(t)u_cV=\\frac{1}{2}e^2+\\frac{\\vert b\\vert}{2\\gamma_1}\\tilde{k}_1^2+\\frac{\\vert b\\vert}{2\\gamma_2}\\tilde{k}_2^2\\begin{aligned}\\dot{V} &amp;= e\\dot{e}+\\tilde{k}_1\\dot{\\tilde{k}}_1|b|/\\gamma_1+\\tilde{k}_2\\dot{\\tilde{k}}2|b|/\\gamma_2 \\&amp;=-a{ref}e^2+\\frac{|b|}{\\gamma_1}\\tilde{k}_1(\\dot{\\hat{k}}_1+\\gamma_1\\cdot sgn(b)xe)+\\frac{|b|}{\\gamma_2}\\tilde{k}_2(\\dot{\\hat{k}}_2+\\gamma_2\\cdot sgn(b)u_ce)\\end{aligned}\\dot{\\hat{k}_1}=-\\gamma_1\\cdot sgn(b)xe\\ \\dot{\\hat{k}2}=-\\gamma_2\\cdot sgn(b)u_ce\\dot{V}=-a{ref}e^2\\le0 \\notag$$Thus . From(31), $e,\\tilde{k}_1,\\tilde{k}2x\\dot{e}\\ddot{V}\\lim \\limits{t\\rightarrow \\infty}e(t)=0$. summary Find a controller structure(based on known parameters) Derive the error dynamics Design a suitable Lyapunov function Derive parameter updating laws such that Direct MRAC Design for Scalar SystemConsider the following first-order scalar system:where with begin a bounded and continuous known function, and are unknown parameters but the sign of is known. The reference model is still given by$$\\dot{x}{ref}=-a{ref}x_{ref}+b_{ref}u_cu(t)=\\hat{k}1(t)x+\\hat{k}2(t)u_c(t)-\\phi(x)\\hat{\\theta}(t)\\begin{aligned}\\dot{x} &amp;= -a{ref}x+b{ref}u_c+b\\tilde{k}1(t)x+b\\tilde{k}2(t)u_c-b(\\hat{\\theta}-\\theta)\\phi(x) \\&amp;= -a{ref}x+b{ref}u_c+b\\tilde{k}_1(t)x+b\\tilde{k}_2(t)u_c-b\\tilde{\\theta}\\phi(x) \\\\end{aligned}$$where , and . Then the error dynamics isConsider the following Lyapunov function candidate:$$V=\\frac{1}{2}e^2+\\frac{|b|}{2\\gamma_1}\\tilde{k}_1^2+\\frac{|b|}{2\\gamma_2}\\tilde{k}2^2+\\frac{|b|}{2\\gamma_3}\\tilde{\\theta}^2\\dot{V}=-a{ref}e^2+\\frac{|b|}{\\gamma_1}\\tilde{k}_1(\\dot{\\hat{k}}_1+\\gamma_1\\cdot sgn(b)xe)+\\frac{|b|}{\\gamma_2}\\tilde{k}_2(\\dot{\\hat{k}}_2+\\gamma_2\\cdot sgn(b)u_ce)\\+\\frac{|b|}{\\gamma_3}\\tilde{\\theta}(\\dot{\\hat{\\theta}}-\\gamma_3\\cdot sgn(b)\\phi(x)e)$$Tips(important）: Consider a system different from(43) like are unknown. We should transfer the system into the following form:Then the previous MRAC method design with nonlinear term can be applied to this problem. Indirect MRAC Design for Scalar SystemIn directed adaptive control, $\\hat{k}1(t)\\hat{k}2(t)\\hat{k}1(t)\\hat{k}2(t)\\hat{a}(t)\\hat{b}(t)a,b$\\hat{k}1(t)=\\frac{-\\hat{a}-a{ref}}{\\hat{b}} \\\\hat{k}2(t)=\\frac{b{ref}}{\\hat{b}}u=\\hat{k_1}(t)x+\\hat{k_2}(t)u_c(t)=\\frac{1}{\\hat{b}}[-(\\hat{a}+a{ref})x+b{ref}u_c]\\begin{aligned} \\dot{x} &amp;= (a-\\hat{a}+\\hat{a})x+(b-\\hat{b}+\\hat{b})u \\ &amp;=-(\\hat{a}-a)x-(\\hat{b}-b)u+\\hat{a}x+\\hat{b}u \\ &amp;= -(\\hat{a}-a)x-(\\hat{b}-b)u+\\hat{a}x+\\hat{b}u \\ &amp;= -a{ref}x+b{ref}u_c-\\tilde{a}x-\\tilde{b}u\\end{aligned}$$where ,. Then the error dynamics can be written as:Consider the following Lyapunov function candidate:The time derivative of along is given by:In order to yield , we choose:Then , which implies that , are all bounded. In order to claim the boundedness of , we need to modify the adaptation law(61) and prevent from going through zero. Such a modification can be achieved using the following a prior knowedge:Assumption: The and a lower bound for are known. Let us consider the following modification of in (61)$$\\dot{\\hat{b}}=\\left{\\right.$$The main motivation here is to stop adaptation of if the parameter reaches its lower absolute limit value with a nonzero time derivative. We need to argue that the modification(62) does indeed prevent from going through zero and at the same time, it preserves . For this to be true, it is sufficient to show that:We check when and . Notice that . Overall, we can get that under the modification(62), inequality (63) holds, thus the following inequality holds:And thus are bounded. Since are bounded, are all bounded. From LaSalle Yoshizawa Theorem . Remark: Another Proof Integrating both sides of (64) yields:Furthermore, from the above analysis we have . From Barbalat’s Lemma we have the same conclusion. Direct MRAC Design for MIMO SystemsIn this section, we will extend applicability of the MRAC design from scalar dynamics to multi-input multi-output nonlinear systems in the form:where is the system state, is the control input, and is the known control matrix, while and are unknown constant matrices. In addition, it is assumed that is diagonal, its elements are strictly positive and the pair is controllable. The uncertainty in is introduced to model control failures or modeling errors, in the sense that there may exist uncertain control gains or the designer may have incorrectly estimated the system control effectiveness. Control Objective: Design such that all signals in the closed-loop system are bounded and tracks the state of the following reference model given by:$$\\dot{x}{ref}=-A{ref}x_{ref}+B_{ref}u_c$$where is Hurwitz, and is the external bounded command vector. If the matrices and were known, we can apply the control law:$$u = K_1^x+K_2^u_c\\dot{x}=(A+B\\Lambda K_1^*)x+B\\Lambda K_2^u_c$$In general, there is no guarantee that the ideal gain $K_1^K_2^*ABA_{ref}B_{ref}K_1^*K_2^*$u=\\hat{K}1(t)x+\\hat{K}2(t)u_c\\begin{aligned}\\dot{x} &amp;= A{ref}x+B{ref}u_c-A_{ref}x-B_{ref} + Ax B\\Lambda \\hat{K}1(t)x+B\\Lambda \\hat{K}2(t)u_c \\&amp;=A{ref}x+B{ref}u_c +(A+B\\Lambda\\hat{K}1(t)-A{ref})x +(B\\Lambda \\hat{K}2(t)-B{ref})u_c \\&amp;=A_{ref}x+B_{ref}u_c+B\\Lambda \\tilde{K}_1(t)x + B\\Lambda \\tilde{K}_2(t)u_c \\\\end{aligned}$$where and $\\tilde{K}2:=\\hat{K}2-K_2^*e := x-x{ref}e$\\dot{e}=A{ref}e+B\\Lambda \\tilde{K}_1(t)x+B\\Lambda\\tilde{K}_2(t)u_cV=\\frac{1}{2}e^2+\\frac{1}{2}\\tr\\left{\\tilde{K}_1^T\\tilde{K}_1\\right}+\\frac{1}{2}\\tr\\left {\\tilde{K}_2^T\\tilde{K}_2\\right}$$*Use sum of every column vector’s inner product makes sense here, still this Lyapunov candidate can not lead to asymptotically stable. Since is Hurwitz, we can get from Lyapunov’s Theorem that for any positive definite there exists a unique positive definite such that:We then consider the following Lyapunov function candidate:Missing or unrecognized delimiter for \\left V=e^TPe +\\tr\\left{\\tilde{K}^T_1\\Lambda\\tilde{K}_1 \\right} +\\tr\\left{\\tilde{K}^T_2\\Lambda\\tilde{K}_2 \\right} Its derivative along (73) can be written as:$$\\begin{aligned}\\dot{V} =&amp; \\dot{e}^TPe+e^TP\\dot{e}+2\\tr\\left{\\tilde{K}^T_1\\Lambda\\dot{\\hat{K}}1 \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda\\dot{\\hat{K}}2 \\right} \\=&amp;(A{ref}e)^TPe+e^TP(A{ref}e)+2e^TPB\\Lambda\\tilde{K}_1x+\\cdots \\&amp;+2e^TPB\\Lambda\\tilde{K}_2u_c+2\\tr\\left{\\tilde{K}^T_1\\Lambda\\dot{\\hat{K}}_1 \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda\\dot{\\hat{K}}_2 \\right} \\=&amp;-e^TQe+2\\tr\\left{\\tilde{K}^T_1\\Lambda B^TPex^T \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda B^TPeu_c^T\\right} +\\cdots\\&amp;+2\\tr\\left{\\tilde{K}^T_1\\Lambda\\dot{\\hat{K}}_1 \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda\\dot{\\hat{K}}_2 \\right} \\\\end{aligned}\\dot{\\hat{K}}_1=-B^TPex^T,\\ \\dot{\\hat{K}}_2=-B^TPeu_c^T$$Then we have . Thus , which implies that $e,\\tilde{K}1,\\tilde{K}2A{ref}u_cx{ref}x\\dot{e}\\ddot{V}=-2e^TQ\\dot{e}\\lim \\limits_{t\\rightarrow \\infty}\\dot{V}(t)=0\\lim \\limits_{t\\rightarrow\\infty}e(t)=0$. Final Exam Question: Q1: with all negative elements? Missing or unrecognized delimiter for \\left\\tr\\left{\\tilde{K}^T_2(-\\Lambda)\\dot{\\hat{K}}_2 \\right} ​ with some negative elements? Missing or unrecognized delimiter for \\left\\tr\\left{\\tilde{K}^T_2|\\Lambda|\\dot{\\hat{K}}_2 \\right} Q2: Consider the following question with nonlinear term:where is unknown and . The controller can be: Nussbaum gainsConsider the following system:where and are unknown constants and but unlike previous discussion the direction of is unknown. Use control law , the closed-loop system is :Define ideal gain $u=k^xa+bk^:=k_0\\le0\\dot{\\hat{k}}(t)=-\\gamma\\cdot sgn(b)x^2\\hat{k}(t)$. Nussbaum gainsis one kind of Nussbaum gain. It satisfies the following condition: changes its sign an infinite number of times as . Other Nussbaum gains: , ,… By using nussbaum gain in the form of (86), the closed-loop system(82) is:We derive the following expression:Integrating both sides of (88) from to :Thus we have:where ( and ) Note that is monotone nondecreasing. must either approach a finite limit or grow without bound. If grows without bound, the sign of will be dominated by the term , which can assume a large negative value independent of the sign of . As a result , the right side of (90) is negative. Clearly, there is a contradiction with . Therefore, must be bounded. Then from (90) and from . From (87) we known $\\dot{x}\\in\\mathcal{L}\\infty\\lim \\limits{t\\rightarrow\\infty}=0$. Robust Adaptive ControlParameter DriftOur starting point is the following scalar system: where is the state, is the control input, is a continuous known function, is the unknown constant, and is a bounded time-dependent disturbance with . Control Objective: Design , such that all signals in the closed-loop system are bounded, and the state is derived to zero. (or to a small neighbor of zero) When , we proposed the following control inputThe the closed-loop system is :Consider a Lyapunov function candidate:Its derivative along (93) is :Then the adaptation law can be designed as:But when , the closed-loop system is:The derivative of in (94) along (97) is:Clearly, outside the set Missing or unrecognized delimiter for \\leftE_0=\\left{(x,\\tilde{\\theta}):\\Vert x\\Vert \\le\\frac{d_{max}}{k}:=e_0 \\right}. Inside , might be positive, and as a consequence, the parameter error can grow freely and even become unbounded. This phenomenon is known as parameter drift. It is caused by the disturbance. This is argument shows that the proposed adaptive law is not robust. Q: Does the state remain bounded? No existing answer. An Example of Parameter Drift Assume That . Consider a certain example for (91) as following:$$\\left{\\right. $$ The Dead-Zone ModificationIn order to enforce robustness, we consider an adaptive law with the dead-zone modification:$$\\dot{\\hat{\\theta}}=\\left{\\right.n_1 \\triangleq \\left{t:\\Vert x(t)\\Vert\\lt e_0+\\delta \\right} \\n_2 \\triangleq \\left{t:\\Vert x(t)\\Vert \\ge e_0+\\delta \\right}$$ If , and the trajectory reaches the boundary of , and is outside at , we have:When , . We can conclude that at is monotonously decreasing. Finally, we can get is bounded, and . Advantage of Dead-Zone Modification: Simplicity and effectiveness Drawbacks: The assumption that an upper bound for the disturbances need is known a priori In the absence of disturbance, asymptotic stability of the tracking error cannot be recovered. In other words, robustness is achieved at the expense of destroying some of the ideal properties of the adaptive law. The -ModificationThe -modification scheme, developed by Ioanon and Kokotovic does not require any priori information on the disturbance upper bounds. The adaptive law with the -modification is (with the ideal of feedback control) :where and are positive constants. In essence, this modification adds some damping to the ideal adaptive law. The motivation here is to prevent parameter drift. Under (105), the derivative of (94) along (93) is :Note that:and:Substituting (108) and (107) into (106) yields:We have . By adjusting , the convergence rate of can be modified.","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"自适应控制","slug":"自适应控制","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/"}]},{"title":"Go语言GMP模型","slug":"Go语言GMP模型 54845","date":"2021-07-28T01:58:24.000Z","updated":"2022-03-10T15:39:10.657Z","comments":true,"path":"2021/07/28/Go语言GMP模型 54845/","link":"","permalink":"https://kimanyang.xyz/2021/07/28/Go%E8%AF%AD%E8%A8%80GMP%E6%A8%A1%E5%9E%8B%2054845/","excerpt":"","text":"Go语言GMP模型为什么学习Go语言： Go语言的吉祥物是土拨鼠，开发者自称Gopher, 完美契合当代越南青年的鼠人形象 GMP模型中的Worker（Goroutine）和越南青年一样只能任人摆布调度剥削，资源掌握在深不见底的内核之中 简单，快速上手，没有复杂的面向对象 快速的并发编程，自带GC无需关注内存细节同时速度够快 前置知识——进程、线程与协程之间的关系：进程的定义： 一个正在执行中的程序 一个正在计算机中执行的程序实例 能分配给处理器并且由处理器执行的实体 包括如下单元：一组指令序列的执行、一个当前状态和相关的系统资源集 进程信息被存放在进程控制块之中详细内容可见《操作系统–精髓与设计原理（第七版）》P80 图3.1 进程最重要的两个特点：1.进程拥有独立的资源所有权，进程间的资源是互斥的 2.进程被操作系统内核调度和执行 由此带来的问题是进程间对于资源的持有是不透明的，需要通过陷入内核的进程间的通信才能够交换彼此间的信息。进程内存占用开销几十MB到几百MB到几GB不等线程的定义多个线程可以存在于一个进程之中，对于单个线程存在如下资源： 线程的执行状态（运行、就绪、挂起or阻塞等等） 线程不在运行时的上下文（寄存器状态、程序计数器啥的），可以看作进程内的独立程序计数器 进程内的线程共享资源，线程对于资源的修改对于其他线程是透明的，其通信无需陷入内核 随着多线程多进程而来的问题：线程、进程的切换成本高昂，多线程之间的资源竞争带来的同步问题 协程的定义：进一步细化粒度，在程序内部对多个可执行的过程进行调度并提供一整套调度方式，在大部分的时间内无需陷入内核，不需要依赖操作系统的调度操作。也就是直接在线程内部交替执行模拟多线程，由于每一个协程只有几kb，因此可以大量地创建。（其实也存在着用户态线程的说法，纯粹的用户态线程应该也可以称为协程） 线程与线程比值以及相应地效果： 1：N 事实上地单核运行，无法发挥多核地优势，容易出现阻塞瓶颈 1：1 本质上相当于多线程多进程模型，切换协程也要切换线程，每次都得陷入内核 M:N 可以利用好多核心的优势同时协程的切换代价也会相应地降低，但是依赖调度算法的设计与优化 Go语言协程模型（GMP）何为GMP： G—Goroutine go协程，一段可执行的二进制代码和其拥有的堆栈资源 P—Processor 处理器，提供了运行上下文、调度队列, 对于G来说相当于一个CPU M—Machine 事实上是OS内核线程（区别于用户态线程）的抽象，代表实际的运算资源 （图片取自 刘丹冰Aceld Golang协程调度及其思想） 除此以外一个GMP模型还维护着各个P的本地队列以及一个全局队列 该模型的G和P部分可以理解为在用户态的层面自己实现了一个多核CPU 其中P的数量可以自己决定，通过命令配置环境变量 1go env -w GOMAXPROCS=n //n为你想要的P个数 对于M的数量其大小最大为10000（一般也达不到），如果一个M被P阻塞了，一个新的M会被创建，如果一个M空闲，那么就会被回收或者sleep 调度器策略线程复用机制： work stealing机制：线程M和绑定的P无可运行的G时尝试从其他绑定的M和P处偷取G来运行而不是直接销毁线程 hand off机制：当一个线程因为G的调用产生阻塞时，线程释放绑定的P，将P转移给其他空闲的线程进行执行 并行(Parallelism)与并发(Concurrency)机制： 关于并发与并行机制，Go语言创始人之一的Rob Pike说过这样一段话：Concurrency Is Not Parallelism. Concurrency is dealing lots of things at once. Parallelism is doing lots of things at once. Not the same, but related. One is about structure and one is about execution. Concurrency is not parallelism, although it enables parallelism. 并行在多个核心进行，一个操作系统中各个同时运行的进程可以看作是并行的，不同进程中正在同时执行的线程也可以看作并行的。 而并发是在一个核心之中分时复用CPU资源，使用者看起来是同时执行的样子而已，并非实际执行，dealing和doing两个词完美地指出了二者的区别。 对于go语言来说，一个P本地队列中的G肯定是并发的，如果两个P对应的两个M在同一个进程中那么G也只能算是并发的，但是OS可以调度M使之运行在多个CPU核心之上，所以Goroutine虽然主要是并发的，但语言本身也提供了并行的支持。 抢占调度机制： 一个goroutine最多占用CPU10ms的时间片，防止Goroutine在非阻塞情况下大量占用运算资源导致其他的Goroutine饥饿 全局队列机制： 在M无法在work stealing机制下获得G时，M会到全局队列获取G 经典八股文：一个go func()的执行经历了什么 go func()创建了一个goroutine (下文简称G) 这时G有两个选择，优先进入调度器P的本地队列，若本地队列满了进入全局队列 G运行在一个M中，M与P是1：1的关系，M会从P的本地队列中弹出一个G来执行，如果本地队列为空那么M会去其他MP那里偷取G来执行 M调度G的过程是一个循环的状态机模型 M执行G时发生了系统调用（意味着此时要陷入内核）或者go语言自带的阻塞机制(通道、waitgroup等)发挥作用时，M会进入阻塞状态，于是乎runtime会将P从该M上摘除，创建一个新的进程来为这个P服务 M系统调用或者阻塞结束的时候，位于其上G尝试获取一个空闲的P来执行并进入其本地队列，如果没有一个空闲的P可用，那么M会进入休眠，G被扔到全局队列 关于M位于自旋线程状态时的情况：自旋线程即本地队列为空且拥有的Goroutinue被执行完的MP组合，它们去全局队列拿G，没有的话就会去偷取其他的MP组合的G来执行，成功的话会退出自旋的状态，具体偷取和执行的方式细节十分丰富，详细说明如何执行这个策略可以参考https://www.notion.so/Go-GMP-dd55f3cf178c43c5bb31fc2ff791df8e#b7907ba58d3c4ebba937c5f5c4eccf36，但作为面试来说以上内容应该已经很足够了。 调度器的生命周期： M0为程序执行的主线程，其实例位于全局变量runtime.m0之中，不需要在堆内存上分配,M0负责执行初始化和启动第一个G，之后M0和其他的M一样被调度。 G0时每一次启动的M都会第一个创建的goroutine，G0仅仅用于负责调度的G，G0不指向任何可执行函数，每个M都有自己的G0，在进行协程调度或者系统调用的时候G0的栈空间被使用 关于GO语言堆栈空间以及内存的分配相关内容将会在同一个系列的另一篇文章里介绍 进一步阅读： https://zhuanlan.zhihu.com/p/360034857 这篇文章详解了Go语言的三种结构，interface&#x2F;goroutine&#x2F;channel在底层地实现方式，相关内容主要 123456789101112func largestNumber(nums []int) string &#123; sort.Slice(nums,func(i,j int)bool&#123; tempa := strconv.Itoa(nums[i])+strconv.Itoa(nums[j]) tmpeb := strconv.Itoa(nums[j])+strconv.Itoa(nums[i]) return tempa &gt; tmpeb &#125;) trans:=[]string&#123;&#125; for _,v:=range nums &#123; trans = append(trans,strconv.Itoa(v)) &#125; return strings.Join(trans,&#x27;&#x27;)&#125;","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"GMP模型","slug":"GMP模型","permalink":"https://kimanyang.xyz/tags/GMP%E6%A8%A1%E5%9E%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://kimanyang.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Go语言内存模型","slug":"Go语言内存模型 a2cd6","date":"2021-07-28T01:58:24.000Z","updated":"2022-03-10T15:39:05.061Z","comments":true,"path":"2021/07/28/Go语言内存模型 a2cd6/","link":"","permalink":"https://kimanyang.xyz/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%20a2cd6/","excerpt":"","text":"Go语言内存模型物理地址、地址空间与虚拟内存总之先推荐一下虚拟内存讲解得非常好的一个视频。 https://www.bilibili.com/video/BV18v411a7Vk?from=search&seid=8049687409040152217&spm_id_from&#x3D;333.337.0.0 物理内存顾名思义指内存芯片的内部存储结构，CPU寻址时根据物理地址获取改地址对应的数据字。 地址空间是一个非负整数集合，包含$[0,2^{n}-1]$。对于物理内存来说n是地址总线的个数，对于我们虚拟地址空间来说n是任意决定的，而且计算机中每一个进程独自拥有一整片完整的虚拟地址空间。CPU在进行索引时使用虚拟地址，经过MMU（内存管理单元）以及页表机制等硬件提供的映射服务将虚拟地址转换为对应的物理地址，这便是虚拟内存的工作流程简介。细节可以参考开头给出的视频以及CSAPP。 对于这篇文章来说，最重要的是理解如下几点： 理解虚拟内存即使已经获取并分配也并不一定占用实际的物理内存 虚拟内存提供了多进程之间的隔离，Go语言内存分配器分配的是独占的虚拟内存 Go内存分配器的设计(Tcmalloc)Go内存分配器基于谷歌研发的tcmalloc内存分配器（ThreadCache Malloc)。 以下图片引用https://zhuanlan.zhihu.com/p/29216091的图示进行代码讲解与分析。 分配的基本结构——Span与Object在第一节我们讲述了操作系统内存的分页结构（Page），Go内存分配在这基础上引入了Span和Object两个概念，其中Span是由多个页组成的较大块不定长内存；而Object是使用中为我们的程序实例对象分配内存的实际单元，由不同大小的Span切割对齐而来。 对于Span的管理，Go语言采用了类似于内存池分配的方法，为不同大小的对象预先切割好内存并利用隐式链表的方法进行管理。 1234567891011121314151617181920212223242526272829type mspan struct &#123; next *mspan // 显式链表下一节点 prev *mspan // 显式链表前一节点 startAddr uintptr // 首字节指针 npages uintptr // Span中的内存页数量 manualFreeList gclinkptr // 待分配的Object列表 freeindex uintptr //位于0和nelems中，表示以分配的内存块索引 nelems uintptr // Span中的Object数量 allocCache uint64 //gc相关 allocBits *gcBits //gc相关 gcmarkBits *gcBits //gc相关 sweepgen uint32 divMul uint16 // 元素大小切分 baseMask uint16 // if non-0, elemsize is a power of 2, &amp; this will get object allocation base allocCount uint16 // 已分配Object数量 spanclass spanClass // uint8的结构，决定了内部Object的大小 state mSpanStateBox // mspan状态，gc多线程相关以及内存管理使用 needzero uint8 // 进行内存分配前需要归0的标志位 divShift uint8 // for divide by elemsize - divMagic.shift divShift2 uint8 // for divide by elemsize - divMagic.shift2 elemsize uintptr // 由内存页数目或者spanClass决定的Object大小 limit uintptr // span的尾指针&#125; （虽然图示讲的是Page，但是我们可以暂且将其看作是一个Span，其结构可以和单个Span对应） Span的大小在8B到32KB之间不等，并非严格的按照2的幂次进行分配以减少内部碎片。超过32KB的对象会以另外的方式进行分配。除此以外，分配器对于多个微小的对象会尝试组合到一个Object内部进行内存分配以提高分配效率。 上述管理方式还存在着外部碎片的问题：不同大小的Span在连续的内存页中混杂共存，相同大小的内存通过指针进行联系。如果程序中有大量的小内存对象申请，分配器会将大的Span拆分为小的Span提高内存利用率，但是当小内存对象释放内存的时候程序如果需要大的内存空间就只能再向上级的分配器申请，原先的小内存对象释放后的span成为了外部碎片。为了避免这个问题直观的想法是将释放内存后的span前后的空闲span合并，由于page地址空间连续，span地址空间不连续，我们需要一个page（即地址）到span的映射来获取span前后的其他span状态。 再TCmalloc中，采用RadixTree结构来完成这一映射，这是一种特殊的前缀树，详细的介绍可以参考https://en.wikipedia.org/wiki/Radix_tree这里不再进行赘述。在源码之中这一映射被存放在mheap中进行管理。 内存的管理组件由于Span以及Heap为我们提供了从虚拟地址空间到Span内存池之间的一层抽象映射，底层的内存管理组件只需要关心Span的可用性以及待分配对象大小即可。 goruntime提供了三种内存分配组件：mcache、mcentral以及mheap。 mcache被每一个线程独占（也就是Go语言GMP模型中的P），在tcmalloc中被称为ThreadCache，可以进行无锁分配，拥有预分配好的一批span，分配时若对象在mcache中有合适的span就直接分配在其上，没有合适的span时会向所需span规格的mcentral进行申请 对于不同大小的对象有不同个mcentral（并非图中所示的一个），每个mcentral维护具有相同大小的span的一个spanlist，mcache申请时需要加锁访问。 如果mcentral没有合适的span可供mcache使用，那么mcentr会向mheap申请span。正如上一节所述mheap维护了内存页和span之间的映射，它首先会尝试合并空闲的span并将其交给mcentral，如果失败了，则陷入系统调用向操作系统申请新的内存。 mcache结构体内容12345678910111213141516171819type mcache struct &#123; next_sample uintptr // heap相关 local_scan uintptr // heap相关 //对于非指针的微小对象特殊处理相关，在一个object里面挤一挤 tiny uintptr tinyoffset uintptr local_tinyallocs uintptr //对于小对象可以根据numSpanClasses直接分配在span上 alloc [numSpanClasses]*mspan stackcache [_NumStackOrders]stackfreelist // 当前分配器的状态 local_largefree uintptr // 可用于大对象（&gt;32kB)的字节指针 local_nlargefree uintptr // 可用于大对象的块数目 (&gt;32kB) local_nsmallfree [_NumSizeClasses]uintptr // 可用于对应大小小对象的块数目指针桶(&lt;=32KB)&#125; mcentral结构体内容1234567891011121314type mcentral struct &#123; lock mutex //mcache申请时的互斥锁 spanclass spanClass //当前mcentral属于的span大小 nonempty mSpanList // 具有空闲的object的span称为非空span empty mSpanList // 被mcache取走或者没有空闲object的span //GC相关的span集合 partial [2]spanSet // list of spans with a free object full [2]spanSet // list of spans with no free objects //累加的整数，用于记录被分配出去的对象数目，假设所有被mcache拿走的span被完全分配 nmalloc uint64&#125; mheap结构体内容heap结构体相对复杂，包含了一些初始化时的内存连续地址划分以及垃圾回收算法的相关字段。简单介绍一下初始化时预分配的地址空间内容。上一节没有详细说明的大于32KB的对象会直接在mheap进行分配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465type mheap struct &#123; lock mutex pages pageAlloc // 内存页存储结构 sweepgen uint32 // gc相关 sweepdone uint32 // gc相关 sweepers uint32 // gc相关 // allspans包含所有已构建的span指针列表. 每个span只出现一次 //其内存地址会随着堆的增长进行移动和再分配 allspans []*mspan // gc相关 sweepSpans [2]gcSweepBuf _ uint32 // uint64对齐到32-bit，保证原子性 // gc相关 pagesInUse uint64 pagesSwept uint64 pagesSweptBasis uint64 sweepHeapLiveBasis uint64 sweepPagesPerByte float64 //堆持有的虚拟内存总量，runtime通过将内存交还操作系统来维持 scavengeGoal uint64 // Page reclaimer state reclaimIndex uint64 reclaimCredit uintptr // 分配状态 largealloc uint64 // 为大对象分配的字节数目 nlargealloc uint64 // 可以分配的大对象数目 largefree uint64 // 剩余大对象可分配字节数目 nlargefree uint64 // 剩余大对象可分配数目 nsmallfree [_NumSizeClasses]uint64 // 可分配小对象数目 //该数组用于管理所有的heapArena，包含了span指针区，bitmap区和真正的堆区 arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena // 堆分配相关 heapArenaAlloc linearAlloc arenaHints *arenaHint arena linearAlloc // 可用大对象地址空间的迭代 allArenas []arenaIdx // GC相关 sweepArenas []arenaIdx // GC相关 markArenas []arenaIdx // 堆增长的位置 curArena struct &#123; base, end uintptr &#125; // 核心功能，对应的mcentral列表 central [numSpanClasses]struct &#123; mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]byte &#125;&#125; 堆区的内存页以arena的数组的形式进行保存，大内存对象（&gt;32KB）直接经过arena进行分配，其结构如下所示： 123456789101112131415161718192021type heapArena struct &#123; //用于垃圾回收时的标记位图，表示对应span的情况，在gc章节会详细讲述 bitmap [heapArenaBitmapBytes]byte //虚地址页ID在span上的ID映射与spans指针集合(页号对应的已分配span指针) spans [pagesPerArena]*mspan // 页号所处的span是否被使用，GC相关 pageInUse [pagesPerArena / 8]uint8 // 页号所处的span是否被标记，GC相关 pageMarks [pagesPerArena / 8]uint8 // pageSpecials is a bitmap that indicates which spans have // specials (finalizers or other). Like pageInUse, only the bit // corresponding to the first page in each span is used. pageSpecials [pagesPerArena / 8]uint8 // 标志本arena第一页的第一个字节 zeroedBase uintptr&#125; 全貌总结 总结一下全文， 本文所讲的内存分配基本上是关于堆区的内存分配，但是我们在写代码时可以尽量使得对象和变量位于栈区，在编译器能够确定内存大小就不必走本文的内存分配机制。 堆区在Go语言中提供了两种基本抽象，一种是包含并管理虚拟内存页的heapArena，另一种是针对32KB以下对象进行管理的具有不同大小的span 与操作系统的交互、内存管理伙伴系统的实现由堆区进行，同时堆区也维持了虚拟页号到span的映射用于合并内存减少外部碎片问题 mcentral管理不同类型的 span集合，每一个process（Go中指线程）向所需mecentral申请span同时拥有自己的span缓存","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"内存模型","slug":"内存模型","permalink":"https://kimanyang.xyz/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"Tcmalloc","slug":"Tcmalloc","permalink":"https://kimanyang.xyz/tags/Tcmalloc/"}]},{"title":"Go语言垃圾回收","slug":"Go语言垃圾回收 54997","date":"2021-07-28T01:58:24.000Z","updated":"2022-03-10T15:38:56.147Z","comments":true,"path":"2021/07/28/Go语言垃圾回收 54997/","link":"","permalink":"https://kimanyang.xyz/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2054997/","excerpt":"","text":"Go语言垃圾回收垃圾回收的基本概念对于存在于栈区的内存，当栈所对应的进程、线程或者协程终止时，其中分配的内存会被自动销毁。但是如果所需的内存较大并且内存分配在堆区，事情变得复杂起来，可能有多个进程、线程或者协程甚至只是简单的不同的函数共享一个对象的内存，如果对象不再被使用后这部分内存没有被销毁，那么会造成内存泄漏，当内存泄漏积累到一定程度内存被耗尽则可能造册内存溢出。因此设计一套合理的内存释放方法十分有必要。 在C++、C中内存释放的时机交由程序员自己手动管理，Rust在语言层面采取了RAII（资源获取即初始化）的设计模式，在编译阶段保证了内存不会泄露，但这也给程序书写的灵活性带来极大的困难。更多的现代语言采用专门垃圾收集器（Garbage Collector, GC)来保证用户不需要耗费过多的精力在内存管理上而是专注于功能的实现。 垃圾回收方法介绍RAII资源获取即初始化严格来说这不能称为GC算法，利用了局部变量自动销毁的特性，声明全局对象的生命周期或者进行引用计数，在对象不再被使用后确保会被清除，在C++中通过各种智能指针以及类的析构函数来实现这一思想，还有Object-C提供的ARC自动引用计数方法，也是一种语言层面的RAII。但是这种内存管理方法这仍然会给我这种菜比程序员带来很大的心智负担。 标记清除最为原始的GC方法，程序使用替身能力开启STW（stop the world）停止所有任务的执行，垃圾收集器从主程序的栈开始递归遍历所有被引用的对象并进行标记，所有没有被标记的对象都将被清除。这种想法很好理解，在Go早期采用过这样的方法，采用Muatator&#x2F;Allocator&#x2F;Collector对mheap区的内存进行标记、分配以及回收。 但这么做显然会带来很大的性能问题，一般是假定内存占用达到某个阈值开始进行STW，如果阈值太低那么STW触发过于频繁导致总体性能下降，阈值太高则容易使得标记清除时间过长用户程序等待过久，在很多时候这种情况是令人无法忍受的。 上图分别表示了标记阶段与清除阶段的操作，箭头指示了引用关系。 三色标记最最基础三色标记本身并不比原始的标记清除高效许多，其标记过程可能可以通过一定的多线程手段加速，但是这个过程仍然无法并发进行，需要进行STW ，它的存在更重要的是作为一层抽象成为进一步GC算法的基础。其原理仍然很简单，如果说原始的标记清除法递归地查找根节点可达对象树是深度优先搜索，那么三色标记就是其广度优先搜索版本。 三色指的是三种对象标记： 灰色对象：存在指向白色对象的指针的对象，属于活跃对象 黑色对象：根节点可达且不存在引用白色对象外部指针的对象，属于活跃对象 白色对象：潜在的垃圾，可能会被垃圾回收器回收（不一定会立刻回收） 我们将标记阶段归纳为： 一开始将所有的对象标记为白色，根节点标记为灰色 从灰色对象集合中选取一个对象标记为黑色，再将其引用的所有对象都标记为灰色 重复步骤2直到没有灰色对象 标记阶段结束后垃圾收集器回收所有的白色对象。 显然如果在标记过程中采用并发执行程序导致引用关系被修改，产生“悬浮指针”是十分危险的 三色不变性读写屏障假设我们要在三色标记的同时对对象进行操作，要求操作后的所有对象不会产生诸如上述的“悬浮指针”这样的错误清除操作，这使得清除阶段可以和程序运行交替进行或者并发进行，从而大大提高垃圾回收的效率，这时候我们需要做些什么呢？保证三色不变性的读写屏障技术可以帮助我们解决这个问题。 首先介绍一下三色不变性： 强三色不变性：保证黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象 弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径(P. P. Pirinen. Barrier techniques for incremental tracing. In ACM SIGPLAN Notices, 34(3), 20–25, October 1998. https://dl.acm.org/doi/10.1145/301589.286863 ↩︎) 满足两个不变性中的一个即可保证GC算法的正确性，强三色不变性很好理解，根本上不可能产生悬浮指针，而弱三色不变性则保证了指向的白色对象由于终将染成黑色所以也能保证不产生悬浮指针。采用屏障技术从而保证三色不变性，编程语言有两种选择——读屏障（Read Barrier)和写屏障(Write Barrier)两种，一般来说读操作在程序执行时远远多于写操作，而屏障技术属于一种钩子或者触发器函数在对象进行读写时触发，有一定的开销，所以选取更少触发的写屏障可以更好地提高程序执行的效率。 Go语言的垃圾回收技术采用了两种写屏障：Dijkstra插入写屏障和Yuasa删除写屏障 Dijkstra插入写屏障 当黑色对象修改其引用，指向了一个白色对象时，将白色对象染为灰色，从而保证了强三色不变性，下图展示了其工作流程，标记时切换到主程序，主程序在修改A对象指针时将白色对象C染为灰色，在下一轮切换回标记时灰色对象被染黑。 这种保守的写法可能将不再存活的B标记为黑色，而若是下一次切换到主程序时A又把C的指针改回去，那么标记为黑色的C不再存活却得等到下一轮GC标记开始才能被回收。 同时由于栈上元素也被认为是根节点元素，同一个对象可能是多个根节点可达的，而一次标记可能只从单个根节点开始，所以要么将栈上的对象也纳入读写屏障的范围，要么在每次切换到GC时都咋瓦鲁多标记栈上元素为恒灰（为什么不能是黑？因为用户程序可能在栈上引用了白色节点破坏了三色不变性） Yuasa删除写屏障 针对所有的指针，当该指针所引用的对象发生改变或者指针被删除时，指针原本所引用的对象标记为灰色，通过这种屏障操作能够实现弱三色不变性。一开始GC标记到A为黑B为灰，切到了主程序，图中A指向B的指针drop到C时将B标记为灰色，由于B本来就是灰的所以无影响，此时弱三色不变性得以保证（C可有灰色对象B到达）；下一步主程序B指向C的指针drop掉，由于删除写屏障C被标记为灰色，弱三色不变性仍然得以保证。 增量垃圾回收与并发垃圾回收有了三色不变性以及屏障技术的理论支持，我们可以将基本的三色标记法扩展为增量以及并发的版本。回忆一下之前所说的STW垃圾回收的缺点：STW间隔时间过长，导致内存过大，GC时用户程序无响应时间过长导致用户无法忍受（想象一下程序流畅运行一段时间后完全无响应，之后才有响应）；STW间隔过短浪费CPU资源。 增量垃圾回收 这种方法减少的是最长暂停时间，虽然将完整的一次垃圾回收时间拉长，但是减少了用户程序的等待时间。具体做法跟我们示例读写屏障中的切换垃圾回收与用户程序类似，触发垃圾回收后将时间切换为时间片，GC标记程序和用户程序用完各自时间片后暂停交由对方运行。 不过这要求用户程序在GC期间运行写屏障，会导致一定的开销，不过总体上利大于弊。 并发垃圾回收 GC和用户程序并发运行，具体设计十分复杂，在下一章会详细分析Go所用的并发垃圾回收技术。并发不能完全避免STW，会占用一定的CUP以及内存资源影响用户程序执行。但可以无限接近完美。 混合写屏障该方法用于解决我们所说的Dijkstra写屏障的弊端，之前说过为了安全没有被扫描的栈的根对象要么纳入写屏障，要么STW进行添加，但是在Go中几百个Goroutine都有自己栈，全部扫描一遍是不可接受的，完全纳入写屏障开销也十分巨大，那么采用混合写屏障可以缓解这个问题。 混合写屏障：在保证执行汤浅写屏障的前提下，如果当前栈没有被扫描，执行Dijkstra写屏障 同时在GC期间所有新创建的对象都设置为黑色，防止新分配的栈内存和堆内存对象被错误回收。 Go语言垃圾回收简介未完待续","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://kimanyang.xyz/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]}],"categories":[{"name":"散文","slug":"散文","permalink":"https://kimanyang.xyz/categories/%E6%95%A3%E6%96%87/"},{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"},{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"},{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"散文","slug":"散文","permalink":"https://kimanyang.xyz/tags/%E6%95%A3%E6%96%87/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"爬虫","slug":"爬虫","permalink":"https://kimanyang.xyz/tags/%E7%88%AC%E8%99%AB/"},{"name":"colly","slug":"colly","permalink":"https://kimanyang.xyz/tags/colly/"},{"name":"golang","slug":"golang","permalink":"https://kimanyang.xyz/tags/golang/"},{"name":"并发编程","slug":"并发编程","permalink":"https://kimanyang.xyz/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"互斥锁","slug":"互斥锁","permalink":"https://kimanyang.xyz/tags/%E4%BA%92%E6%96%A5%E9%94%81/"},{"name":"读写锁","slug":"读写锁","permalink":"https://kimanyang.xyz/tags/%E8%AF%BB%E5%86%99%E9%94%81/"},{"name":"条件变量","slug":"条件变量","permalink":"https://kimanyang.xyz/tags/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"},{"name":"sqlx总结","slug":"sqlx总结","permalink":"https://kimanyang.xyz/tags/sqlx%E6%80%BB%E7%BB%93/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Context总结","slug":"Context总结","permalink":"https://kimanyang.xyz/tags/Context%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"https://kimanyang.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://kimanyang.xyz/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"https://kimanyang.xyz/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"网络流","permalink":"https://kimanyang.xyz/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"Ford-Fulkerson算法","slug":"Ford-Fulkerson算法","permalink":"https://kimanyang.xyz/tags/Ford-Fulkerson%E7%AE%97%E6%B3%95/"},{"name":"Dinic算法","slug":"Dinic算法","permalink":"https://kimanyang.xyz/tags/Dinic%E7%AE%97%E6%B3%95/"},{"name":"Edmond-Karp算法","slug":"Edmond-Karp算法","permalink":"https://kimanyang.xyz/tags/Edmond-Karp%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"},{"name":"树状数组","slug":"树状数组","permalink":"https://kimanyang.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://kimanyang.xyz/tags/ST%E8%A1%A8/"},{"name":"线段树","slug":"线段树","permalink":"https://kimanyang.xyz/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"KMP","slug":"KMP","permalink":"https://kimanyang.xyz/tags/KMP/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"Trie字典树","slug":"Trie字典树","permalink":"https://kimanyang.xyz/tags/Trie%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://kimanyang.xyz/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"路径压缩","slug":"路径压缩","permalink":"https://kimanyang.xyz/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"},{"name":"matlab","slug":"matlab","permalink":"https://kimanyang.xyz/tags/matlab/"},{"name":"LQR算法","slug":"LQR算法","permalink":"https://kimanyang.xyz/tags/LQR%E7%AE%97%E6%B3%95/"},{"name":"凸优化","slug":"凸优化","permalink":"https://kimanyang.xyz/tags/%E5%87%B8%E4%BC%98%E5%8C%96/"},{"name":"HJB方程","slug":"HJB方程","permalink":"https://kimanyang.xyz/tags/HJB%E6%96%B9%E7%A8%8B/"},{"name":"卡尔曼滤波","slug":"卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"优化算法","slug":"优化算法","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"分布式卡尔曼滤波","slug":"分布式卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"Cookie","slug":"Cookie","permalink":"https://kimanyang.xyz/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"https://kimanyang.xyz/tags/Token/"},{"name":"Session","slug":"Session","permalink":"https://kimanyang.xyz/tags/Session/"},{"name":"身份认证","slug":"身份认证","permalink":"https://kimanyang.xyz/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"},{"name":"扩展卡尔曼滤波","slug":"扩展卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"模型预测控制","slug":"模型预测控制","permalink":"https://kimanyang.xyz/tags/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/"},{"name":"二次规划","slug":"二次规划","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/"},{"name":"多智能体","slug":"多智能体","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"},{"name":"一致性","slug":"一致性","permalink":"https://kimanyang.xyz/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/tags/Javascript/"},{"name":"页面事件","slug":"页面事件","permalink":"https://kimanyang.xyz/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/"},{"name":"前端经典案例","slug":"前端经典案例","permalink":"https://kimanyang.xyz/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"},{"name":"事件流模型","slug":"事件流模型","permalink":"https://kimanyang.xyz/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/"},{"name":"DOM事件","slug":"DOM事件","permalink":"https://kimanyang.xyz/tags/DOM%E4%BA%8B%E4%BB%B6/"},{"name":"DOM模型","slug":"DOM模型","permalink":"https://kimanyang.xyz/tags/DOM%E6%A8%A1%E5%9E%8B/"},{"name":"H5标签","slug":"H5标签","permalink":"https://kimanyang.xyz/tags/H5%E6%A0%87%E7%AD%BE/"},{"name":"CSS过渡","slug":"CSS过渡","permalink":"https://kimanyang.xyz/tags/CSS%E8%BF%87%E6%B8%A1/"},{"name":"CSS3新特性","slug":"CSS3新特性","permalink":"https://kimanyang.xyz/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"CSS布局","slug":"CSS布局","permalink":"https://kimanyang.xyz/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"CSS三角与精灵图","slug":"CSS三角与精灵图","permalink":"https://kimanyang.xyz/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS 溢出显示","slug":"CSS-溢出显示","permalink":"https://kimanyang.xyz/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/"},{"name":"CSS浮动与定位","slug":"CSS浮动与定位","permalink":"https://kimanyang.xyz/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://kimanyang.xyz/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS盒模型","slug":"CSS盒模型","permalink":"https://kimanyang.xyz/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"LRU","slug":"LRU","permalink":"https://kimanyang.xyz/tags/LRU/"},{"name":"LFU","slug":"LFU","permalink":"https://kimanyang.xyz/tags/LFU/"},{"name":"BitSet","slug":"BitSet","permalink":"https://kimanyang.xyz/tags/BitSet/"},{"name":"STL","slug":"STL","permalink":"https://kimanyang.xyz/tags/STL/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://kimanyang.xyz/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"优先队列","slug":"优先队列","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"多路归并","slug":"多路归并","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://kimanyang.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"快速排序","slug":"快速排序","permalink":"https://kimanyang.xyz/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"https://kimanyang.xyz/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://kimanyang.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分法","slug":"二分法","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"Rabin-Karp","slug":"Rabin-Karp","permalink":"https://kimanyang.xyz/tags/Rabin-Karp/"},{"name":"哈希算法","slug":"哈希算法","permalink":"https://kimanyang.xyz/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"name":"状态机DP","slug":"状态机DP","permalink":"https://kimanyang.xyz/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://kimanyang.xyz/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"非自治系统","slug":"非自治系统","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"},{"name":"自治系统","slug":"自治系统","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"},{"name":"自适应控制","slug":"自适应控制","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/"},{"name":"控制系统设计","slug":"控制系统设计","permalink":"https://kimanyang.xyz/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"机械臂","slug":"机械臂","permalink":"https://kimanyang.xyz/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"GMP模型","slug":"GMP模型","permalink":"https://kimanyang.xyz/tags/GMP%E6%A8%A1%E5%9E%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://kimanyang.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存模型","slug":"内存模型","permalink":"https://kimanyang.xyz/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"Tcmalloc","slug":"Tcmalloc","permalink":"https://kimanyang.xyz/tags/Tcmalloc/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://kimanyang.xyz/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]}