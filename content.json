{"meta":{"title":"Brief Candle","subtitle":"Unterm Rad","description":"Planet earth is blue, and there is nothing I can do.","author":"Kiman Yang","url":"https://kimanyang.xyz","root":"/"},"pages":[{"title":"文章归档","date":"2022-03-09T07:13:15.346Z","updated":"2022-03-09T07:06:47.634Z","comments":true,"path":"archive.html","permalink":"https://kimanyang.xyz/archive.html","excerpt":"","text":""}],"posts":[{"title":"分布式卡尔曼滤波阅读笔记","slug":"分布式卡尔曼滤波观测器","date":"2022-03-25T05:12:23.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/03/25/分布式卡尔曼滤波观测器/","link":"","permalink":"https://kimanyang.xyz/2022/03/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E8%A7%82%E6%B5%8B%E5%99%A8/","excerpt":"","text":"TargetDesign a distributed linear estimator of linear time-varying random field that uses only local communications among the sensors such that the distributed estimates are asymptotically unbiased with bounded mean-squared errors. Main Contribution Propose a single time scale distributed information Kalman filter (DIKF) to obtain unbiased estimates with bounded MSE for unstable systems Develop a general analytical design of the estimator gain matrices by introducing a novel consensus+innovations type dynamic averaging step that runs in parallel with the DIKF Problem FormulationObserver dynamicsLet collect the samples of the system at time . Observer dynamics:where is the system dynamics matrix and is the input noises. The system is observed by a network of sensors(agents), where the measurement of sensor , . In vector notation:$$\\underbrace{}{z_i}=\\underbrace{}{H}x_i+\\underbrace{}{r_i}z_i,r_i\\in R^{\\sum{n=1}^N M_n}\\A\\in R^{M\\times M}\\H_n\\in R^{M_n\\times M}\\H\\in R^{\\sum_{n=1}^N M_n\\times M}$$Some assumptions : the input noise sequence and the sensing noise sequence are zero mean independent the input noise sequence and the sensing noise sequence are both distributed Gauss with covariance and where is block-diagonal . the input noise sequence and the sensing noise sequence are respectively and statistically independent of each other and of Communication NetworkThe sensors communicate through a network define by a simple(no self-loops nor multiple edges), undirected, connected graph , where is the set of sensors(nodes, vertexes or agents) and is the set of local communication channels(edges or links) among the sensors. The Laplacian matrix of is denoted by . The communication network is sparse and time-invariant. Overall Properties and Assumptions The paper focus on developing a distributed estimator over a time-invariant network with time-invariant observation models , and time-invariant dynamics Each agent knows the dynamics model and , the statistics of the initial condition and , the observations model, and , and the network, . The field dynamics and the distributed observations are globally observable but not necessarily locally detectable, i.e., the pair is detectable but are not necessarily detectable. The agent communication network is connected, i.e., the algebraic connectivity of the Laplacian matrix is strictly positive. The system is distributedly observable, i,e., the matrix is full rank, where: Centralized Kalman Filter(CKF)Pseudo-ObservationFor dimensions of the local observations, are different for different agents, we need to introduce pseudo-observations which have the same dimension :Let . The vector form:where . The average pseudo-observations are:$$\\bar{y}i = \\frac{1}{N}\\sum{n=1}^NH_n^TR_n^{-1}z_i^n=Gx_i+\\frac{1}{N}H^TR^{-1}r_i$$ Centralized Kalman FilterFollow the general Kalman filter algorithm: Global Averaging: $\\bar{y}i=\\frac{1}{N}\\sum{n=1}^N y_i^n$ Filtering:$$\\begin{align}K_i^c&amp;=\\left(\\frac{1}{N}(\\Sigma_{i|i-1}^c)^{-1}+G\\right)^{-1} \\\\hat{x}{i|i}^c&amp;=\\hat{x}^c{i|i-1}+K_i^c(\\bar{y}i-G\\hat{x}{i|i-1}^c) \\\\Sigma_{i|i}^c &amp;=(I_M-K_i^cG)\\Sigma_{i|i-1}^c(I_M-GK_i^c)+\\frac{1}{N}K_i^cGK_i^c\\end{align}$$ Prediction:$$\\begin{align}\\hat{x}{i+1|i}^c &amp;= A\\hat{x}{i|i}^c \\\\Sigma^c_{i+1|i} &amp;= A\\Sigma^c_{i|i}A^T+V\\end{align}$$ Distributed Information Kalman Filter(DIKF)PreworkSome pre-definition:In DIFK algorithm, each agent runs two companion sub-routines: dynamic consensus on the pseudo-observations to estimate distributed filtering to estimate the state To achieve dynamic consensus on the pseudo-observations, we define the error process. The agent’s distributed filter and prediction estimates of are and , respectively. The distributed filter error and the distributed prediction error are :$$\\begin{align}\\epsilon^n_{i|i} &amp;= \\hat{x}^n_{i|i}-x_i \\\\epsilon_{i+1|i}^n &amp;= \\hat{x}{i+1}^n-x{i+1}\\end{align}q_i^n = \\hat{y}i^n-Gx_i$$The distributed pseudo-observations error covariance matrix is . Let be the covariance between $\\epsilon{i|i-1}q_i^n$\\hat{x}{i|i} =\\begin{bmatrix}\\hat{x}^1{i|i}\\ \\vdots \\ \\hat{x}^N_{i|i}\\end{bmatrix},\\hat{x}{i+1|i} =\\begin{bmatrix}\\hat{x}^1{i+1|i}\\ \\vdots \\ \\hat{x}^N_{i+1|i}\\end{bmatrix},\\hat{y}{i} =\\begin{bmatrix}\\hat{y}^1{i}\\ \\vdots \\ \\hat{y}^N_{i}\\end{bmatrix},\\begin{align}\\epsilon_{i|i}&amp;=\\hat{x}{i|i}-1_N\\otimes x_i \\\\epsilon{i+1|i}&amp;=\\hat{x}{i+1|i}-1_N\\otimes x{i+1} \\q_i &amp;= \\hat{y}i - 1_N\\otimes(Gx_i)\\end{align}$$The covariance between $\\epsilon{i|i-1}q_i\\Pi_i\\Sigma_{i|i}\\Sigma_{i+1|i}Q_iP_i$ are block matrices of the above vector. Initial Conditions$$\\begin{align}\\hat{x}_{0|-1} &amp;= \\bar{x}0 \\A_G\\hat{y}{-1}^n &amp;= G\\bar{x}0 \\\\Sigma{0|-1} &amp;= J\\otimes \\Sigma_0 \\Q_0 &amp;= \\left( (I_N\\otimes B)\\bar{D}_H-I_N\\otimes G \\right)(J\\otimes \\Sigma_0) \\&amp;\\left(\\bar{D}_H(I_N\\otimes B^T)-I_N\\otimes G \\right)+(I_N\\otimes B)\\bar{D}_H(I_N\\otimes B^T) \\\\Pi_0 &amp;=(J\\otimes \\Sigma_0)\\left(I_N \\otimes G- \\bar{D}_H(I_N\\otimes B^T)\\right)\\end{align}$$ AlgorithmAt time , agents communicate their pseudo-observations estimates to neighbors and implement the following steps: Dynamic Consensus on Pseudo-Observations: $$ \\begin{align} \\hat{y}i^n &amp;= A_G\\sum{l\\in\\Omega_n}w_{nl}\\hat{y}^l_{i-1}+B(y_i^n-H_G^nA_G\\hat{y}{i-1}^n) \\ Q{i+1} &amp;= FQ_iF^T + \\Psi \\end{align} $$ Filtering: $$ \\begin{align} K_i^n &amp;= \\left((Q_i^n+(\\Pi_i^n)^TG)(\\Sigma_{i|i-1}^nG+\\Pi_i^n)^{-1}+G \\right)^{-1} \\ \\hat{x}{i|i}^n &amp;= \\hat{x}{i|i-1}^n + K_i^n(\\hat{y}i^n-G\\hat{x}{i|i-1}^n) \\ \\Sigma_{i|i} &amp;= (I_{MN}-K_i(I_N\\otimes G))\\Sigma_{i|i-1}(I_{MN}-(I_N\\otimes G)K_i^T) \\ &amp;+K_i\\Pi_i^T(I_{MN}-(I_N\\otimes G)K_i^T) \\end{align} $$ Prediction:$$\\begin{align}\\hat{x}{i+1|i}^n &amp;= A\\hat{x}{i|i} \\\\Sigma_{i+1|i} &amp;= (I_N\\otimes A) \\Sigma_{i|i}(I_N\\otimes A^T)+J\\otimes V \\\\Pi_{i+1} &amp;= (I_N\\otimes A)(I_{MN}-K_i(I_N\\otimes G))\\Pi_i F^T \\&amp;+(I_N\\otimes A)K_iQ_iF^T \\&amp;+(J\\otimes A)\\left( I_N\\otimes G-\\bar{D}_H(I_N\\otimes B^T)\\right)\\end{align}$$ where is a stochastic consensus weight matrix; are the estimator gain matrices; and . The error matrix and the noise covariance matrix are: Comparison &amp; Conclusion DIKF is capable of ditributed estimation of the unstable dynamical system with bounded MSE. The simulated MSE of the DIKF has a performance gap of about 2.5dB when compared to the CKF. Note that the distributed gain matrices are computationally expensive, the paper used Monte-Carlo simulate the DIKF with time invariante gain matrices .","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"卡尔曼滤波","slug":"卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"优化算法","slug":"优化算法","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"分布式卡尔曼滤波","slug":"分布式卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"}]},{"title":"web身份认证机制以及Go中的实现","slug":"web身份认证机制以及Go中的实现","date":"2022-03-22T15:56:24.000Z","updated":"2022-03-23T07:35:22.134Z","comments":true,"path":"2022/03/22/web身份认证机制以及Go中的实现/","link":"","permalink":"https://kimanyang.xyz/2022/03/22/web%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8AGo%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"web身份认证机制以及Go中的实现服务端渲染的Session认证模式由于HTTP的无状态性，每个请求间默认是无状态保留的，为了能够识别用户的身份使用了cookie，一般它的大小不大于4KB，由一个Name和Value以及控制其有效期、安全性和适用范围的可选属性构成。不同域名下的cookie相互独立，每次客户端发起请求时会自动把当前域名下所有未过期的cookie一起发送到服务器。 当客户端第一次发起请求的时候，服务器通过响应头的形式向客户端发送一个用于身份认证的cookie，当客户端浏览器每次请求服务器的时候浏览器会自动将身份认证相关的cookie通过请求头的形式发送给服务器以此来验证客户端身份。 需要注意 cookie并不具备安全性，存储在客户端，因此不能够存放隐私数据。整个基于cookie的session认证机制流程如下： 常用的session认证机制需要配合cookie实现，而cookie不支持跨域，在使用时需要额外的配置来实现认证。 前后端分离的JWT认证机制这种机制往往存在于需要跨域请求的场合，JSON Web Token(JWT)是目前最流行的跨域认证解决方案。其工作原理如下所示： 一个加密的JWT由三个部分组成，分别是Header.Payload.Signature，它们之间由点号分割，头部和签名保证Token安全性，比如采用SHA256将盐和用户特定信息进行加密来验证用户的真实性；中间的部分才是真正的用户信息，这部分的加密通常是可逆的比如base64加密，所以仍然不能用户存储重要信息。通常客户端收到JWT后会进行本地存储，然后在每次进行访问的时候将其加在请求的某个地方，通常是和Authorization的首部之中。 总结Cookie&#x2F;Session&#x2F;Token的区别Cookiecookie是一种具体的session实现，是浏览器实现的一种数据存储功能，由于在客户端实现浏览器对其进行了一定的限制。 Session通过上述讨论，我们知道其实session就是一个会话记录，用于区分用户，服务器会临时保存用户的信息用于验证，采用的方法对浏览器来说大多是cookie，但也可以采用别的方式。缺点是： 每次用户请求都需要存储一个session记录，用户数量很多的情况下内存开下巨大 可扩展性较小，多台服务器难以平行扩展，通常需要配置Memcahced专门有一台Session服务器 CORS（跨域资源共享）难以实现，因为cookie并不能跨域使用，需要很多额外配置 CSRF（跨站请求伪造），即用户访问恶意网站被强制执行攻击性代码访问合法网站进行操作，很容易经由cookie实现。 TokenJWT术语Token的一种实现，Token具有如下优点： 无状态、可扩展，不需要服务器存储信息，只需要服务器直到加密算法即可，用户多了可以直接加机器 支持移动设备 跨程序调用，能够和其他设备、APP共享权限 安全，每次客户端请求都需要开发者手动将token放在header中带过去，这就使之不会遭受CSRF攻击 Go框架两种认证方式的具体实现Cookie的使用\\todo Token的使用\\todo 关于Go的跨域\\todo","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"Cookie","slug":"Cookie","permalink":"https://kimanyang.xyz/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"https://kimanyang.xyz/tags/Token/"},{"name":"Session","slug":"Session","permalink":"https://kimanyang.xyz/tags/Session/"},{"name":"身份认证","slug":"身份认证","permalink":"https://kimanyang.xyz/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"}]},{"title":"卡尔曼滤波","slug":"卡尔曼滤波","date":"2022-03-19T15:52:33.000Z","updated":"2022-03-27T11:27:20.055Z","comments":true,"path":"2022/03/19/卡尔曼滤波/","link":"","permalink":"https://kimanyang.xyz/2022/03/19/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/","excerpt":"","text":"卡尔曼滤波由于最近要阅读分布式卡尔曼滤波观测器相关的论文，在这里先总结一个基本款的卡尔曼滤波器以及一个扩展滤波器的推导，参考视频教程https://www.bilibili.com/video/BV1ez4y1X7eR。 卡尔曼滤波推导给定状态空间方程：其中是过程噪声，是测量噪声。 我们假定过程噪声满足正态分布，测量噪声也满足正态分布。 由于期望为0，所以协方差矩阵满足：以一个二维的噪声为例：由于均值为0，，于是乎：由于我们没办法给噪声建模，只能根据物理模型和测量结果来对系统状态进行判断：$$\\hat{x}k^-=A\\hat{x}{k-1}+Bu_{k-1} \\z_k = Hx_{km} \\implies \\hat{x}_{km}=H^{-1}z_k\\notag$$其中$\\hat{x}k^-$是先验结果，是我们根据上一次的估计值计算出来的结果，是不带噪声的真实结果而，是测量矩阵，我们用测量值去估计真实值得出的结果就是$\\hat{x}{km}。由于噪声的存在我们得到的两结果都不是真实的，在这里需要用到数据融合：其中K_kH\\in(0,I)，如果它更接近I$则我们更相信测量结果，如果它更接近0则我们更相信计算出来的先验结果。 现在我们的目标转变为寻找一个好的——这被称为卡尔曼增益——从而使得估计值更加接近实际值。 定义实际值与估计值之间的误差为，假设估计误差符合均值为0的正态分布，，那么根据我们之前的推导有：（由于我们所有操作都是线性变换，过程噪声的误差包含其中计算之后仍然是均值为零的正态分布【mark】自己要算一下） 有了这个假设，我们就拥有了对估计结果的criteria，即选取卡尔曼增益使得误差的协方差矩阵的迹尽可能地小。协方差越小则误差更加向均值0集中，则我们的估计结果越好。迹即对角线的和，最小化迹对于协方差矩阵来说便是最小化每个均方差的平方和。 将代入对计算结果进行展开，引入原始模型噪声：结果代入之中：要注意到在这条式子之中随机变量仅仅有先验误差和测量噪声，在实际之中我们通常认为这两者相互独立（【mark】这一步我没有完全理解，需要进行计算验证或其他背景知识） 继续上式的展开，有对称性消去交叉项：$$\\begin{aligned}P &amp;= (I-K_kH)Ee_k^-e_k^{-t}^T+K_kE[v_kv_k^T]K_k^T \\&amp;=(P_k^–K_kHP_k^-)(I-H^TK_k^T)+K_kRK_k^T \\&amp;=P_k^–K_kHP_k^–P_k^-H^TK_k^T+K_kHP_k^-H^TK_k^T\\&amp;+K_kRK_k^T\\end{aligned}\\notag其中为先验误差的协方差矩阵，为测量噪声的协方差矩阵。现在我们要做的是最小化，下面计算的迹，注意到互为转置矩阵的两个矩阵迹相等：\\notag对矩阵关于进行求导来求取最小值（当然如果为了严谨得考虑这个函数是一个凸函数，局部最优是全局最优，这里就不加证明了），注意到协方差矩阵为对称矩阵：\\notag$$**remark:**矩阵求导的一些个小结论 自此我们推出了卡尔曼增益的表达式：通常来讲观测矩阵是满秩的、噪声误差和先验估计的协方差矩阵不会是奇异的，卡尔曼增益是有解的。 如果噪声特别大，那么噪声协方差矩阵很大，这会导致更趋向于零矩阵，于是更相信我们计算出来的先验结果 如果噪声特别小，那么结果接近，意味着我们更相信测量出来的结果 现在还有一个问题，我们并不知道是多少。现在将其展开：$$\\begin{aligned}e_k^-&amp;=x_k-\\hat{x}k^- \\&amp;=Ax_k+Bu{k-1}+w_{k-1}-A\\hat{x}{k-1}-Bu{k-1} \\&amp;=A(x_{k-1}-\\hat{x}{k-1})+w{k-1} \\&amp;=Ae_{k-1}+w_{k-1}\\end{aligned}\\notag将上式代入到之中得到：\\notag$$自此我们可以给出卡尔曼滤波器每一步的计算流程： 预测步骤，利用上一步的结果做先验计算： 计算状态先验估计：$\\hat{x}k^-=A\\hat{x}{k-1}+Bu_{k-1}$ 计算先验协方差矩阵： 矫正步骤，通过测量的结果对正式估计结果进行矫正： 计算卡尔曼增益： 给出最后的后验估计： 更新步骤：对本次计算的和估计进行保存，留作下次使用 算法在实现上是十分简洁明了的，但是在推导过程中利用的数据融合思想、迭代算法思想、最优化思想、动态规划思想的使用都十分巧妙。 当然我们还剩下最后的一点问题： 迭代算法的初值以及噪声的协方差矩阵需要给出，目前的算法是随便估计一下，的初值一般取单位阵 卡尔曼滤波器针对的系统是线性系统，滤波器本身也是线性滤波器 扩展卡尔曼滤波器扩展卡尔曼滤波器（Extended Kalman Filter, EKF)针对卡尔曼滤波器只能应用于线性系统方面做出了改进，能够适应非线性系统。 考虑系统：这里的主要问题是经过非线性变换的噪声不一定符合正态分布，扩展卡尔曼滤波采用最简单的泰勒展开局部线性化进行处理。 由于系统有误差，我们无法在真实点进行泰勒展开，于是退而求其次令在上一次的后验估计$\\hat{x}{k-1}处进行线性化。展开如下：$x_k=f(\\hat{x}{k-1},u_{k-1},w_{k-1})+J_A(x_{k-1}-\\hat{x}{k-1})+J_Ww{k-1}\\notag$$由于误差不可得在非线性项里将其近似为0，和为雅可比矩阵，具体参考非线性控制章节的MIMO系统局部线性化。 同样我们对观测函数在进行局部线性化：$$z_k = h(\\tilde{x}_k,v_k)+J_H(x_k-\\tilde{x}k)+J_Vv_k$$由于误差$v{k-1}不可得在非线性项里将其近似为，J_H=\\frac{\\partial h}{\\partial x}和J_V=\\frac{\\partial h}{\\partial v}$为雅可比矩阵。 于是我们的到线性化的系统：$$\\begin{aligned}x_k &amp;= \\tilde{x}{k-1}+J_A(x{k-1}-\\hat{x}{k-1})+J_Ww{k-1} \\z_k &amp;= \\tilde{z}{k-1}+J_H(x_k-\\tilde{x}{k-1})+J_Vv_k\\end{aligned}$$其中$\\tilde{x}{k-1}=f(\\hat{x}{k-1},u_{k-1},0)，\\tilde{z}{k-1}=h(\\tilde{x}{k-1},0)。其中发现有一项x_k-\\tilde{x}_{k-1}$不是很和谐，这就是我们对展开点做出取舍之后的结果，在小范围内仍然有效。 经过这种近似变换，误差的分布仍然是高斯分布，不过相比原来多了一部分区别：有了局部线性化，接下来跟着传统卡尔曼滤波的流程走一遍; 预测步骤，利用上一步的结果做先验计算： 计算状态先验估计 $\\hat{x}k^-=f(\\hat{x}{k-1},u_{k-1},0)$ 计算先验协方差矩阵 矫正步骤，通过测量的结果对正式估计结果进行矫正： 计算卡尔曼增益： 给出最后的后验估计： 更新步骤：对本次计算的和估计进行保存，留作下次使用 自此扩展卡尔曼滤波器介绍完毕。","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"卡尔曼滤波","slug":"卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"扩展卡尔曼滤波","slug":"扩展卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"优化算法","slug":"优化算法","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"}]},{"title":"MPC模型预测控制推导与实现","slug":"MPC模型预测控制推导","date":"2022-03-16T03:07:33.000Z","updated":"2022-03-27T11:27:20.380Z","comments":true,"path":"2022/03/16/MPC模型预测控制推导/","link":"","permalink":"https://kimanyang.xyz/2022/03/16/MPC%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"MPC模型预测控制推导与实现考虑MIMO控制系统，给定代价函数给定正定的和，设计控制器使得代价函数最小。 上述的建模即最基本的最优化控制理念，下面我们考虑模型预测控制。 模型预测控制概念通过模型预测系统在某一段时间内的表现来进行优化控制即模型预测控制(Model Prediction Control)。这种控制方法多用于数位控制，采用离散型的状态空间模型来进行表达：对于一次控制来说，大致有三个步骤，在时刻： 估计、测量当前的系统状态 基于来进行最优化控制:其中状态的未来N个时刻的范围为预测窗口/区间(Predictive Horizon)，控制器输出的未来N个时刻为控制窗口(Control Horizon)，为最终误差项，即预测最末时刻误差代价函数。 仅取作为我们的控制量输出，即每次输出都需要将控制窗口和预测窗口向右移动来进行新一轮计算和控制输出 简单来说就是在每一步都求解一个优化问题，这对控制器计算能力要求十分高；除此以外优化问题还需要进一步考虑系统的约束条件。 二次规划（Quadratic Programming)最优化建模二次规划是常见的凸问题，将代价函数设计为二次规划函数进而求取最小化凸代价函数是常见的一种策略，其基本形式。其中正定。继续考虑我们的离散系统，在时刻定义：$$\\begin{aligned}\\hat{X}_k&amp;=[x(k|k),x(k+1|k),\\cdots,x(k+N|k)]^T \\\\hat{U}k&amp;=[u(k|k),u(k+1|k),\\cdots,u(k+N|k)]^T\\end{aligned}作为状态预测与控制输出预测矩阵。出于简单考虑，定义输出函数即为状态，参考输入为，则基于二次规划的代价函数可以定义为：\\begin{aligned}J&amp;=\\sum^{N-1}{i=0}(x(k+i|k)^TQx(k+i|k)+u(k+i|k)^TRu(k+i|k))\\&amp;+x(k+N|k)^TFx(k+N|k)\\end{aligned}由于我们的优化变量是，所以需要消除代价函数中的项，一种直观的想法是采用迭代计算：通过前面定义的状态预测矩阵和化简上述公式：\\hat{X}_k=x_k+\\hat{U}_k将上述式子简化：\\label{sim}\\begin{aligned}&amp;M\\triangleq ^T \\&amp;C\\triangleq\\\\hat{X}k&amp;=Mx_k+C\\hat{U_k}\\end{aligned}进一步化简我们的代价函数：\\label{costmat}\\begin{aligned}J&amp;=\\sum^{N-1}{i=0}(x(k+i|k)^TQx(k+i|k)+u(k+i|k)^TRu(k+i|k))\\&amp;+x(k+N|k)^TFx(k+N|k) \\&amp;=\\hat{X_k}^T\\hat{X}_k + U_k^TU_k\\&amp;=\\hat{X}_k\\bar{Q}_F\\hat{X}_k+U_k^T\\bar{R}U_k\\end{aligned}将式子代入中可得：$$其中, , 至此代价函数的形式转换为一个标准的二次规划形式问题，包括一个常数项、线性项和二次项。 代码实现由上述的模型预测控制推导，给出如下核心代码： 123456789101112131415161718192021222324252627282930313233343536373839function [M,C,Q_bar,R_bar,G,E,H,U_k] = MPC_Zero_Ref(A,B,N,x_k,Q,R,MPC_Zero_RefmyFun)n = size(A,1); % 获取矩阵的维度np = size(B,2); % 获取控制输入的维度pM = [eye(n);zeros(N*n,n)]; % 初始化 M 矩阵，单位阵+0部分C = zeros((N+1)*n, N*p); % 初始化 C 矩阵tmp = eye(n);for i=1:N rows = i * n + (1:n); % 当前要填满的其实行数 C(rows,:)=[tmp*B,C(rows-n,1:end-p)]; tmp = A*tmp; M(rows,:)=tmp;end% 定义Q_bar和R_barS_q = size(Q,1) % 获取 Q 的维度S_r = size(R,1) % 获取 R 的维度Q_bar = zeros((N+1)*S_q, (N+1)*S_q); % 初始化 Q_bar 矩阵% 获得 Q_barfor i:=0:N Q_bar(i*S_q + 1:(i+1)*S_q,i*S_q+1:(i+1)*S_q)=Q; end% 获得 R_barfor i=0:N-1 R_bar(i*S_r+1:(i+1)*S_r,i*S_r+1:(i+1)*S_r)=R;end% 求解所需矩阵 G E HG = M' *Q_bar*M;E = C' *Q_bar*M;H = C' *Q_bar*C+R_bar;% 二次规划问题最优化求解f = (x_k' * E')';U_k = quadprog(H,f); end","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"模型预测控制","slug":"模型预测控制","permalink":"https://kimanyang.xyz/tags/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/"},{"name":"matlab","slug":"matlab","permalink":"https://kimanyang.xyz/tags/matlab/"},{"name":"二次规划","slug":"二次规划","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/"}]},{"title":"多智能体相关代数图论知识总结","slug":"图论知识总结","date":"2022-03-15T02:12:33.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/03/15/图论知识总结/","link":"","permalink":"https://kimanyang.xyz/2022/03/15/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"图论知识总结本文的 图和图模型术语总结 部分是离散数学中的基础知识，方便 多智能体相关的代数图论 部分随时查阅。文章旨在快速总结补全阅读多智能体领域论文的基础图论知识。 图和图模型术语总结图的类型 类型 边 允许多重边 允许环 简单图 无向 否 否 多重图 无向 是 否 伪图 无向 是 是 简单有向图 有向 否 否 有向多重图 有向 是 是 混合图 有向和无向 是 是 完全图 无向 否 否 所谓多重边指的是两个顶点间存在多条连接的边 所谓完全图指的是任意两个顶点之间都存在直接通路的简单无向图 图的基本术语定义 若和是无向图中的一条边的端点，则称两个顶点和在里邻接。这样的边称为关联顶点和，也可以说连接和 在图中，顶点的所有相邻集合，记作，称为顶点的邻居。若是的子集，则表示图中至少和中一个定点相邻的所有顶点的集合，即 在无向图中，顶点的**度(degree)**指的是与该顶点相关联的边的数目（但顶点上的环为其做出双倍贡献），顶点的度记作 当是带有有向边的图的边时，说邻接到，而且说从邻接，顶点称为的起点，顶点称为的终点，环的起点和终点是相同的 在带有有向边的图里，顶点的入度记作，指以作为终点的边数，顶点的出度记作，是以作为起点的边数 若把简单图的顶点集分成两个不相交的非空集合和，使得图中每一条边都连接中的一个顶点与中的一个顶点（因此中没有边连接中的两个顶点或两个顶点），则称为二分图，称为的一个二分划分 平衡图指每个顶点的出度和入度都相等的图 定理 设是有条边的无向图，则 无向图有偶数个度为奇数的顶点（由1可直接推出） 设是带有有向边的图，那么有： 一个简单图是二分图当且仅当能够对图中每一个顶点赋予两种不同的颜色（算法搜索遍历染色判断二分图） 图的构造相关定义 图的真子图是图，其中且。若，则称图的子图是的真子图 令是一个简单图，图是由顶点集的子集导出的子图，其中边集包含中的一条边当且仅当这条边的两个顶点都在中 图的构造方法 删除或增加图中的边 边的收缩：删除顶点和之间的边后吧两个顶点合并 从图中删除顶点：删除顶点同时移除与之相关联的边 图的并集 连通性通路定义：形式化不给了，非形式化：通路是边的序列，从一个顶点开始沿着边行进到相邻顶点，如果通路不包含相同的边则成为简单通路。如果一条通路开始和结束都是相同的顶点则称为回路 连通性定义： 若无向图每一对不同的顶点之间都有通路则称该图是连通的，否则为不连通的。连通无向图的每一对不同顶点之间都存在简单通路。 若对于有向图中的任意顶点和，都有从到的通路，则该图是强连通的。若有向图的基本无向图（去掉边的方向）是连通的，那么有向图弱连通。 欧拉通路定义图的欧拉回路是包含每一条边的简单回路。图中的欧拉通路是包含的每一条边的简单通路。 充要条件 至少有两个顶点的图具有欧拉回路当且仅当它每个顶点的度都为偶数。 连通多重图具有欧拉通路但无欧拉回路当且仅当它恰有两个度为奇数的顶点。 生成树定义：如果是简单图，则的生成树是包含每个顶点的的子图且为树。有生成树的图必然是联通的，每个连通图也必然有生成树。关于连通定义见连通性一节。 多智能体相关的代数图论多智能体的一致性和多智能体之间的交流结构密切相关，这些交流结构的抽象就是图。 图矩阵一张图G的结构和属性可以通过研究和G相关的矩阵来揭示，这就是代数图论（algerbraic graph theory）。一个N节点的G中边的权重系数可以构成一个邻接矩阵（adjacency matrix）：在多智能体中采用的通常是带权有向图，于是邻接矩阵不一定是对称的。如下图所示的两个顶点，图中所有的边集称为，如果顶点之间的边，则；否则。默认每个节点知道自己的信息，不需要和自己通信，所以有对角元素。 定义一个顶点的加权入度(weighted in-degree)为的第行所有元素之和：$$\\label{indegree}d_i=\\sum^{N}{j=1}a{ij}$$定义节点的加权出度(weighted out-degree)为的第列所有元素之和： Laplacian矩阵拉普拉斯(Laplacian)矩阵，即矩阵在多智能体体系中十分重要。 首先定义入度矩阵，表示以加权入度元素作为主对角线元素的对角矩阵。 矩阵定义为：。 直观上感受一下一个矩阵和矩阵： 写出其邻接矩阵：根据的定义，于是矩阵如下：从其定义可以看出矩阵每一行的所有元素之和为0。 矩阵的特征值和特征向量实数矩阵能够转换为若当标准型，变换矩阵为其左右特征向量组成的矩阵，这部分基础知识不再赘述。由于矩阵行的和为0，有：其中，，c为任意非零常数。 由此我们可以得出矩阵的一个特征值为0，特征向量为。 给出如下一个定理：如果有生成树，则的稚为，有且仅有一个相对应的右特征向量。 我们对几种图的矩阵进行总结： 由于L矩阵行和为0，所有图的第一个特征值都为0 对于所有无向图，其特征值都为实数 N节点完全图的所有非零特征值为 有向树的所有非零特征值 有向N循环图的N个特征值均匀分布在以（1,0）为圆心，1为半径的圆上，且第一个特征值为0 矩阵及代数图论几个引理：有向图至少有一个零特征值，其特征向量为且所有的非零特征值都具有正实部。如果图有有向生成树，则代数重数为1且是唯一的。 对于无向图来说，矩阵的特征值代数重数为1当且仅当图是联通的。最小的非零特征值：对于无向图，如果我们已知是半正定的，那么我们不难验证如下的平方和性质(SOS-property)：其中表示向量的第个分量。对于强连通图和有向平衡图来说，拉普拉斯矩阵正定的条件是满足的，证明略。 进一步我们讨论拉普拉斯矩阵是一个一般的奇异阵的情况，可以获得如下的一些结论。 如果图是强连通的，那么其拉普拉斯矩阵的零特征值存在一个正的左特征向量，且满足：其中。 对于一个强连通图及其拉普拉斯矩阵，我们定义其广义代数连通性：其中和的定义在中已经给出。对于平衡图，我们有：其中是提取括号内的最小非零特征值。 拉普拉斯矩阵对于多智能体的一致性考察十分有用。 假设有、图的邻接矩阵、拉普拉斯矩阵。对于闭环系统，定义一致性为，这种一致性满足当且仅当具有有向生成树。进一步的，最终一致时收敛的值可以由给出，其中是正则化的拉普拉斯矩阵零特征值左特征向量。 除了我们定义的拉普拉斯矩阵，拉普拉斯矩阵可以写作另外一种形式：。如果存在某一个顶点入度为0，那么是奇异矩阵，我们令来使之满足矩阵定义。我们将和称为正则化的邻接矩阵和拉普拉斯矩阵。 正则化的拉普拉斯矩阵具有一个以为右特征向量的零特征值，且所有的特征值都分布在以(1,0)为圆心，1为半径的复平面圆盘上。进一步的，0的代数重数为1当且仅当图具有有向生成树。 随机矩阵对于求解离散多智能体问题来说更加便利。对于一个具有个节点的有向图，其行随机矩阵被定义为，我们定义如果 则，，否则矩阵项为0，同时满足。对于无向图也可以类似的进行定义不过其随机矩阵是一个对称矩阵，这意味着它同时是行随机矩阵和列随机矩阵。显然随机矩阵的行和是1，那么显然它具有特征值1且与之相关的特征向量是。 由盖尔圆盘定理可以得知的所有特征值，要么在以原点为中心的开单位圆盘上，要么等于1。进一步的，当且仅当图具有有向生成树时1的代数重数为1。 假设，那么对于闭环的离散系统来说，一致性可以定义为。其中且时所有顶点的入度中最大的，这种一致性能够满足当且仅当图具有有向生成树。进一步的，最终一致时收敛的值可以通过得到，其中是正则化的特征向量，其特征值为1。","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"多智能体","slug":"多智能体","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"},{"name":"图论","slug":"图论","permalink":"https://kimanyang.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"一致性","slug":"一致性","permalink":"https://kimanyang.xyz/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"}]},{"title":"JS中正则表达式使用总结","slug":"JS中正则表达式使用总结","date":"2022-03-13T04:15:14.000Z","updated":"2022-03-13T05:26:57.134Z","comments":true,"path":"2022/03/13/JS中正则表达式使用总结/","link":"","permalink":"https://kimanyang.xyz/2022/03/13/JS%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"JS中正则表达式使用总结详细的规则参考MDN文档：正则表达式 - JavaScript | MDN (mozilla.org)。 好用的正则工具：在线正则表达式测试 (oschina.net) 使用方法在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。 脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用预先定义的正则规则可获得更好的性能。 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。语法：regexObj.exec(str) test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。语法：regexObj.test(str) match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。语法：str.match(regexp) matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。语法：str.matchAll(regexp) search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。语法：str.search(regexp) replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。语法：&#96;str.replace(regexp split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。语法：str.split([separator[, limit]]) 元字符 边界符（表示匹配边界），^表示开头，$表示结尾 量词（表示重复次数） 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n次到m次（左闭右闭） 字符类（表示特定字符集），[]匹配字符集合，诸如 /[aeiou]/,元音集合 /[a-z]/,/[a-zA-Z]/,/[0-9]/小写字母、大小写数字 [^aeiou],[^a-z]非元音，非小写字母 .通配符，匹配任意字符 x|y选择符，匹配x或y 预定类 说明 \\d 匹配0-9之间的任意数字，[0-9] \\D 匹配所有0-9以外的字符，[^0-9 ] \\w 匹配任意字母、数字和下划线，[A-Za-z0-9_] \\W 匹配任意字母、数字和下划线以外，[^A-Za-z0-9_] \\s 匹配空格（换行符、制表符和空格），[\\t\\r\\n\\v\\f] \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f] 经典例子： 用户名验证：英文字母、数字、下划线和短横线组成的6-16位用户名/^[a-zA-Z0-9-_]&#123;6,16&#125;$/ 用户只能输入中文：/^[\\u4e00-\\u9fa5]+/ 日期格式：^/\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;/ 高级特性 捕获：(xyz)|(abc)，匹配并记忆整个括号中的内容，使得后面的作用符作用于前面的整个表达式 非捕获：(?:foo)+ 12345678let personList = `First_Name: John, Last_Name: DoeFirst_Name: Jane, Last_Name: Smith`;let regexpNames = /First_Name: (\\w+), Last_Name: (\\w+)/mg;let match = regexpNames.exec(personList);do &#123; console.log(`Hello $&#123;match[1]&#125; $&#123;match[2]&#125;`);&#125; while((match = regexpNames.exec(personList)) !== null); ​ 上述代码的(\\w+)采用非捕获(?:\\w+)则不会输出$&#123;match[1]&#125;和$&#123;match[2]&#125;，但是性能会相应提高 正向否定查找：x(?!y)，仅当x后不跟着y时匹配x 反向否定查找：(?&lt;!y)，仅当x前面不是y时匹配x 先行断言：x(?=y)，仅当x后面跟着y时匹配x 后行断言：(?&lt;=y)x，仅当x前面跟着y时匹配x 使用组与命名组 12345678910111213141516let users= `姓氏: 李, 名字: 雷姓氏: 韩, 名字: 梅梅`;let regexpNames = /姓氏: (?&lt;first&gt;.+), 名字: (?&lt;last&gt;.+)/mg;let match = regexpNames.exec(users);/* [ &quot;姓氏: 李, 名字: 雷&quot;, &quot;李&quot;, &quot;雷&quot; ] groups: first:&quot;李&quot; last:&quot;雷&quot; index:0 length:3*/ 标志位 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 s 允许 . 匹配换行符。 u 使用unicode码的模式进行匹配。 y 执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/tags/Javascript/"}]},{"title":"BOM对象相关","slug":"BOM对象相关","date":"2022-03-11T07:38:19.000Z","updated":"2022-03-13T05:26:26.601Z","comments":true,"path":"2022/03/11/BOM对象相关/","link":"","permalink":"https://kimanyang.xyz/2022/03/11/BOM%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3/","excerpt":"","text":"BOM对象相关基本概念 BOM(Browser Object Model ) 是浏览器对象模型 window 是浏览器内置中的全局对象，我们所学习的所有 Web APIs 的知识内容都是基于 window 对象实现的 window 对象下包含了 navigator、location、document、history、screen 5个属性，即所谓的 BOM （浏览器对象模型） document 是实现 DOM 的基础，它其实是依附于 window 的属性。 依附于 window 对象的所有属性和方法，使用时可以省略 window 定时器-延时函数和之前所学的setInterval不同 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeou 语法let timer = setTimeout(回调函数, 等待毫秒数) 清除延时函数语法： clearTimeout(timer) 可用于诸如5秒广告消失之类的需求 小技巧，可以通过递归调用来实现类似setInterval的功能： 1234567let myInterval = () =&gt; &#123; //do something repeated //... //recursive call setTimeout(myInterval,1000);&#125;myInterval() 两种定时器对比： setInterval 的特征是重复执行，首次执行会延时 setTimeout 的特征是延时执行，只执行 1 次 setTimeout 结合递归函数，能模拟 setInterval 重复执行 clearTimeout 清除由 setTimeout 创建的定时任务 JS执行机制简述同步与异步机制 同步机制在主线程上执行，形成执行栈 异步任务通过回调函数实现，存在三种类型： 普通事件：click/resize等 资源加载：load&#x2F;error等 定时器，包括setInterval/setTimeout 异步任务相关添加到任务队列中，任务队列也成为消息队列 更详细的内容参考另一篇博文Promise与异步模型 location对象其数据类型是对象，拆分保存了url地址的各个组成部分。location对象的常用属性和方法如下： href属性获取完整的url地址，对其赋值时用于地址的跳转 用例：五秒延时后转到同域下另一个界面 1setTimeout(()=&gt;&#123;location.href=&#x27;页面链接&#x27;&#125;, 5000) search属性获取地址中携带的参数，即?后的部分 hash属性获取地址的哈希值，即符号#后的部分 reload方法用于刷新当前页面，传入参数true时表示强制刷新 navigator对象其数据类型是对象，几率了浏览器自身的相关信息，最常用的用途是通过userAgent检测浏览器版本和平台来决定渲染的页面。 1234567891011// 检测 userAgent（浏览器信息）!(function () &#123;const userAgent = navigator.userAgent// 验证是否为Android或iPhoneconst android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)// 如果是Android或iPhone，则跳转至移动站点if (android || iphone) &#123;location.href = &#x27;http://m.itcast.cn&#x27;&#125;&#125;)() *关于匿名函数调用：javascript 函数前面的一元操作符 (colobu.com)*，这是一种消除编译器歧义的方法。 history对象用于和浏览器地址栏的操作相对应的一些操作，比如前进、后退、历史记录等等，常用的属性方法： history对象方法 作用 back() 后退 forward() 前进 go() 传入参数n为正就前进n步，负就后退n swiper插件的使用本地存储(sessionStorage)的使用localStorage 生命周期永久生效，除非手动删除 否则关闭页面也会存在 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 使用方法： 123localStorage.setItem(key, value)//存储数据localStorage.getItem(key) //获取数据localStorage.removeItem(key) //删除数据 sessionStorage 生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 以键值对的形式存储使用 用法跟localStorage 基本相同","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/tags/Javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-08T15:35:06.928Z","updated":"2022-03-08T15:35:06.929Z","comments":true,"path":"2022/03/08/hello-world/","link":"","permalink":"https://kimanyang.xyz/2022/03/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"DOM-事件相关(3)","slug":"DOM-事件相关(3)","date":"2022-03-08T10:11:14.000Z","updated":"2022-03-10T15:37:53.571Z","comments":true,"path":"2022/03/08/DOM-事件相关(3)/","link":"","permalink":"https://kimanyang.xyz/2022/03/08/DOM-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3(3)/","excerpt":"","text":"DOM事件相关(3)滚动事件scroll事件在页面进行滚动的时候触发，用于监听整个页面的滚动，个人感觉可以拿来做懒加载。除此以外还有一些网页需要检测用户页面滚动到某个区域之后进行一些处理，比如固定导航栏或返回顶部等。 使用方法： 12345678//整个页面,document也可以window.addEventListener(&#x27;scroll&#x27;,()=&gt;&#123; //do somthing&#125;)//某个元素ele.addEventListener(&#x27;scroll&#x27;,()=&gt;&#123; //do somthing&#125;) 加载事件load事件实在外部资源（图片、外联CSS、外联JS）加载完毕时进行触发。老旧代码的script写在头部此时时没办法访问body的DOM元素的，于是有了： 123456&lt;script&gt; window.addEventListener(&#x27;load&#x27;, function () &#123; let div = document.querySelector(&#x27;div&#x27;) console.log(div) &#125;) &lt;/script&gt; 的过时写法。 另外有DOMContentLoaded事件，给 document 加该事件,当初始的 HTML 文档被完全加载和解析完成 之后DOMContentLoaded 事件被触发，而无需等待样式 表、图像等完全加载。 元素大小与位置的获取方法scroll系列 获取宽高： 获取元素内容的总宽高（不包含滚动条），返回值不带单位 scrollWidth和scrollHeight属性 获取位置： 获取元素往左和往上滚动出去看不到的距离 scrollLeft和scrollTop 这两个属性可修改 具体使用方法： 123456window.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123; // 在得到页面滚动的距离 scrollTop console.log(document.documentElement.scrollTop) //直接固定了页面滚动距离，其他东西看不见 // document.documentElement.scrollTop = 500&#125;) offset系列使用场景：滚动到某个元素就做某些事，而不是像scroll属性一样需要算好位置才能够做某些事 获取宽高 获取元素自身宽高、包含元素自身设置的宽高、padding、border offsetLeft和offsetHeight 获取位置 获取元素距离自己定位父级的元素左上距离 无定位则以 文档左上角 为准 offsetLeft和offsetTop是只读属性 案例：固定导航栏 当页面滚动到秒杀模块的时候导航栏自动滑入，否则滑出 使用页面滚动事件 检测页面滚动 大于等于 模块位置 则滑入，否则滑出 模板代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .nav &#123; position: fixed; display: none; width: 100%; height: 40px; font-size: 20px; font-weight: 700; line-height: 40px; text-align: center; background-color: blueviolet; z-index: 99; &#125; .content &#123; position: relative; width: 100%; height: 8000px; background-color: pink; &#125; .trigger &#123; position: absolute; top:700px; width: 590px; height: 590px; background-color: blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt;这里是导航栏&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;trigger&quot;&gt;出发点&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 脚本实现： 12345678910let nav = document.querySelector(&#x27;.nav&#x27;)let trigger = document.querySelector(&#x27;.trigger&#x27;)window.addEventListener(&#x27;scroll&#x27;, (e) =&gt; &#123; if(document.documentElement.scrollTop &gt;= trigger.offsetTop) &#123; nav.style.display = &#x27;block&#x27; &#125; else &#123; nav.style.display = &#x27;none&#x27; &#125;&#125;) client系列 获取宽高 获取元素可见部分（不包含边框和滚动条等）的宽高 clientWidth和clientHeight 获取位置 获取左边框和上边框宽度 clientLeft和clientTop是只读属性 典型应用：背景窗口变化时触发事件（变色、布局）123456789101112window.addEventListener(&#x27;resize&#x27;, function () &#123; // console.log(111) let w = document.documentElement.clientWidth // console.log(document.documentElement.clientWidth) if (w &gt;= 700) &#123; document.body.style.backgroundColor = &#x27;pink&#x27; &#125; else if (w &gt; 540) &#123; document.body.style.backgroundColor = &#x27;hotpink&#x27; &#125; else &#123; document.body.style.backgroundColor = &#x27;deeppink&#x27; &#125;&#125;) 经典案例：轮播图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; li &#123; list-style: none; &#125; .main &#123; width: 700px; margin: auto; background: #000; &#125; .slides &#123; height: 320px; position: relative; &#125; .slides ul li &#123; /* display: none; */ position: absolute; top: 0; left: 0; opacity: 0; /* 这里实现淡入淡出的关键 */ transition: all .3s; &#125; /*权重20*/ .slides .active &#123; /* display: block; */ opacity: 1; &#125; /*定位，无所谓高度，还挺好的*/ .slides .extra &#123; width: 700px; height: 53px; line-height: 53px; position: absolute; bottom: 0px; background-color: rgba(0, 0, 0, 0.8); z-index: 10; &#125; .slides .extra h3 &#123; width: 82%; margin: 0; margin-right: 20px; padding-left: 20px; color: #98E404; font-size: 28px; float: left; font-weight: 500; font-family: &quot;Microsoft Yahei&quot;, Tahoma, Geneva; &#125; .slides .extra a &#123; width: 30px; height: 29px; display: block; float:left; margin-top: 12px; margin-right: 3px; background-image: url(./assets/icon_focus_switch.png); &#125; /*精灵图样式切换*/ .slides .extra .prev &#123; background-position: 0 0; &#125; .slides .extra .prev:hover &#123; background-position: -30px 0; &#125; .slides .extra .next &#123; background-position: -60px 0; &#125; .slides .extra .next:hover &#123; background-position: -90px 0; &#125; /*下方导航栏列表*/ .indicator ul &#123; margin-left: 4px; overflow: hidden; &#125; .indicator ul li &#123; position: relative; float: left; width: 60px; height: 60px; margin: 10px 4px 10px 5px; text-align: center; cursor: pointer; &#125; .indicator li img &#123; display: block; border: 0; text-align: center; width: 100%; height: 100%; &#125; /*下方轮播栏的激活显示*/ .indicator li .mask &#123; width: 60px; height: 60px; /*为了使其浮动至当前图片上方*/ position: absolute; top:0; left: 0; background-color: rgba(0, 0, 0, 0.4); &#125; .indicator li .border &#123; display: none; width: 54px; position: absolute; bottom: 0; left: 0; z-index: 10; border: 3px solid #98e404; &#125; /*激活样式*/ .indicator .active .mask &#123; display: none; &#125; .indicator .active .border &#123; display: block; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;slides&quot;&gt; &lt;ul&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_01.jpg&quot; alt=&quot;第1张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_02.jpg&quot; alt=&quot;第2张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_03.jpg&quot; alt=&quot;第3张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_04.jpg&quot; alt=&quot;第4张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_05.jpg&quot; alt=&quot;第5张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_06.jpg&quot; alt=&quot;第6张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_07.jpg&quot; alt=&quot;第7张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_08.jpg&quot; alt=&quot;第8张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_09.jpg&quot; alt=&quot;第9张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./assets/b_10.jpg&quot; alt=&quot;第9张图的描述信息&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;extra&quot;&gt; &lt;h3&gt;第1张图的描述信息&lt;/h3&gt; &lt;a class=&quot;prev&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;a class=&quot;next&quot; href=&quot;javascript:;&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;indicator&quot;&gt; &lt;ul&gt; &lt;li class=&quot;active&quot;&gt; &lt;img src=&quot;assets/s_01.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_02.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_03.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_04.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_05.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_06.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_07.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_08.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_09.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;assets/s_10.jpg&quot;&gt; &lt;span class=&quot;mask&quot;&gt;&lt;/span&gt; &lt;span class=&quot;border&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let curIdx = 0 let bigPicItems = document.querySelectorAll(&#x27;.slides ul li&#x27;) let smallPicItems = document.querySelectorAll(&#x27;.indicator ul li&#x27;) let text = document.querySelector(&#x27;.extra h3&#x27;) let nextBtn = document.querySelector(&#x27;.next&#x27;) let prevBtn = document.querySelector(&#x27;.prev&#x27;) let main = document.querySelector(&#x27;.main&#x27;) let total = smallPicItems.length /*鼠标经过操作*/ for(let i = 0;i &lt; total;i++) &#123; smallPicItems[i].addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123; bigPicItems[curIdx].classList.remove(&#x27;active&#x27;) smallPicItems[curIdx].classList.remove(&#x27;active&#x27;) smallPicItems[i].classList.add(&#x27;active&#x27;) bigPicItems[i].classList.add(&#x27;active&#x27;) text.innerHTML = `第$&#123;i+1&#125;张图的描述信息` curIdx = i &#125;) &#125; /*按钮操作*/ let shilftPic = (newIdx) =&gt; &#123; smallPicItems[newIdx].classList.add(&#x27;active&#x27;) bigPicItems[newIdx].classList.add(&#x27;active&#x27;) smallPicItems[curIdx].classList.remove(&#x27;active&#x27;) bigPicItems[curIdx].classList.remove(&#x27;active&#x27;) text.innerHTML = `第$&#123;newIdx+1&#125;张图的描述信息` curIdx = newIdx &#125; nextBtn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; let newIdx = (curIdx + 1) % total shilftPic(newIdx) &#125;) prevBtn.addEventListener(&#x27;click&#x27;,() =&gt; &#123; let newIdx = (curIdx - 1)&lt;0 ? (total - 1) : (curIdx - 1) shilftPic(newIdx) &#125;) /*定时器操作*/ let timer = setInterval(()=&gt;&#123;nextBtn.click()&#125;,1000) main.addEventListener(&#x27;mouseenter&#x27;,()=&gt;&#123; clearInterval(timer) &#125;) main.addEventListener(&#x27;mouseleave&#x27;,()=&gt;&#123; timer = setInterval(()=&gt;&#123;nextBtn.click()&#125;,1000) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 经典案例：手风琴看着挺帅的，但意外地挺好实现，重点在于transition属性的使用。 模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &lt;style&gt; ul &#123; list-style: none; &#125; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 1200px; height: 400px; margin: 50px auto; border: 1px solid red; overflow: hidden; &#125; div li &#123; width: 240px; height: 400px; float: left; transition: all 500ms; &#125; div ul &#123; width: 1200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/2.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/4.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;./images/5.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; 脚本： 1234567891011121314let lis = document.querySelectorAll(&#x27;li&#x27;)for (let i = 0; i &lt; lis.length; i++) &#123; lis[i].addEventListener(&#x27;mouseenter&#x27;, () =&gt; &#123; for (let j = 0; j &lt; lis.length; j++) &#123; lis[j].style.width = &#x27;100px&#x27; &#125; this.style.width = &#x27;800px&#x27; &#125;) lis[i].addEventListener(&#x27;mouseleave&#x27;, () =&gt; &#123; for (let j = 0; j &lt; lis.length; j++) &#123; lis[j].style.width = &#x27;240px&#x27; &#125; &#125;)&#125; 经典案例——电梯导航图这是对于scroll&#x2F;offset二者的综合应用，具体实现如下 模板： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .aside &#123; position: fixed; left: 0; top: 50%; transform: translateY(-50%); &#125; .item &#123; height: 40px; line-height: 40px; text-align: center; padding: 0 10px; cursor: pointer; &#125; .active &#123; background-color: red; color: #fff; &#125; .content &#123; width: 660px; margin: 400px auto; &#125; .neirong &#123; height: 300px; margin-bottom: 20px; color: #fff; &#125; .content1 &#123; background-color: red; &#125; .content2 &#123; background-color: blue; &#125; .content3 &#123; background-color: orange; &#125; .content4 &#123; background-color: yellowgreen; &#125;&lt;/style&gt; 脚本： 12345678910111213141516171819202122let items = document.querySelectorAll(&#x27;.aside .item&#x27;)let contents = document.querySelectorAll(&#x27;.content .neirong&#x27;)let total = contents.lengthlet curIdx = 0window.addEventListener(&#x27;scroll&#x27;, (e) =&gt; &#123; let curPos = document.documentElement.scrollTop; items[curIdx].classList.remove(&#x27;active&#x27;) for (let i = 0; i &lt; total; i++) &#123; curIdx = curPos &gt;= contents[i].offsetTop ? i : curIdx &#125; items[curIdx].classList.add(&#x27;active&#x27;)&#125;)for (let i = 0; i &lt; total; i++) &#123; items[i].addEventListener(&#x27;click&#x27;, () =&gt; &#123; items[curIdx].classList.remove(&#x27;active&#x27;) items[i].classList.add(&#x27;active&#x27;) curIdx = i document.documentElement.scrollTop = contents[curIdx].offsetTop &#125;)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"页面事件","slug":"页面事件","permalink":"https://kimanyang.xyz/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/"},{"name":"前端经典案例","slug":"前端经典案例","permalink":"https://kimanyang.xyz/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"}]},{"title":"DOM-事件相关(2)","slug":"DOM-事件相关(2)","date":"2022-03-07T08:28:14.000Z","updated":"2022-03-10T15:37:11.346Z","comments":true,"path":"2022/03/07/DOM-事件相关(2)/","link":"","permalink":"https://kimanyang.xyz/2022/03/07/DOM-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3(2)/","excerpt":"","text":"DOM-事件相关(2)事件对象 保存了事件相关信息（诸如鼠标位置、键盘码等等）的对象，作为回调函数的传参可以在回调事件中进行访问，命名约定俗称为event&#x2F;ev&#x2F;e等等 常用的事件对象属性： type：当前事件类型 clientX/clientY：当前光标相对于浏览器窗口左上角位置 offsetX/offsetY：当前光标相对于当前DOM元素左上角的位置 key：用户按下键盘值的值，当前不提倡使用keyCode 例子图片跟随： 鼠标在页面中移动，使用mousemove事件 鼠标的坐标位置付给图片的left和top(记得添加定位) 12345let img = document.querySelector(&#x27;img&#x27;)document.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123; img.style.left = e.pageX - 50 + &#x27;px&#x27; img.style.top = e.pageY - 40 + &#x27;px&#x27;&#125;) 回车发布信息 使用keydown或者keyup事件 判断key值是否为回车，处理事件和发布按钮事件相同 12345textarea.addEventListener(&#x27;keyup&#x27;, (e) =&gt; &#123; if (e.key === &#x27;Enter&#x27;) &#123; send.click() &#125;&#125;) 事件流 事件流指事件完整执行过程中的流动路径 页面中的div触发事件时会经历捕获阶段和冒泡阶段 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。 当一个元素触发事件后，**会依次向上调用所有父级元素的同名事件**。 事件冒泡是默认存在的。 事件捕获 DOM的根元素开始去执行对应的事件（外到里） 事件捕获需要专门指定 语法： 1DOM.addEventListener(事件类型，事件处理函数，捕获机制) 第三个参数默认false，若为true则为捕获阶段触发（很少用） L0事件监听只有冒泡没有捕获 阻止事件流默认行为诸如表单跳转、链接跳转的清除使用e.preventDefault() 非默认行为由于默认的冒泡模式存在，很容易导致对子元素的点击影响到父元素（比如父元素和子元素都有click，点了子元素导致父元素也触发） 很多时候需要阻止时间流动，于是得把事件限制在当前元素内 组织时间流动得对事件对象进行 语法event.stopPropagation() 示例： 12345678910111213 let fa = document.querySelector(&#x27;.father&#x27;) let son = document.querySelector(&#x27;.son&#x27;) fa.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; console.log(&#x27;我是爸爸&#x27;) // e.stopPropagation() &#125;)son.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; console.log(&#x27;我是儿子&#x27;) // e.stopPropagation()&#125;)document.addEventListener(&#x27;click&#x27;, function () &#123; console.log(&#x27;我是爷爷&#x27;)&#125;) 一些特殊事件的事件流 鼠标经过事件 mouseover和mouseout存在冒泡效果 即鼠标移动到元素上时会触发，移动到子元素上还会触发 mouseenter和mouseleave没有冒泡效果 仅仅在移动到自身的盒子时触发 事件委托事件委托是通过事件流的特征解决一些开发需求的技巧。 优点：通过给父级元素添加事件提高性能 原理：利用事件冒泡的特性 实现：事件对象可以获得真正触发事件的元素 事件流模型初看很没有道理，但是了解了传播原理之后真正利用事件event.target特性可以极大简化代码提高性能。一个例子，对于列表中的每一个元素要进行相同的处理（类似于tab菜单），以前的做法是循环为每一个元素添加相同事件的处理函数，现在仅仅需要对父元素进行事件的添加即可。 123456789101112131415 &lt;ul&gt; &lt;li&gt;我是第1个小li&lt;/li&gt; &lt;li&gt;我是第2个小li&lt;/li&gt; &lt;li&gt;我是第3个小li&lt;/li&gt; &lt;li&gt;我是第4个小li&lt;/li&gt; &lt;li&gt;我是第5个小li&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 不要每个小li注册事件了 而是把事件委托给他的爸爸 // 事件委托是给父级添加事件 而不是孩子添加事件 let ul = document.querySelector(&#x27;ul&#x27;) ul.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; e.target.style.color = &#x27;red&#x27; &#125;)&lt;/script&gt; 核心代码e.target获取触发事件的DOM对象模型。缺点是点父模型会触发所有子对象的事件。在该示例中可以通过直接设置li标签的color属性为黑（增加CSS权重）来使得子元素不继承父元素的样式。 一个例子：动态渲染表格这里采用的不再是每次点击针对性地渲染，而是将数据抽象为一个数据层，将显示抽象为视图层，即mvvc地思想进行页面渲染。 页面如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;h1&gt;新增学员&lt;/h1&gt; &lt;div class=&quot;info&quot;&gt; 姓名：&lt;input type=&quot;text&quot; class=&quot;uname&quot;&gt; 年龄：&lt;input type=&quot;text&quot; class=&quot;age&quot;&gt; 性别: &lt;select name=&quot;gender&quot; id=&quot;&quot; class=&quot;gender&quot;&gt; &lt;option value=&quot;男&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;女&quot;&gt;女&lt;/option&gt; &lt;/select&gt; 薪资：&lt;input type=&quot;text&quot; class=&quot;salary&quot;&gt; 就业城市：&lt;select name=&quot;city&quot; id=&quot;&quot; class=&quot;city&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;广州&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;曹县&quot;&gt;曹县&lt;/option&gt; &lt;/select&gt; &lt;button class=&quot;add&quot;&gt;录入&lt;/button&gt; &lt;/div&gt; &lt;h1&gt;就业榜&lt;/h1&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;薪资&lt;/th&gt; &lt;th&gt;就业城市&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt; 表单处理程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 数据层，接口获取 let arr = [ &#123; stuId: 1001, uname: &#x27;欧阳霸天&#x27;, age: 19, gender: &#x27;男&#x27;, salary: &#x27;20000&#x27;, city: &#x27;上海&#x27; &#125;, &#123; stuId: 1002, uname: &#x27;令狐霸天&#x27;, age: 29, gender: &#x27;男&#x27;, salary: &#x27;30000&#x27;, city: &#x27;北京&#x27; &#125;, &#123; stuId: 1003, uname: &#x27;诸葛霸天&#x27;, age: 39, gender: &#x27;男&#x27;, salary: &#x27;2000&#x27;, city: &#x27;北京&#x27; &#125;, ] let tbody = document.querySelector(&#x27;tbody&#x27;) let add = document.querySelector(&#x27;.add&#x27;) let uname = document.querySelector(&#x27;.uname&#x27;) let age = document.querySelector(&#x27;.age&#x27;) let gender = document.querySelector(&#x27;.gender&#x27;) let salary = document.querySelector(&#x27;.salary&#x27;) let city = document.querySelector(&#x27;.city&#x27;) // 渲染函数 把数组里面的数据渲染到页面中 let render = () =&gt; &#123; tbody.innerHTML = &#x27;&#x27; // 在渲染新的数据 // 根据数据的条数来渲染增加 tr for (let i = 0; i &lt; arr.length; i++) &#123; let tr = document.createElement(&#x27;tr&#x27;) tr.innerHTML = ` &lt;td&gt;$&#123;arr[i].stuId&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].uname&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].age&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].salary&#125;&lt;/td&gt; &lt;td&gt;$&#123;arr[i].city&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;javascript:&quot; id=&quot;$&#123;i&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; ` tbody.appendChild(tr) &#125; &#125; render() add.addEventListener(&#x27;click&#x27;,() =&gt; &#123; //修改数据层 arr.push(&#123; stuId: arr[arr.length - 1].stuId + 1, uname: uname.value, age: age.value, gender: gender.value, salary: salary.value, city: city.value &#125;) //渲染页面 render() // 复原所有的默认表单数据 uname.value = age.value = salary.value = &#x27;&#x27; gender.value = &#x27;男&#x27; city.value = &#x27;北京&#x27; &#125;) // 删除操作, 删除的也是数组里面的数据 // 不想要在每次重新渲染时都添加函数,可以直接对父元素采用事件委托方式 // 在冒泡地过程中进行事件处理, e.target.tagName返回的是大写 tbody.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; if (e.target.tagName === &#x27;A&#x27;) &#123; arr.splice(e.target.id, 1) // 重新渲染页面 render() &#125; &#125;)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"事件流模型","slug":"事件流模型","permalink":"https://kimanyang.xyz/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/"}]},{"title":"DOM-事件相关(1)","slug":"DOM-事件相关(1)","date":"2022-03-07T07:50:14.000Z","updated":"2022-03-10T15:36:32.633Z","comments":true,"path":"2022/03/07/DOM-事件相关(1)/","link":"","permalink":"https://kimanyang.xyz/2022/03/07/DOM-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3(1)/","excerpt":"","text":"DOM-事件相关(1)一个疑问，定时器的实现方式 undefined根据 JIT会当场停下 基础内容： 什么是事件 事件是在编程时系统内发生的动作或者发生的事情 什么是事件监听 程序检测是否有事件产生，一旦事件触发就立刻使用函数做出响应，也称为注册事件 事件监听三要素 事件源（被谁触发了） 事件类型（以什么方式触发，点击or鼠标经过） 事件处理程序 事件使用例——按钮单击抽签12345678910111213141516171819202122 // 1. 获取元素 div 和 button let box = document.querySelector(&#x27;div&#x27;)let btn = document.querySelector(&#x27;button&#x27;)// 2. 随机函数let getRandom = (min, max) =&gt; &#123; return Math.floor(Math.random() * (max - min + 1)) + min&#125;// 声明一个数组let arr = [&#x27;刘备&#x27;, &#x27;曹操&#x27;, &#x27;孙十万&#x27;]// 3. 事件监听btn.addEventListener(&#x27;click&#x27;, ()=&gt;&#123; // 随机的数字 let random = getRandom(0, arr.length - 1) box.innerHTML = arr[random] // 删除数组里面的元素 splice(从哪里删, 删几个) arr.splice(random, 1) // 如果数组没有了 长度为0，就要禁用按钮 if (arr.length === 0) &#123; btn.disabled = true btn.innerHTML = &#x27;已经抽完&#x27; &#125;&#125;) 事件监听的版本历史 DOM L0 事件源.on事件 = function()&#123;&#125; DOM L2 事件源.addEventListener(事件，事件处理函数) 发展史 DOM L0是 DOM 的发展的第一个版本 DOM L1DOM级别1 于1998年10月1日成为W3C推荐标准 DOM L2使用addEventListener注册事件 DOM L3事件模块在DOM2事件的基础上重新定义了这些事件，也添加了一些新事件类型 事件的几种类型1.鼠标事件 click鼠标点击 mouseenter鼠标经过 mouseleave鼠标离开 2.焦点事件 focus表单获得光标（获得焦点） blur表单失去光标（失去焦点） 3.键盘事件 keydown键盘按下触发 keyup键盘抬起触发 4.文本事件 input用户输入事件 详细可见《JavaScript高级程序设计（第4版）》17章介绍的用法。 综合案例——搜索下拉菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; * &#123; margin:0; padding:0; box-sizing: border-box; &#125; ul &#123; list-style: none; &#125; .area &#123; margin: 100px auto; width: 200px; &#125; input &#123; height: 28px; width: 100%; line-height: 28px; font-size: 12px; padding-left: 10px; border: 1px solid #ccc; outline: none; transition: all .3s; &#125; .area .change_border_input &#123; border: 1px solid #ff6700; &#125; .result_list &#123; width: 100%; line-height: 100%; border: 1px solid #ccc; border-top: 0; display: none; transition: all 0.3s ; &#125; .area .change_border_list &#123; border: 1px solid #ff6700; border-top: 0; &#125; .result_list li &#123; width: 100%; height: 28px; padding-left: 15px; font-size: 12px; line-height: 28px; &#125; .result_list li:hover &#123; background-color: #ccc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;area&quot;&gt; &lt;input type=&quot;search&quot; class=&quot;search&quot; placeholder=&quot;搜索结果&quot;&gt; &lt;ul class=&quot;change_border result_list &quot;&gt; &lt;li&gt;1商品&lt;/li&gt; &lt;li&gt;2商品&lt;/li&gt; &lt;li&gt;3商品&lt;/li&gt; &lt;li&gt;4商品&lt;/li&gt; &lt;li&gt;5商品&lt;/li&gt; &lt;li&gt;6商品&lt;/li&gt; &lt;li&gt;7商品&lt;/li&gt; &lt;li&gt;8商品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; let search = document.getElementsByTagName(&#x27;input&#x27;)[0] let list = document.getElementsByClassName(&#x27;result_list&#x27;)[0] let focus_ev = () =&gt; &#123; list.style.display = &#x27;block&#x27; search.classList.add(&#x27;change_border_input&#x27;) list.classList.add(&#x27;change_border_list&#x27;) &#125; let blur_ev = () =&gt; &#123; list.style.display = &#x27;none&#x27; search.classList.remove(&#x27;change_border_input&#x27;) list.classList.remove(&#x27;change_border_list&#x27;)//还是改不了，再说吧 &#125; search.addEventListener(&#x27;focus&#x27;, focus_ev) search.addEventListener(&#x27;blur&#x27;, blur_ev) &lt;/script&gt;&lt;/body&gt; 综合案例——全选表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;style&gt; * &#123; margin:0; padding: 0; box-sizing: border-box; &#125; table &#123; margin: 100px auto; width: 500px; border-collapse: collapse; border-spacing: 0; text-align: center; border:1px solid #ccc &#125; th &#123; height: 25px; background-color: rgb(27, 7, 161); font: bold 16px; color: white; text-align: center; &#125; td &#123; height: 35px; border: 1px solid #ccc; &#125;&lt;/style&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ckall&quot;&gt; &lt;span class=&quot;ckall_text&quot;&gt;全选&lt;/span&gt; &lt;/th&gt; &lt;th&gt;商品&lt;/th&gt; &lt;th&gt;商家&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ck&quot;&gt; &lt;td&gt;小米手机&lt;/td&gt; &lt;td&gt;小米&lt;/td&gt; &lt;td&gt;￥1999&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ck&quot;&gt; &lt;td&gt;小米净水器&lt;/td&gt; &lt;td&gt;小米&lt;/td&gt; &lt;td&gt;￥4999&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;ck&quot;&gt; &lt;td&gt;小米电视&lt;/td&gt; &lt;td&gt;虾米&lt;/td&gt; &lt;td&gt;￥5999&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script&gt; let checkAll = document.querySelector(&#x27;.ckall&#x27;) let checkboxs = document.querySelectorAll(&#x27;.ck&#x27;) let ckallText = document.querySelector(&#x27;.ckall_text&#x27;) let ckAllEvent = () =&gt; &#123; if(checkAll.checked) &#123; ckallText.innerHTML = &#x27;取消&#x27; for(let i = 0;i &lt; checkboxs.length;i++) &#123; checkboxs[i].checked = true; &#125; &#125; else &#123; ckallText.innerHTML = &#x27;全选&#x27; for(let i = 0;i &lt; checkboxs.length;i++) &#123; checkboxs[i].checked = false; &#125; &#125; &#125; checkAll.addEventListener(&#x27;click&#x27;,ckAllEvent) &lt;/script&gt;&lt;/body&gt; 综合案例——增减栏按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;style&gt; *&#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .box &#123; width: 60px; height: 40px; margin:100px auto; &#125; input &#123; float: left; text-align: center; border: 1px solid #ccc; outline: none; &#125; input[type=text] &#123; width: 60%; height: 100%; &#125; input[type=button] &#123; width: 40%; height: 50%; border-left: 0px; cursor: pointer; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;cnt&quot; value=&quot;1&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;+&quot; id=&quot;plus&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;-&quot; id=&quot;minus&quot; disabled=&quot;true&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let plusBtn = document.getElementById(&#x27;plus&#x27;) let minuxBtn = document.getElementById(&#x27;minus&#x27;) let inputText = document.getElementById(&#x27;cnt&#x27;) let cnt = 1,upperBound = 10; let plusEvent = () =&gt; &#123; if(cnt &lt; upperBound) &#123; cnt++; inputText.value = cnt minuxBtn.disabled = false; if(cnt &gt;= upperBound) &#123; plusBtn.disabled = true; &#125; &#125; &#125; let minusEvent = () =&gt; &#123; if(cnt &gt; 1) &#123; cnt--; inputText.value = cnt plusBtn.disabled = false; if(cnt &lt;= 1) &#123; minuxBtn.disabled = true; &#125; &#125; &#125; plusBtn.addEventListener(&#x27;click&#x27;,plusEvent); minuxBtn.addEventListener(&#x27;click&#x27;,minusEvent)&lt;/script&gt; 综合案例——Tab栏切换的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .tab &#123; margin: 100px auto; width: 300px; height: 150px; border: 1px solid #ccc; &#125; .tab .checkbar &#123; width: 80%; height: 15%; &#125; .tab .checkbar button &#123; float: left; width: 20%; height: 100%; border: 1px solid #ccc; background-color: #ccc; border-right: 0; border-bottom: 0; font-size: 14px; line-height: 100%; cursor: pointer; &#125; .tab .checkbar .beChecked &#123; border: 2px solid palevioletred; border-radius: 20%; &#125; .tab .checkbar button:hover &#123; border: 2px solid orange; border-radius: 10%; background-color: azure; &#125; .tab .checkbar .lastBtn &#123; border-right: 1px solid #ccc; &#125; .tab .tabContent &#123; height: 85%; width: 100%; border-top: 1px solid #ccc; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;checkbar&quot;&gt; &lt;button class=&quot;tabbtn beChecked&quot;&gt;按钮1&lt;/button&gt; &lt;button class=&quot;tabbtn&quot;&gt;按钮2&lt;/button&gt; &lt;button class=&quot;tabbtn&quot;&gt;按钮3&lt;/button&gt; &lt;button class=&quot;tabbtn&quot;&gt;按钮4&lt;/button&gt; &lt;button class=&quot;tabbtn&quot; class=&quot;lastBtn&quot;&gt;按钮5&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;empty&quot;&gt;&lt;/div&gt; &lt;div class=&quot;tabContent&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let tabBtns = document.querySelectorAll(&#x27;.tabbtn&#x27;) let content = document.querySelector(&#x27;.tabContent&#x27;) let contents = [ &quot;这是内容1&quot;, &quot;这是内容2&quot;, &quot;这是内容3&quot;, &quot;这是内容4&quot;, &quot;这是内容5&quot;, ] content.innerHTML = contents[0] for(let i = 0;i &lt; tabBtns.length;i++) &#123; tabBtns[i].addEventListener(&#x27;click&#x27;, () =&gt; &#123; content.innerHTML = contents[i] let curSetBtn = document.querySelector(&#x27;.beChecked&#x27;) curSetBtn.classList.remove(&#x27;beChecked&#x27;) tabBtns[i].classList.add(&#x27;beChecked&#x27;) &#125;) &#125;&lt;/script&gt; DOM对象节点的增删改查1.节点查找 父节点查找： parentNode属性 返回最近的父节点，找不到为null 子节点查找 childNodes属性，包括所有子节点（包括文本节点和注释节点） children属性，获得所有元素节点 返回一个伪数组 兄弟节点查找 nextElementSibling属性 previousElementSibling属性 2.节点增加 创建节点：对于节点一般是先创建再追加 &#96;&#96;&#96;jslet ele &#x3D; document.createElement(‘标签名’)123456- 追加节点至父元素中使之在页面显示 - ```js 父元素.appendChild(ele)//父元素最后 父元素.insertBefore(ele,child)//插入到父元素的子元素child之前 深拷贝一个节点， 语法element.cloneNode(flag) 若flag为true则克隆时包含后代节点 若flag为false则不包含后代节点 默认为false 3.删除节点删除元素必须通过父元素进行 1parent.removeChild(child) 不存在父子关系则删除不成功 删除节点和隐藏节点不同，隐藏节点后节点仍然存在 时间对象使用总结首先要实例化一个事件对象，然后调用对象的方法 12let date = new Date()let date = new Date(&#x27;1949-10-01&#x27;) 接口总结： 方法 作用 说明 getFullYear() 获得年份 获取四位年份 getMonth() 获得月份 取值为 0 ~ 11 getDate() 获取月份中的每一天 不同月份取值也不相同 getDate() 获取星期 取值为 0 ~ 6 getHours() 获取小时 取值为 0 ~ 23 getMinutes() 获取分钟 取值为 0 ~ 59 getSeconds() 获取秒 取值为 0 ~ 59 getTime()&#x2F;Date.now() 获取时间戳 六十四位数字","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"DOM事件","slug":"DOM事件","permalink":"https://kimanyang.xyz/tags/DOM%E4%BA%8B%E4%BB%B6/"}]},{"title":"DOM模型","slug":"DOM模型","date":"2022-03-06T00:23:14.000Z","updated":"2022-03-09T14:59:51.579Z","comments":true,"path":"2022/03/06/DOM模型/","link":"","permalink":"https://kimanyang.xyz/2022/03/06/DOM%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"DOM相关基本概念DOM树 将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树 描述网页内容关系的名词 作用：文档树直观的体现了标签与标签之间的关系 DOM对象DOM对象：浏览器根据html标签生成的 JS对象 所有的标签属性都可以在这个对象上面找到 修改这个对象的属性会自动映射到标签身上 DOM的核心思想就是把网页当作对象处理 Document对象是DOM中提供的根对象，提供的属性和方法都是用来访问和操作网页内容的 如何获取DOM对象1.根据CSS选择器来获取DOM元素选择匹配到的第一个元素，语法： 1document.querySelector(&#x27;cssslect&#x27;) 选择匹配的所有元素NodeList集合，语法： 1ducument.querySelecotrAll(&#x27;ul li&#x27;) 对于这个集合无法通过一般数组的push/pop方法进行操作，但是可以数组遍历，被称为伪数组。 2.其他获取方法123456//根据id获取元素document.getElementById(&#x27;nav&#x27;)//根据标签获取一类元素document.getElementByTagName(&#x27;div&#x27;)//根据类名获取元素document.getElementByClassName(&#x27;w&#x27;) 设置&#x2F;修改DOM元素内容DOM对象都是根据标签生成的,所以操作标签,本质上就是操作DOM对象。 就是操作对象使用的点语法。 如果想要修改标签元素的里面的内容，则可以使用如下几种方式： document.write()方法， 只能将文本内容追加到&lt;\\body&gt;标签之前 文本中包含的标签会被解析 对象**.innerText属性修改** 可以将文本内容添加到任意标签位置 文本中包含的标签不会被解析 对象**.innerHTML属性修改** 文本内容添加&#x2F;更新到任意标签位置 文本中包含的标签会被解析 设置&#x2F;修改DOM元素属性1.设置&#x2F;修改元素常用属性常见包括href&#x2F;title&#x2F;src等等，语法： 123let pic = document.querySelector(&#x27;img&#x27;);pic.src = &#x27;./images/b02.jpg&#x27;;pic.title = &#x27;a new picture&#x27;; 一个典型案例的实现： 刷新页面时图片随机显示 2.设置&#x2F;修改元素样式属性可以通过JS设置修改标签元素的样式属性来实现诸如 主要有三种方法： 通过style属性操作CSS，属性若有连接符转换为小驼峰命名 1234let box = document.querySelector(&#x27;.box&#x27;)box.style.backgroundColor = &#x27;red&#x27;box.style.width = &#x27;300px&#x27;box.style.marginTop = &#x27;50px&#x27; 操作类名（className）操作CSS，实现定义好一套类的CSS，更换类名实现更换CSS 1box.className = &#x27;active&#x27; 通过classList操作类控制CSS 123el.classList.add(&#x27;类名&#x27;)//添加类名el.classList.remove(&#x27;类名&#x27;)//移除类名el.classList.toggle(&#x27;类名&#x27;)//切换类名 3.设置&#x2F;修改表单元素属性诸如点击眼睛看到密码等功能，都是通过设置表单的不同属性来实现的。 12el.value = &#x27;username&#x27;el.type = &#x27;password&#x27; 表单属性中添加就有效果，移除就没有效果，一律使用布尔值。常用的一些属性disabled、checked、selected 间歇定时器设置按钮定时器，到时间才能够使能 12345678910111213141516let btn = document.querySelector(&#x27;.btn&#x27;)let i = 60let timer = setInterval( () =&gt; &#123; i-- btn.innerHTML = `我已经阅读用户协议($&#123;i&#125;)` if (i === 0) &#123; //清除定时器 clearInterval(timer) // 开启按钮 btn.disabled = false // 更换文字 btn.innerHTML = &#x27;我同意该协议啦&#x27; &#125;&#125;, 1000)//let timer = setInterval(closure, time),单位是毫秒 实践案例，定时轮播图。 123456789101112131415 // 1. 获取元素 图片 和 h3let pic = document.querySelector(&#x27;.pic&#x27;)let text = document.querySelector(&#x27;.text&#x27;)// i 记录图片的张数let i = 0// 2.开启定时setInterval(() =&gt; &#123; i++ pic.src = data[i].imgSrc // 修改文字内容 text.innerHTML = data[i].title if (i === data.length - 1) &#123; i = -1 &#125;&#125;, 900)","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"}],"tags":[{"name":"DOM模型","slug":"DOM模型","permalink":"https://kimanyang.xyz/tags/DOM%E6%A8%A1%E5%9E%8B/"}]},{"title":"CSS笔记(4)","slug":"CSS笔记(4)","date":"2022-03-01T09:08:24.000Z","updated":"2022-03-10T15:32:59.460Z","comments":true,"path":"2022/03/01/CSS笔记(4)/","link":"","permalink":"https://kimanyang.xyz/2022/03/01/CSS%E7%AC%94%E8%AE%B0(4)/","excerpt":"","text":"CSS笔记(4)目标内容 说出3~5个H5新增布局和表单标签 说出CSS3的新增特性 HTML5的新特性H5新增语义化标签 &lt;header&gt; 头部标签 &lt;nav&gt; 导航标签 &lt;article&gt; 内容标签 &lt;section&gt; 文档某个区域 &lt;aside&gt; 侧边栏标签 &lt;footer&gt; 尾部标签 需要注意： 语义化标准主要针对搜索引擎SEO，你要喜欢可以全部div 变迁在页面中可以多次使用 IE9需要用div 多用于移动端 H5新增多媒体标签在不适用插件的情况下支持部分视频格式 1.video标签当前支持三种格式，尽量使用mp4 浏览器 MP4 WebM Ogg IE ok no no Chrome ok ok ok Firefox ok ok ok Safari ok no no Opera ok ok ok video的常见属性： 属性 值 描述 autoplay autoplay 视频自动播放 controls controls 显示播放控件 width 像素 设置宽度 height 像素 设置高度 loop lool 是否循环播放 preload auto（预先加载）none（不预先加载） 规定是否预加载视频，有autoplay则忽略 src url 视频url地址 poster imgurl 等待加载的图片 muted muted 静音播放，谷歌浏览器autoplay需加入此项使能 2.音频audio浏览器支持自己查，三种格式MP3,Wav,Ogg，尽量MP3和Wav H5为input新增的属性类型 属性值 说明 email 限制类型为Email url 限制类型为Url date 限制类型为日期 time 限制类型为时间 month 限制类型为月份 week 限制类型为周 number 限制类型为数字 tel 限制类型为电话 search 搜索框 color 生成颜色选择表单 H5为表单新增的表单属性 属性 值 说明 required required 拥有表单该属性表示内容不能为空必须填 placeholder 提示的文本 表单提示信息，存在默认值将不再显示 autoforcus autofocus 自动聚焦，页面加载完成后是否自动聚焦表单 autocomplete off&#x2F;on 是否为用户基于先前输入自动补全，默认打开，如果需要关闭得在表单里面写样式同时添加name属性 multiple multiple 可以选多个本地文件提交，用于file 1&lt;input type=&quot;search&quot; name=&quot;sear&quot; id=&quot;&quot; required=&quot;required&quot; placeholder=&quot;fuck you&quot; onfocus=&quot;this.placeholder=&#x27;&#x27;&quot; onblur=&quot;this.placeholder=&#x27;fuck you&#x27;&quot;&gt; 有部分js内容，但是上述的代码可以实现单击文本框时placeholder消失 CSS3的新特性新增选择器1.属性选择器 选择符 简介 E[alt] 选择具有alt属性的e元素 E[alt&#x3D;”val”] 选择具有alt属性且值等于val的E元素 E[alt^&#x3D;”val”] 匹配具有alt属性且值以val开头的E元素 E[alt$&#x3D;”val”] 匹配具有alt属性且值以val结尾的E元素 E[alt*&#x3D;”val”] 匹配具有alt属性且值中含有val的E元素 2.结构伪类选择器 选择符 简介 E:first-child 匹配父元素中的第一个子元素E E:last-child 匹配父元素中的最后一个元素E E;nth-child(n) 匹配父元素中的第n个子元素E E:first-of-type 指定类型E的第一个 E:last-of-type 指定类型E的最后一个 E:nth-of-type(n) 指定类型E的第n个 重点关注一下nth-child(n)，里面的n很多变，用处很大。 n可以是数字、关键字和公式 n如果是数字，就是选择第n个子元素，里面数字从1开始 n如果是关键字，odd为偶数元素，even为奇数元素 n可以是公式：常见的公式如下所示（n从0开始到不超出范围内符合的） 公式 取值 $2 n$ 偶数 $2n+1$ 奇数 $5n$ 5 10 15… $n+5$ 第五个开始到最后 $- n + 5$ 包含第五个的前五个 nth-of-type和nth-child(n)的用法是类似的，但是区别和字面意义一样在排序上不相同，nth-of-type编号是对所有类型为前面的结构伪类的元素进行的，而nth-child编号是对所有元素进行的，如果一个父元素拥有异质的子元素，使用nth-child同时也指定类型是可能选不上的。 3.伪元素选择器伪元素选择器可以帮助我们利用CSS创建新标签元素而不需要HTML标签从而简化HTML结构。前面讲的浮动清除就利用了这个原理。 选择符 简介 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 before和after创建一个元素，但是属于行内元素 新创建的元素在文档树中无法找到，称之为伪元素 语法： element::before&#123;&#125; 必须要有content属性 伪元素选择器的权重和标签选择器一样为1 伪元素的使用场景：字体图标1234567891011121314151617 div &#123; position: relative; width: 200px; height: 35px; border: 1px solid red;&#125;div::after &#123; position: absolute; top: 10px; right: 10px; font-family: &#x27;icomoon&#x27;; /* content: &#x27;&#x27;; */ content: &#x27;\\e91e&#x27;; color: red; font-size: 18px;&#125; 伪元素的使用场景：hover掩模在笔记2中的半透明掩膜需要额外添加一个盒子让其脱标并悬浮于当前显示之上，使用伪元素特性则可以直接忽略这点（也不需要使用js）： 1234567891011121314151617181920212223242526272829303132&lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .tudou::before &#123; content: &#x27;&#x27;; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面before遮罩层显示出来 */ .tudou:hover::before &#123; /* 而是显示元素 */ display: block; &#125;&lt;/style&gt; 上述的before属性用after也没啥问题。 伪元素使用场景：双伪元素清除浮动伪元素清除浮动的方法: 1234567.clearfix:after &#123; content: &quot;&quot;; /*伪元素必要属性*/ display: block;/*插入的元素必须为块级*/ height: 0;/*不看见这个元素*/ clear: both;/*左右不允许浮动，核心代码*/ visibility:hidden;/*元素不可见*/&#125; 关于原理，解释的好的博客地址：了解伪元素清除浮动原理_qq_38105488的博客-CSDN博客 12当应用于非浮动块时，它将非浮动块的边框边界移动到所有相关浮动元素外边界的下方。这个非浮动块的垂直外边距会折叠。所以添加一个没有高度的不可浮动块元素它会另起一行直接撑开所有浮动块 双伪元素的强化版本，这种做法相当于： 12345678.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;/*前后转换为块元素并且一行显示*/&#125;.clearfix:after &#123; clear: both;&#125; CSS3盒子模型变动以前计算盒子大小的时候要提前考虑padding值和border算半天，现在可以通过box-sizing来指定盒子模型，即可指定为content-box&#x2F;border-box 盒子模型的变动为两种情况： box-sizing:content-box盒子大小是width(height)+padding+border，即默认情况 box-sizing:border-box则盒子大小就是width(height)，这样就不用去算了,前提是边界合起来不超过盒子大小 对于三角形不友好，如果设置了默认的box-sizing:bordr-box;记得要画三角形的时候重新设置回来。 CSS3过渡的使用（Important）过渡特性可以使得浏览器不需要JavaScript也能够实现动画，当元素从一种样式变换为另一种样式的时候为元素添加效果。 可以美化页面，经常和hover配合使用 过渡的语法1transition:过渡的属性 花费时间 运动曲线 何时开始; 属性：想要变换的css属性，包括宽度、高度、背景颜色、内外边距都可以。如果想要所有属性都过渡就是用一个alt 花费时间：单位是秒（必须写单位）比如0.5s 运动曲线：默认是easy，可以省略 何时开始：可以延迟触发，单位是秒（必须写单位），默认是0，可以省略 谁要过渡给谁加（transition属性加在过渡之前） 123456789101112131415161718 div &#123; width: 200px; height: 100px; background-color: pink; /* transition: 变化的属性 花费时间 运动曲线 何时开始; */ /* transition: width .5s ease 0s, height .5s ease 1s; */ /* 如果想要写多个属性，利用逗号进行分割 */ /* transition: width .5s, height .5s; */ /* 如果想要多个属性都变化，属性写all就可以了 */ /* transition: height .5s ease 1s; */ /* 谁做过渡，给谁加 */ transition: all 0.5s;&#125;div:hover &#123; width: 400px; height: 200px; background-color: skyblue;&#125; 过渡特性的一个案例，血压拉满： 12345678910111213141516171819202122232425262728293031&lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; .outbox &#123; margin: 20px auto; height: 30px; width: 300px; padding: 2px; border: 1px solid red; border-radius: 10px; &#125; .bar &#123; height: 95%; width: 50%; float: left; background-color: skyblue; transition: all 0.8s; &#125; .bar:hover &#123; width: 100%; background-color: red; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;outbox&quot;&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 其他CSS3小特性 图片模糊filter:函数需要的时候去查就好，用blur()可以模糊 盒子宽度计算函数width:calc()，可以在声明CSS属性时做一些计算，支持四则运算，比如width: calc(100% - 30px);可以永远比父盒子宽度小30像素 一些属性书写顺序规定建议遵循以下顺序： 布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background 文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word 其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"H5标签","slug":"H5标签","permalink":"https://kimanyang.xyz/tags/H5%E6%A0%87%E7%AD%BE/"},{"name":"CSS过渡","slug":"CSS过渡","permalink":"https://kimanyang.xyz/tags/CSS%E8%BF%87%E6%B8%A1/"},{"name":"CSS3新特性","slug":"CSS3新特性","permalink":"https://kimanyang.xyz/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"CSS笔记(3)","slug":"CSS笔记(3)","date":"2022-02-28T08:48:24.000Z","updated":"2022-03-10T15:33:07.954Z","comments":true,"path":"2022/02/28/CSS笔记(3)/","link":"","permalink":"https://kimanyang.xyz/2022/02/28/CSS%E7%AC%94%E8%AE%B0(3)/","excerpt":"","text":"CSS笔记(3)目标列表 使用精灵图 使用字体图标 写出CSS三角 常见CSS用户界面样式 说出常见的布局技巧 精灵图为何使用精灵图为什么需要精灵图:网页中往往会应用很多小的背景图像作为修饰，网页中图像过多时，服务器会频繁地接受和发送请求造成页面加载速度过慢。为了减少请求次数提高页面加载速度从而有了CSS Sprites技术。 如何使用精灵图 主要针对背景图片，把多个小背景图片这个河道一个大的图片中 大图片称为sprites精灵图 移动背景图片位置可以用background-position 移动距离就是目标图x轴和y轴坐标，右x下y 一般情况往上往左移动，所以数值为负值 使用精灵图得准确测量每个小背景图片的大小和位置 12345678910111213.box1 &#123; width: 60px; height: 60px; margin: 100px auto; background: url(images/sprites.png) no-repeat -182px 0;&#125;.box2 &#123; width: 27px; height: 25px; /* background-color: pink; */ margin: 200px; background: url(images/sprites.png) no-repeat -155px -106px;&#125; 字体图标使用场景：显示网页中通用的常用小图标，这些地方使用精灵图有些缺点： 图片文件较大 图片放大缩小会失真 制作完成后更换很复杂 字体图标本质上是字，但是可以显示出图片，需要外部引入相关的字体图标库 优点： 轻量级：字体图标比一系列图像小，减少了服务请求 灵活性：本质上是文字，可以改变颜色产生阴影透明旋转效果 兼容性：支持所有浏览器 但不能替代精灵图，只是部分优化。可以去阿里iconfont字库或者icomoon下载字体图标用。 使用过程： 把下载包地font文件（包括EOT&#x2F;TRUETYPE&#x2F;WOFF&#x2F;SVG）文件放入目录 链接或者直接复制粘贴字体中附加的css文件 根据需要在字库里面复制所需的utf码，在vscode里是乱码但是浏览器能够渲染 阿里的包下下来直接就有教程，不怕不怕啦 CSS三角制作网页中常见的三角形直接用CSS画出来即可，不必做成图片或者字体图标。规律大概是上下被左右压进去。左右是不会冲突的。待考证。 参考网站：The Shapes of CSS | CSS-Tricks - CSS-Tricks 用户界面样式鼠标样式li &#123;cursor: pointer;&#125;，设置或检索在对象上移动鼠标指针采用何种预定义形状。 属性值 描述 default 默认 pointer 手 move 移动 text 文本 not-allowed 禁止 表单样式12345678 input, textarea &#123; /* 取消表单轮廓，点下去表单不会变粗 */ outline: none;&#125;textarea &#123; /* 防止拖拽文本域，富文本框不会被拖大 */ resize: none;&#125; vertical-align属性应用属性值与场景使用场景:用于设置图片或者表单（行内块元素）和文字垂直对齐。 vertical-align:baseline|top|middle|bottom 值 描述 baseline 默认，置于父元素基线之上 top 元素的顶端与行中最高元素顶端对齐 middle 元素置于父元素中部 bottom 元素的顶端与行中最低元素顶端对齐 解决图片底部默认空白缝隙（行内块元素基线对齐导致）解决方法有两种： 给图片添加vertical-align:middle|top|bottom;等（提倡使用） 把图片转换为块级元素display:block; 溢出文字省略号表示1.单行文本溢出显示省略号必须满足三个条件： 123456/* 1.nowrap,不展开，强制文字显示不自动换行 */white-space: nowrap;/* 2.溢出的部分隐藏起来 */overflow: hidden;/* 3. 文字溢出的时候用省略号来显示 */text-overflow: ellipsis; 2.多行文本溢出显示省略号有较大兼容性问题，适合webKit浏览器和移动端 12345678overflow: hidden;text-overflow: ellipsis;/* 弹性伸缩盒子模型显示 */display: -webkit-box;/* 限制在一个块元素显示的文本的行数 */-webkit-line-clamp: 4;/* 设置或检索伸缩盒对象的子元素的排列方式 */-webkit-box-orient: vertical; 推荐后端限制字数，做起来没那么多事情 几个常用的布局技巧margin负值的运用多个盒子排在一起如果margin是0的话边框会重叠在一起导致中间的边框变为两倍大小看着很难看，于是可以设置margin为负的边框大小： 12345678910111213141516171819 ul li &#123; position: relative; float: left; list-style: none; width: 150px; height: 200px; border: 1px solid red; margin-left: -1px;&#125; /* ul li:hover &#123; 1. 如果盒子没有定位，则鼠标经过添加相对定位即可 position: relative; border: 1px solid blue;&#125; */ul li:hover &#123; /* 2.如果li都有定位，则利用 z-index提高层级 */ z-index: 1; border: 1px solid blue;&#125; 对于hover效果，如果要让其显示在浮动之上，可以添加定位或者直接设置z-index 文字围绕浮动元素巧妙利用（可能也是原本运用）浮动不压住内容的特性形成下图效果： 12345678910111213141516171819202122232425262728 &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 300px; height: 70px; background-color: pink; margin: 0 auto; padding: 5px; &#125; .pic &#123; float: left; width: 120px; height: 60px; margin-right: 5px; &#125; .pic img &#123; width: 100%; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;pic&quot;&gt; &lt;img src=&quot;images/img.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;p&gt;【集锦】热身赛-巴西0-1秘鲁 内马尔替补两人血染赛场&lt;/p&gt;&lt;/div&gt; 行内块巧妙运用例子，制作翻页条 是个例子来着，自己做了一遍就行 CSS三角强化例子，制作斜角切条： 总之自己做了做： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; * &#123; margin:0; padding: 0; &#125; .box &#123; height: 28px; width: 180px; line-height: 28px; margin: 30px auto; border: 1px solid red; &#125; .box .price &#123; float: left; height: 100%; width: 85px; font-size: 16px; text-align: center; margin:0 &#125; .box .before &#123; float: right; background-color: aliceblue; text-decoration: line-through; font-size: 12px; color: #ccc; &#125; .box .after &#123; font-weight: 700; background-color: red; color: aliceblue; &#125; .triangle &#123; float: left; width: 0; height: 0; border-top: 28px solid red; border-right: 10px solid aliceblue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;price after&quot;&gt; $1880 &lt;/div&gt; &lt;div class=&quot;triangle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;price before&quot;&gt;$2680&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS初始化一个CSS初始化的案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 把我们所有标签的内外边距清零 */* &#123; margin: 0; padding: 0&#125;/* em 和 i 斜体的文字不倾斜 */em,i &#123; font-style: normal&#125;/* 去掉li 的小圆点 */li &#123; list-style: none&#125;img &#123; /* border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */ border: 0; /* 取消图片底侧有空白缝隙的问题 */ vertical-align: middle&#125;button &#123; /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */ cursor: pointer&#125;a &#123; color: #666; text-decoration: none&#125;a:hover &#123; color: #c81623&#125;button,input &#123; /* &quot;\\5B8B\\4F53&quot; 就是宋体的意思 这样浏览器兼容性比较好 */ font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\\5B8B\\4F53&quot;, sans-serif&#125;body &#123; /* CSS3 抗锯齿形 让文字显示的更加清晰 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\\5B8B\\4F53&quot;, sans-serif; color: #666&#125;.hide,.none &#123; display: none&#125;/* 清除浮动 */.clearfix:after &#123; visibility: hidden; clear: both; display: block; content: &quot;.&quot;; height: 0&#125;.clearfix &#123; *zoom: 1&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"https://kimanyang.xyz/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"CSS三角与精灵图","slug":"CSS三角与精灵图","permalink":"https://kimanyang.xyz/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS 溢出显示","slug":"CSS-溢出显示","permalink":"https://kimanyang.xyz/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/"}]},{"title":"CSS笔记(2)","slug":"CSS笔记(2)","date":"2022-02-27T14:38:34.000Z","updated":"2022-03-10T15:33:13.490Z","comments":true,"path":"2022/02/27/CSS笔记(2)/","link":"","permalink":"https://kimanyang.xyz/2022/02/27/CSS%E7%AC%94%E8%AE%B0(2)/","excerpt":"","text":"CSS笔记(2)浮动相关目标 为什么需要浮动 浮动的排列特性 3种最常见的布局方式 为什么需要清除浮动 2种清除浮动的写法 切图？ 定位相关目标 为什么需要定位 定位的四种分类 4种定位的各自特点 为什么常用子绝父相布局 写出淘宝轮播图布局 显示隐藏的两种方式以及区别 传统网页布局三种方式标准标签按照规定的默认方式排列 块级元素独占一行从上向下，常用div,hr,p,h1~h6,ul,ol,dl,form,table 行内严肃按照顺序从左到右排列，父元素边缘自动换行，常用span,a,i,em 浮动为什么需要浮动有些布局使用标准进行很难整好，使用浮动可以改变默认的标签排列方式。最典型的应用时使得多个块级元素再一行内排列显示。多个块级元素纵向排列用标准布局，多个块级元素横向排列用浮动布局。 浮动的属性值：1选择器 &#123;float:属性值;&#125; 属性值 描述 none 默认不浮动 left 元素向左浮动 right 元素向右浮动 浮动脱标浮动元素的最重要特性： 脱离标准控制流浮动到指定位置 不再保留预先的位置如果存在多个浮动的盒子，则它们会按照属性值再一行内显示并且顶端对齐排列。浮动的元素相互贴靠不存在缝隙，如果父级宽度无法装下浮动的盒子则多出的盒子会另起一行对齐。 浮动元素具有行内块元素特性任何元素都可以浮动，不管原先是什么模式，浮动后都有行内块元素特性 块级盒子没有宽度，则默认宽度和父级一样宽，但是添加浮动后大小根据内容来决定 浮动的盒子中间没有缝隙，是紧挨着的 行内元素同理 为什么需要清除浮动再父级拥有很多盒子的情况下不方便给出高度，到那时子盒子浮动不占有位置，最后父级盒子高度为0的时候会影响下方标准流盒子。父级0高度盒子不会被内容撑开，理想中应该有多少孩子就撑开多少。 清除浮动本质 清除浮动本质是清除浮动元素造成的影响 如果父盒子自身有高度则不需要清除浮动 清除浮动之后父级会根据子盒子的浮动自动检测高度从而被撑开，就不会影响下方元素了 1选择器&#123;clear:属性值&#125; 存在left&#x2F;right&#x2F;both三个值，实际中几乎只用both，即左右侧都不允许浮动值。 清除浮动的四种方法 额外标签法，w3c推荐做法，对末尾的类设置clear:both属性 123456&lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; 父级overflow:hidden属性 1234&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt; &lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;/div&gt; 父级after伪属性 1234567.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125; 父级添加双伪元素 12345678.clearfix:before,.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125; 相关总结： 清除浮动方式 优点 缺点 额外标签法 通俗易懂书写方便 存在无意义标签 父级overflow 书写简单 盒子溢出的部分会被隐藏，不利于完整展示 父级after伪元素 结构语义化正确 IE兼容性问题 父级双伪元素 结构语义化正确 IE兼容性问题 包括浮动后的通常CSS初始化代码1234567891011121314151617181920/*清除内外边距*/* &#123; margin: 0; padding: 0;&#125;/*清除列表样式*/ul &#123; list-style:none;&#125;/*清除浮动*/.clearfix:before, after &#123; display: table; content: &quot;&quot;;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom:1&#125; 定位为什么需要定位让元素在盒子内自由移动位置并且压住其他盒子，比如一些标签啥的 定位的组成1.定位模式 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 2.边偏移就是定位的盒子移动到最终位置，有top&#x2F;bottom&#x2F;left和right四个属性。 边偏移属性 示例 描述 top top:80px 顶端偏移量，相对于父元素上边线的距离 bottom bottom:80px 底部偏移量，相对于父元素下边线的距离 left left:80px 左侧偏移量，相对于父元素左边线的距离 right right:80px 右侧偏移量，相对于父元素右边线的距离 四种定位具体静态定位static即默认定位方式，不定位的意思 相对定位（重要）相对定位的四个偏移值是指相对于它自身原来的位置而言的 绝对定位（重要）绝对定位是元素在移动位置的时候相对于祖先元素而言的 没有祖先元素或者祖先元素没有定位，则以浏览器作为定位 如果祖先元素有定位（相对、绝对、固定这三种），则以最近一级有定位的祖先元素作为参考标准 绝对定位不再占用原先的位置（类似于浮动的脱标，直接到了浏览器上方） 固定定位（重要）固定定位是元素固定于浏览器可视区的位置。主要应用场景：可以使得浏览器在页面滚动时元素位置不会改变。 1选择器 &#123;position:fixed;&#125; 固定定位的特点： 以浏览器的可视窗口为参照点移动元素 和父元素没有任何关系 不随滚动条滚动 固定定位不再占有原先的位置 固定定位也是脱标的，可以看作一种特殊的绝对定位。 固定定位小技巧：固定在版心右侧位置 固定定位盒子left:50%，走到浏览器可视区（版心）的一半位置 固定定位的盒子margin-left：版心宽度一般距离 番外——粘性定位sticky固定定位和相对定位混合 1选择器 &#123;position: sticky; top: 10px;&#125; 粘性定位特点： 以浏览器的可视窗口为参照点移动元素（固定定位） 粘性定位占有原先定位位置（相对定位特点） 必须添加top&#x2F;left&#x2F;right&#x2F;bottom其中一个才有效 子绝父相的由来定位中最常用的方式就是：子级是绝对定位的话父级要用相对定位 子级绝对定位不会占有位置，可以放到父盒子里的任何一个地方，不会影响其他的兄弟盒子 父盒子需要加定位限制子盒子只能在父盒子内显示 父盒子布局时需要占有位置因此只能是相对定位 相对定位经常用来作为绝对定位的父级，如果父元素不需要占有位置也可以都用绝对定位。 定位相关总结 定位模式 是否脱标 移动位置 是否常用 static 否 不能使用边偏移 基本无 relative 否（占有原先位置） 相对自身位置偏移 多 absolute 是（不占原先位置） 相对父级的边偏移 多 fixed 是（不占原先位置） 相对浏览器可视区偏移 多 sticky 否（占有位置） 相对浏览器可视区偏移 看情况 定位的叠放次序可能会出现盒子重叠，这时候可以使用z-index：数值来改变叠放次序 可以是正整数、负整数或者0，默认是auto，越大越靠上 属性值相同按照书写顺序后来居上 数字后不能加单位 有定位的盒子才能添加z-index 定位的扩展绝对定位的盒子居中绝对定位的盒子无法通过margin:0 auto来居中，但是可以自己计算实现水平和垂直居中，具体的代码要记住： 12345678910.box &#123; width:100px; height:100px; position: absolute; left: 50%; top: 50px; margin-left: -50px;/*是负的一半盒子宽度*/ margin-top: -50px;/*是负的一半盒子高度*/ background-color: pink; &#125; 定位的特殊特性 绝对定位和固定定位也和浮动类似 行内元素添加绝对或者固定定位可以直接设置高度和宽度 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 脱标盒子不会触发外边距塌陷包括了浮动元素、绝对定位（固定定位）元素的都不会触发外边距合并问题。 绝对定位（固定定位）会完全压住盒子但是浮动元素只会压住盒子，不会压住盒子中的内容 三种布局总结 标准方式，用于多个垂直的块级盒子布局 浮动方式，用于多个块级元素一行显示或者左右对齐 定位，具有层叠概念，让元素自由在盒子内部移动 元素的显示与隐藏displaydisplay属性用于设置一个元素应该如何显示，除了转换为块级、行内块元素以外，还可以设置是否显示 display:none;用于隐藏对象，被隐藏后不再占用原先的位置 display:block;除了用于转换块级元素也可用于显示对象 visibilityvisibility用于指定一个元素可见或是隐藏属性值包括visible|collapse|hidden visibility:visible;元素可视 visibility:hidden;元素隐藏 隐藏元素后继续占用原来的位置，所以根据元素是否占用原来位置适当地选择让js控制display或者是visibility overflowoverflow属性制定了如果内容溢出了一个元素的框时会发生什么（超过其指定高度及宽度） overflow:visible内容可见 overflow:hidden内容不可见 overflow:scroll总是显示滚动条 overflow:auto溢出的时候才显示滚动条 对于有定位的盒子要慎用overflow:hidden; 重要案例——透明掩模制作1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .box &#123; position: relative; width: 444px; height: 320px; margin: 20px auto; &#125; .box img &#123; width: 100%; height: 100%; &#125; .mask &#123; position: absolute; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; display: none; &#125; /*当.box:hover 事件发生时使得属于这个.box的mask显示为block，很绕，我宁愿用js干这事*/ .box:hover .mask&#123; display: block; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;./images/tudou.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"https://kimanyang.xyz/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"CSS浮动与定位","slug":"CSS浮动与定位","permalink":"https://kimanyang.xyz/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/"}]},{"title":"CSS笔记(1)","slug":"CSS笔记(1)","date":"2022-02-24T03:08:34.000Z","updated":"2022-03-10T15:33:18.968Z","comments":true,"path":"2022/02/24/CSS笔记(1)/","link":"","permalink":"https://kimanyang.xyz/2022/02/24/CSS%E7%AC%94%E8%AE%B0(1)/","excerpt":"","text":"CSS笔记(1)CSS选择器类型基础选择器 标签选择器 类选择器（多类名使用） id选择器 通配符选择器 复合选择器 后代选择器，所有后代（孙子…都会生效） 1ol li &#123;color: pink;&#125; 子选择器，仅仅生效一代 1.nav&gt;a &#123;color: red;&#125; 并集选择器，literally 1div,p,.pig li &#123;color: pink;&#125; 伪类选择器 链接伪类选择器 1234567891011121314151617/* 1.未访问的链接 a:link 把没有点击过的(访问过的)链接选出来 */a:link &#123; color: #333; text-decoration: none;&#125;/*2. a:visited 选择点击过的(访问过的)链接 */a:visited &#123; color: orange;&#125;/*3. a:hover 选择鼠标经过的那个链接 */a:hover &#123; color: skyblue;&#125;/* 4. a:active 选择的是我们鼠标正在按下还没有弹起鼠标的那个链接 */a:active &#123; color: green;&#125; focus选择器 12345 /* // 把获得光标的input表单元素选取出来 */input:focus &#123; background-color: pink; color: red;&#125; Emmet语法HTML快速生成 标签名+tab可以生成标签 标签名*个数+tab,比如div+*+3+tab 父子级关系的标签直接用&gt;，如ul&gt;li 兄弟级关系的标签直接用+，如div+p 生成带有类名和id的可以用.demo或者#two再按tab，比如div.demo+tab 有顺序的类名可以用自增符号$，比如div*5.demo 模板渲染可以填充内容div&#123;fuck you $&#125;*5.demo 具体使用参考博客 Emmet-HTML&#x2F;CSS代码自动补全语法 (z01.com) CSS快速生成基本靠vs插件就行了，语法没啥用懒得记了 CSS元素显示模式三种显示模式元素（标签）以何种方式进行显示。块元素&lt;div&gt;独占一行，行内元素一行可以放多个&lt;span&gt;，HTML分为两种类型，块元素和行内元素两种类型。 常用块元素h1~h6,p,div,ul,ol,li 块元素特点 独占一行 高度宽度内外边距都可控 默认宽度是容器（父级）的100% 是容器盒子，内部由行内或者块元素 常用行内元素a,strong,b,em,i,del,s,ins,u,span 相邻行内元素再一行上，一行可以显示多个 高宽设置无效 默认宽度即本身宽度 行内元素只能容纳行内元素和文本（链接不能放链接） 兼具行内元素和块元素特点，称为行内块元素，img,input,td 和相邻行内元素（行内块）再一行上，但是之间有空白间隙，一行可以显示多个（行内元素） 默认宽度就是本身内容的宽度（行内元素） 高度行高内外边距可以控制（块级元素） 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块元素 可设置宽度高度 容器的100% 任何标签 行内元素 一行可以放个多个行内元素 不可直接设置宽度高度 本身内容宽度 文本或其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度高度 本身内容宽度 显示模式转换使用标签display，比如想要把超链接范围扩大，或者把块级元素在一行里面放多个。例子如下： 123456789101112131415161718192021a &#123; width: 150px; height: 50px; background-color: pink; /* 把行内元素 a 转换为块级元素 */ display: block;&#125;div &#123; width: 300px; height: 100px; background-color: purple; /* 把 div 块级元素转换为行内元素 */ display: inline;&#125;span &#123; width: 300px; height: 30px; background-color: skyblue; /*把span行内元素转换为行内块元素*/ display: inline-block;&#125; *单行文字垂直居中技巧：行高等于盒元素高度，即line-height和height取一样即可。 CSS背景123456789div&#123; width: 300px; height: 300px; background-color: pink; background-image: url(images/logo.png); background-repeat: no-repeat; background-position: right center; background-position: 10px 20px;/*左上角相对于左上角*/&#125; background-position：x y属性可以使用两种：方位名词和精确单位，精确单位为左上角相对左上角 参数 说明 length 百分数|由浮点数和单位标识符构成的长度值 position top|center|bottom|left|center|right 1234567891011body &#123; background-image: url(images/bg.jpg); background-repeat: no-repeat; background-position: center top; /* 把背景图片固定住 */ background-attachment: fixed;/*默认scroll*/ color: #fff;/*文本颜色*/ font-size: 20px;&#125;/*以上可以采用复合写法*/background: black url(images/bg.jpg) no-repeat fixed center top; 若要使背景半透明，可以对background-color使用rgba色，具体用的时候自己百度 属性 作用 值 background-color 背景颜色 RGB代码或预定义的色值 background-image 背景图片 url路径 background-repeat 是否平铺 repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y background-position 背景位置 length&#x2F;position，先x后y background-attachment 背景附着 scroll&#x2F;fixed 背景简写 简写 背景颜色 图片地址 平铺 滚动 位置 背景色半透明 颜色半透明 background:rgba(a,b,c,d) CSS三大特性CSS层叠性相同选择器给设置相同的样式，其中一个样式会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。层叠性的原则： 样式冲突遵循就近原则，哪个离得近执行哪个 样式不冲突，不层叠 CSS继承性子标签会继承父标签的某些样式，比如文本颜色和字号等等 恰当使用可以简化代码降低CSS样式复杂性 子元素可以继承父元素样式(text-及font-及line-开头元素和color) 在继承时如果没有额外指定（层叠性）那么默认属性值会是父标签的对应样式属性值 CSS优先级当同一个元素被指定了多个选择器则会有优先级的产生。选择器相同则执行层叠性，否则根据选择器的权重进行执行： 选择器 选择器权重 继承或者通用选择器* 0，0，0，0 元素选择器(标签选择器) 0，0，0，1 类选择器、伪类选择器 0，0，1，0 ID选择器 0，1，0，0 行内样式style 1，0，0，0 !important 无穷大 整的这么麻烦核心是为了计算权重的叠加。 1234567891011ul li &#123; color: green;&#125;/* li 的权重是 0,0,0,1 1 */li &#123; color: red;&#125;/* .nav li 权重 0,0,1,0 + 0,0,0,1 = 0,0,1,1 11 */.nav li &#123; color: pink;&#125; 最重要记住继承的权重是0 坑点：连写需要同时具备才会出现效果，权重是连写组合中最大的一个,比如li.active、.one.two CSS盒子模型（重要）目标 准确阐述盒子模型的4个组成部分 利用边框复合写法给元素添加边框 计算盒子的实际大小 利用盒子模型布局模块 给盒子设置圆角边框 给盒子添加阴影 给文字添加阴影 核心在于模型本身、浮动和定位 网页布局的基本过程： 准备好相关网页元素，网页元素本身基本都是盒子Box 利用CSS设置好盒子的样式，然后摆放到相应位置 往盒子中添加内容 核心本质就是利用CSS摆盒子。 盒子模型组成分为四个部分border,content,padding和margin。 border边框 content内容 padding内边距，控制边框到内容的距离 margin外边距，控制两个盒子之间的距离 除了content其他都有四个二级属性top&#x2F;left&#x2F;right&#x2F;bottom 边框相关边框由三部分组成：边框宽度、样式和颜色，具体的： 1border:border-width || border-style || border-color 属性 作用 border-width 定义边框粗细，单位是px border-style 定义边框的样式 border-color 边框的颜色 具体属性值可自行查阅手册，style用得比较多的是solid&#x2F;dashed&#x2F;dotted。同样的属性具有符合写法： 12345678910111213 div &#123; width: 300px; height: 200px; /* border-width: 5px; border-style: solid; border-color: pink; */ /* 边框的复合写法 简写: */ border: 5px solid pink; /* 上边框 */ border-top: 5px solid pink; /* 下边框 */ border-bottom: 10px dashed purple;&#125; 同时如果两个盒子连接（外边距为0）的话，可能会出现边框变粗的情况，这时候可以使用border-collapse:collapse使之合并。 需要注意的是边框会增加盒子本身的大小，比如设置了300*200的盒子，给了10像素边框，那么实际的盒子大小是320*220（左右上下各加10）。 内边距相关用于控制内容和内边框的距离，简写属性可以有一到四个值： 值的个数 表达意思 padding:5px; 上下左右5像素内边距 padding:5px 10px; 上下5，左右10 padding:5px 10px 20px; 上下5，左右10，下20 padding:5px 10px 20px 30px; 上向左右分别5、10、20、30 和边框类似，内边距同样会增加盒子的大小 外边距相关用于控制盒子和盒子之间距离，意思和内边距完全一致，不再重复，不同的是外边距不会增加盒子的大小。 外边距典型应用使得块级盒子水品居中，但是得满足两个条件： 盒子必须指定了宽度 盒子左右外边距设置为auto 1.header&#123;width:960px;margin:0 auto;&#125; 常见写法： margin-left:auto; margin-right:auto margin:auto; margin:0 auto; 注意：上述方法只能适用于块级元素，对于行内元素和行内块元素水平居中则应该给其父元素添加text-align:center，同时竖直居中则是将行高设的和高度相同即可。 外边距合并 相邻块元素垂直外边距合并：使用margin定义块元素的垂直外边距时候可能会出现外边距的合并，选择一个大的作为外边距，尽量只给一个盒子设置外边距： 嵌套的块元素垂直外边距塌陷：对于两个嵌套关系（父子关系）的块元素，父元素上外边距同时子元素也有上外边距，此时父元素会塌陷为较大的外边距值 ​ 清除内外边距网页元素常常有自己的默认内外边距，不同浏览器不同，于是还是得自己手动清除。通常来说上手写css第一个就是： 1234* &#123; margin: 0; padding: 0;&#125; 圆角边框使用border-radius属性 123456789101112131415161718192021222324252627282930/*以矩形中心画圆消除角*/div &#123; width: 300px; height: 150px; background-color: pink; border-radius: 10px;&#125;.yuanxing &#123; width: 200px; height: 200px; background-color: pink; /* border-radius: 100px; */ /* 50% 就是宽度和高度的一半 等价于 100px */ border-radius: 50%;&#125;.juxing &#123; width: 300px; height: 100px; background-color: pink; /* 圆角矩形设置为高度的一半 */ border-radius: 50px;&#125;.radius &#123; width: 200px; height: 200px; /* border-radius: 10px 20px 30px 40px; */ /* border-radius: 10px 40px; */ border-top-left-radius: 20px; background-color: pink;&#125; 阴影盒子阴影box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3); 各个参数具体作用： 值 描述 h-shadow 相对水平位置，可负值 v-shadow 相对垂直位置，可负值 blur 可选，模糊距离 spread 可选，阴影尺寸 color 可选，阴影颜色 inset 可选，外部阴影改为内部 文字阴影text-shadow，类似拥有： 值 描述 h-shadow 相对水平位置，可负值 v-shadow 相对垂直位置，可负值 blur 可选，模糊距离 color 可选，阴影颜色","categories":[{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"}],"tags":[{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://kimanyang.xyz/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS盒模型","slug":"CSS盒模型","permalink":"https://kimanyang.xyz/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"}]},{"title":"LRU和LFU缓存设计","slug":"LRU和LFU缓存设计","date":"2022-02-18T15:11:14.000Z","updated":"2022-03-10T15:39:49.153Z","comments":true,"path":"2022/02/18/LRU和LFU缓存设计/","link":"","permalink":"https://kimanyang.xyz/2022/02/18/LRU%E5%92%8CLFU%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"STL双向链表容器(List)的使用及LRU和LFU缓存设计创建方法 123456789using namespace std;/*类似与vector*/list&lt;int&gt; vals;list&lt;int&gt; vals(10);list&lt;int&gt; vals(10,5);/*origin移动到target位置*/vals.splice(target_iterator,vals,origin_iterator);/*moveToHead功能*/vals.splice(vals.begin(),vals,origin_interator); List使用 成员函数 具体功能 begin() 首个迭代器 end() 末尾迭代器 front() 首个元素引用 back() 末尾元素引用 size() 包含元素个数，复杂度$O(1)$ push_front()push_back() 首部（尾部）插入元素 splice() （重要）将一个元素移动到另一个位置 push_front()push_back() 首部（尾部）删除元素 LRU设计请你设计一个满足LRU最近最少使用缓存约束的数据结构。 实现LRUCache: 以正整数作为容量，capacity初始化缓存 int get(int key)方法根据关键字key获取缓存的值，否则返回- void put(int key, int val)在关键字存在则变更val，否则插入键值对。如果插入操作使得关键字数量超过capacity则逐出最久未使用(未被查询)的关键字 要求所有操作的时间复杂度都是$O(1)$。分析要求可以看出给定。 做法是采用一个链表加哈希表，链表存储先后顺序，链表能够达成$O(1)$的删除，而哈希表能够达成$O(1)$的索引，具体实现如下，一般会要求自己整个链表，链表内容为键值对的主要原因是在哈希表中删除的时候需要索引其键： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class BiList&#123;public: int value; int key; BiList* prev; BiList* next; BiList():key(0),value(0),prev(nullptr),next(nullptr)&#123;&#125; BiList(int k,int v):key(k),value(v),prev(nullptr),next(nullptr)&#123;&#125;&#125;;class LRUCache &#123;private: int cap; int cursize; BiList* head; BiList* tail; unordered_map&lt;int, BiList*&gt; dict;public: LRUCache(int capacity) &#123; this-&gt;cap = capacity; this-&gt;cursize = 0; this-&gt;head = new BiList(); this-&gt;tail = new BiList(); head-&gt;next = tail; tail-&gt;prev = head; &#125; int get(int key) &#123; if(!dict.count(key))&#123; return -1; &#125; BiList* tmp = dict[key]; movetoHead(tmp); return tmp-&gt;value; &#125; void put(int key, int value) &#123; if(!dict.count(key))&#123; BiList* node = new BiList(key,value); nodeAdd(node); dict[key] = node; cursize++; if(cursize &gt; cap)&#123; BiList* tmp = tail-&gt;prev; nodeDelete(tmp); dict.erase(tmp-&gt;key); delete tmp; cursize--; &#125; &#125;else&#123; BiList* tmp = dict[key]; tmp-&gt;value = value; movetoHead(tmp); &#125; &#125;private: void nodeAdd(BiList* node)&#123; node-&gt;prev = head; node-&gt;next = head-&gt;next; head-&gt;next-&gt;prev = node; head-&gt;next = node; &#125; void nodeDelete(BiList* node)&#123; node-&gt;next-&gt;prev = node-&gt;prev; node-&gt;prev-&gt;next = node-&gt;next; node-&gt;next = nullptr; node-&gt;prev = nullptr; &#125; void movetoHead(BiList* node)&#123; nodeDelete(node); nodeAdd(node); &#125;&#125;; 但是可以使用C++现成的链表，代码更加简洁，打的速度可以更快而且不用自己释放内存： 12345678910111213141516171819202122232425262728293031class LRUCache &#123;private: using pii = pair&lt;int, int&gt;; unordered_map&lt;int, list&lt;pii&gt;::iterator&gt; hash; list&lt;pii&gt; cache; int capacity;public: LRUCache(int capacity) &#123; this-&gt;capacity = capacity; &#125; int get(int key) &#123; if(!hash.count(key)) return -1; cache.splice(cache.begin(),cache,hash[key]); return hash[key]-&gt;second; &#125; void put(int key, int value) &#123; if(hash.count(key)) &#123; (hash[key])-&gt;second = value; cache.splice(cache.begin(),cache, hash[key]); &#125; else &#123; auto kv = pii(key,value); cache.push_front(kv); hash[key] = cache.begin(); if(cache.size() &gt; capacity) &#123; hash.erase(cache.back().first); cache.pop_back(); &#125; &#125; &#125;&#125;; LFU设计请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象 int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。 void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。 当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。 函数 get 和 put 必须以$ O(1) $的平均时间复杂度运行。 不同于LRU缓存，LFU缓存可以采用双哈希表或者哈希表与哈希集合（二叉平衡树）实现。todo","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LRU","slug":"LRU","permalink":"https://kimanyang.xyz/tags/LRU/"},{"name":"LFU","slug":"LFU","permalink":"https://kimanyang.xyz/tags/LFU/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"}]},{"title":"BitSet数据结构设计","slug":"BitSet数据结构设计","date":"2022-02-18T08:31:14.000Z","updated":"2022-03-10T15:31:45.473Z","comments":true,"path":"2022/02/18/BitSet数据结构设计/","link":"","permalink":"https://kimanyang.xyz/2022/02/18/BitSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"BitSet数据结构设计请你实现 Bitset 类。 Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。 void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。 void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。 void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。 boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。 boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。 int count() 返回 Bitset 中值为 1 的位的 总数 。 String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。 可以不进行压缩，题目没有限制空间，但是限制了时间，不能够对flip使用遍历方式实现，需要给一个懒加载的标记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Bitset &#123;private: vector&lt;int&gt; datas; int l = 0; int bitcount = 0; int ones = 0; //永远是实际的个数，根据懒标记决定是否取补 bool reversed = false;public: Bitset(int size) &#123; bitcount = size; datas.assign(size, 0); &#125; void fix(int idx) &#123; if(datas[idx] != 1 &amp;&amp; !reversed) &#123; ones++; datas[idx] = 1; &#125; else if(datas[idx] == 1 &amp;&amp; reversed) &#123; ones--; datas[idx] = 0; &#125; &#125; void unfix(int idx) &#123; if(datas[idx] != 0 &amp;&amp; !reversed) &#123; ones--; datas[idx] = 0; &#125; else if(datas[idx] == 0 &amp;&amp; reversed) &#123; ones++; datas[idx] = 1; &#125; &#125; void flip() &#123; reversed = reversed ? false : true; &#125; bool all() &#123; return reversed ? ones == 0 : ones == bitcount; &#125; bool one() &#123; return reversed ? ones != bitcount : ones &gt; 0; &#125; int count() &#123; return reversed ? bitcount - ones : ones; &#125; string toString() &#123; string ret = &quot;&quot;; for(auto&amp; n:datas) &#123; if(reversed) &#123; ret += n == 1 ? &quot;0&quot; : &quot;1&quot;; &#125; else &#123; ret += n == 1 ? &quot;1&quot; : &quot;0&quot;; &#125; &#125; return ret; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"BitSet","slug":"BitSet","permalink":"https://kimanyang.xyz/tags/BitSet/"},{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://kimanyang.xyz/tags/STL/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"lambda表达式、C++优先队列使用方式与多路归并总结","slug":"多路归并与C++优先队列使用方式总结","date":"2022-02-18T07:40:24.000Z","updated":"2022-03-10T15:28:52.409Z","comments":true,"path":"2022/02/18/多路归并与C++优先队列使用方式总结/","link":"","permalink":"https://kimanyang.xyz/2022/02/18/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E4%B8%8EC++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"lambda表达式、C++优先队列使用方式与多路归并总结虽然多次写过优先队列，但是每次写都需要查询C++的具体写法，有些还涉及到一些没有听说过的C++11特性，因此在本文给出多道类似题型的总结并一次性把设计优先队列的几种写法总结下来。顺便在开头复习一下在优先队列中可以使用的lambda表达式的相关知识。 前置知识之C++11特性lambda表达式基本形式lambda表达式也可以叫闭包、匿名函数啥的，基本的构造方法如下： 1[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125; 逐项解释下内部各项的实际意义： capture list :捕获列表，表示在lambda表达式中所能捕获的外部变量 params list: 形参列表 mutable：指示符，说明捕获的变量可否修改 exception：异常处理 return type: 返回类型 function body：函数体 也有常见地几种省略形式： 声明const类型地表达式，捕获列表的值不能被修改 1[capture list] (params list) -&gt; return type &#123;function body&#125; 这里省略了返回类型，但是编译器可以自己推导，面向auto编程就完事了 1[capture list] (params list) &#123;function body&#125; 无参函数，一般也可以叫做过程 1[capture list] &#123;function body&#125; 一个使用的例子： 123456auto mylambda = [](int a, int b) -&gt; bool &#123; return a &lt; b;&#125;if(mylambda(1,2)) &#123; std::cout&lt;&lt;&quot;fuck you&quot;;&#125; else &#123; std::cout&lt;&lt;&quot;fuck me&quot;;&#125; 捕获外部变量的方式目前我们没有详细讲解捕获的外部变量是否可以被函数内部修改，同参数的传递有值传递和引用传递方式一样，lambda表达式捕获外部变量的方式也有值捕获和引用捕获，除此以外还有隐式捕获和混合捕获方式。 1.值捕获对于被值捕获的变量，lambda的内部函数体无法改变值，一个具体的例子如下： 1234string fuck = &quot;fuck&quot;;auto f = [fuck]&#123;std::cout &lt;&lt; fuck &lt;&lt; endl;&#125;;fuck = &quot;good&quot;;f();//输出fuck 可见值捕获会在闭包内部创建一个捕获对象的副本，从而使得后续的改变无法对闭包内部的值产生影响，调用闭包时输出的仍然是捕获时对象的值。这种做法会带来额外的性能开销。需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。如果要进行修改需要把函数改为mutable，具体如下： 1234string fuck = &quot;fuck&quot;;auto f = [fuck]()mutable &#123; fuck = &quot;good&quot;;std::cout &lt;&lt; fuck; &#125;; // 不会报错std::cout &lt;&lt; fuck &lt;&lt; endl; // 输出：fuckf(); // 输出：good 2.引用捕获对于引用捕获，要在函数的外部加上引用指示符&amp;，类似的例子： 1234string fuck = &quot;fuck&quot;;auto f = [&amp;fuck]&#123;std::cout &lt;&lt; fuck &lt;&lt; endl;&#125;;fuck = &quot;good&quot;;f();//输出good 此时闭包捕获外部对象的引用，无论是在闭包内对变量的修改抑或是在外部直接对变量进行修改都会是的变量的值发生改变。 3.隐式捕获大部分语言实际上都采用隐式捕获让编译器自行判断捕捉啥变量，C++支持两种隐式捕获，全值捕获和全引用捕获，分别用[=]和[&amp;]表示。给出示例： 123456789101112string fuck1 = &quot;fuck you&quot;;string fuck2 = &quot;fuck me&quot;;auto f1 = [=]&#123;std::cout&lt;&lt;fuck1&lt;&lt;&quot; &quot;&lt;&lt;fuck2&lt;&lt;endl;&#125;;auto f2 = [&amp;]&#123;std::cout&lt;&lt;fuck1&lt;&lt;&quot; &quot;&lt;&lt;fuck2;&#125;;fuck1 = &quot;hello&quot;;fuck2 = &quot;world&quot;;f1();//输出 fuck you fuck mef2();//输出 hello world 4.混合捕获顾名思义就是既有值捕获也有引用捕获，具体来说有如下几种： 代码形式 捕获说明 [] 要求闭包不捕获任何外部变量 [var1, var2 …] 捕获对应变量名变量 [this] 以值捕获形式获取this指针（能不能修改？应该不能） [&#x3D;] 自动值捕获 [&amp;] 自动引用捕获 [&#x3D;,&amp;x] 对于x引用捕获，其他默认值捕获 [&amp;,&#x3D;x] 对于x值捕获，其他默认引用捕获 lambda表达式参数几点注意 参数列表和函数不同，不能有默认参数 不支持可变的参数，即**不是基本变量得加个const**在参数名之前 所有参数必须有参数名 嵌套使用的应用实例1234567891011//lambda表达式的嵌套int m = [](int x) &#123; return [](int y) &#123; return y * 2; &#125;(x)+6;&#125;(5);std::cout &lt;&lt; &quot;m:&quot; &lt;&lt; m &lt;&lt; std::endl; //输出m:16，即5*2 + 6//lambda表达式使用lambda表达式作为传参和返回值（开始魔幻起来了，但对脚本语言属于常规操作）auto gFunc = [](int x) -&gt; function&lt;int(int)&gt; &#123; return [=](int y) &#123; return x + y; &#125;; &#125;;auto lFunc = gFunc(4);std::cout &lt;&lt; lFunc(5) &lt;&lt; std::endl;auto hFunc = [](const function&lt;int(int)&gt;&amp; f, int z) &#123; return f(z) + 1; &#125;;auto a = hFunc(gFunc(7), 8); STL中优先队列的写法写在之前先抛开STL的优先队列，让我们对最大堆最小堆的原理有一个清晰的认识，常规的最大堆写法一般使用一个数组容器实现： 12345678910111213141516171819202122232425262728293031323334353637383940vector&lt;int&gt; heap;//获取最大值int top() &#123; return heap[0];&#125;//插入值，新数字在最后，并进行上浮void push(int k) &#123; heap.push_back(k); swim(heap.size()-1);&#125;//删除最大值，把最后一个数字移到开头并进行下沉void pop() &#123; heap[0] = heap.back(); heap.pop_back(); sink(0);&#125;//核心操作，下沉void swim(int pos) &#123; while(pos &gt; 1 &amp;&amp; heap[pos/2] &lt; heap[pos]) &#123; swap(heap[pos/2], heap[pos]); pos /= 2; &#125;&#125;//核心操作，上浮void sink(int pos) &#123; int N = heap.size(); while(2 * pos &lt;= N) &#123; int i = 2 * pos; if(i &lt; N &amp;&amp; heap[i] &lt; heap[i + 1]) ++i;//选取叶子中小的那个 if(heap[pos] &gt;= heap[i]) break;//已经沉到底了 swap(heap[pos],heap[i]); pos = i; &#125;&#125; 相关API top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素 emplace 原地构造一个元素并插入队列 pop 弹出队头元素（即消除top，使用top()再用pop()等同于Java的poll） swap 交换内容（很少用到） 最基本的一种写法，只能适应基本的数据结构： 简单写法12345678//默认是大顶堆priority_queue&lt;int&gt; a; //升序的小顶堆 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序的大顶堆 priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q; greater和less作为仿函数重载了操作符()从而使得数据结构的比较特性得到实现。 结构体自定义写法这里介绍两种，一种是结构体内的重载实现比较，一种是定义比较结构体 方法11234567891011121314struct mystruct //运算符重载&lt;&#123; pair&lt;int, int&gt; p; //构造函数列表初始化 mystruct(int a, int b) &#123; p.first = a; p.second = b; &#125; //重载操作符 bool operator&lt;(const mystruct&amp; a) const &#123; return this-&gt;p.first &lt; a.p.first; //大顶堆 &#125;&#125;; 具体使用时： 12345mystruct a(1,2);mystruct b(2,3);priority_queue&lt;mystruct&gt; pq;pq.push(a);pq.push(b); 这种方法的数据结构比较受限，很多时候数据结构是别人给的未必能够直接跑到别人的类里面去重载操作符，所以用的还是比较少。 方法2我在合并K个升序列表中使用的定义方法 1234567//重载仿函数struct cmp &#123; bool operator ()(ListNode* a, ListNode* b)&#123; return (a-&gt;val) &gt; (b-&gt;val); &#125;&#125;;priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp &gt; q; 此处详细说明一下，比较函数是用于优先队列底层容器vector中元素的比较，小顶堆重载时用大于号，大顶堆重载时用小于号，q.top()是内部元素最小的链表指针。具体使用时对于这道题如下所示： 1234567891011121314151617181920ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode dummy = ListNode(-1); ListNode* cur = &amp;dummy; for(auto&amp;&amp; node:lists) &#123; if(node)&#123; q.push(node); &#125; &#125; while(!q.empty())&#123; ListNode* l1 = q.top(); q.pop(); cur-&gt;next = l1; cur = cur-&gt;next; l1 = l1-&gt;next; if(l1)&#123; q.push(l1); &#125; &#125; return dummy.next;&#125; 方法3根据C++11中引入的特性，使用lambda表达式，和sort函数中的使用如出一辙，给出二者代码进行一下比较： 自定义排序 1234567vector&lt;pair&lt;int, int&gt;&gt; frac; /**...some operation...**/sort(frac.begin(), frac.end(), [&amp;](const auto&amp; x, const auto&amp; y) &#123; return x.first * y.second &lt; x.second * y.first;&#125;); 自定义优先队列 12345//vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2作为捕获列表的参数，当然也可以不加区分地使用[&amp;]auto cmp = [&amp;nums1, &amp;nums2](const pair&lt;int, int&gt; &amp; a, const pair&lt;int, int&gt; &amp; b) &#123; return nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];&#125;;priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp) &gt; pq(cmp); 这里需要简单解释的是decltype(cmp)这一写法。由于cmp是自动推导出来的lambda表达式，它的类型实际上应该是一个函数（仿函数），decltype(expr)的结果根据expr的结果不同而不同：expr返回左值，得到该类型的左值引用；expr返回右值，得到该类型。和方法二略有不同的一点还在于初始化时要传入参数cmp，因为lambda表达式这种特殊的类（不同于struct和class）没有默认自身的构造函数，所以需要通过传入已有的lambda对象示例进行拷贝构造，使得优先队列内部能够使用。 多路归并样板题目上面的内容主要为了这部分做一点点铺垫，相关性不是很大，因为在多路归并算法中大量使用了优先队列，于是需要先总结一下优先队列的知识。 经典题目：丑数(264)给你一个整数 n ，请你找出并返回第 n 个 丑数 。 丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。 解法1优先队列使用一个优先队列和哈希集合判断。 1234567891011121314151617181920212223class Solution &#123; using LL = long long;public: int nthUglyNumber(int n) &#123; unordered_set&lt;LL&gt; inNum; vector&lt;int&gt; tab = &#123;2,3,5&#125;; priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq; pq.push(1); for(int i = 1;i &lt;= n;++i) &#123; LL k = pq.top(); pq.pop(); if(i == n) return k; for(auto&amp; num : tab) &#123; LL t = num * k; if(!inNum.count(t)) &#123; pq.push(t); inNum.insert(t); &#125; &#125; &#125; return -1; &#125;&#125;; 解法2动态规划12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n + 1); dp[1] = 1; int p2 = 1, p3 = 1, p5 = 1; for (int i = 2; i &lt;= n; i++) &#123; int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5; dp[i] = min(min(num2, num3), num5); if (dp[i] == num2) &#123; p2++; &#125; if (dp[i] == num3) &#123; p3++; &#125; if (dp[i] == num5) &#123; p5++; &#125; &#125; return dp[n]; &#125;&#125;; 扩展题313超级丑数，思路完全相同 12345678910111213141516171819202122232425class Solution &#123;private: using ll = long long;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; vector&lt;ll&gt; dp(n + 1);dp[1] = 1; int pcnt = primes.size(); vector&lt;int&gt; pointers(pcnt,1); vector&lt;ll&gt; mins(pcnt,0); for(int i = 2;i &lt;= n;++i) &#123; ll curMin = INT_MAX; for(int k = 0;k &lt; pcnt;++k) &#123; mins[k] = ll(dp[pointers[k]]) * primes[k]; curMin = min(curMin, mins[k]); &#125; dp[i] = curMin; for(int k = 0;k &lt; pcnt;++k) &#123; if(mins[k] == curMin) &#123; pointers[k]++; &#125; &#125; &#125; return dp[n]; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://kimanyang.xyz/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"优先队列","slug":"优先队列","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"多路归并","slug":"多路归并","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://kimanyang.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"排序方法总结","slug":"排序方法总结","date":"2022-02-16T08:16:24.000Z","updated":"2022-03-10T15:29:17.417Z","comments":true,"path":"2022/02/16/排序方法总结/","link":"","permalink":"https://kimanyang.xyz/2022/02/16/%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"排序方法总结常用的排序总结 算法 平均时间复杂度 最差时间复杂度 空间复杂度 稳定性 插入排序 $O(n^2)$ $O(n^2)$ $O(1)$ 是 选择排序 $O(n^2)$ $O(n^2)$ $O(1)$ 是 冒泡排序 $O(n^2)$ $O(n^2)$ $O(1)$ 是 快速排序 $O(n\\log n)$ $O(n^2)$ $O(\\log n)$ 否 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(\\log n)$ 是 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(\\log n)$ 是 桶排序和希尔排序就暂时不考虑了。 手撕快速排序（Quick Sort)采用左闭右开的二分写法： 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); quickSort(nums,0,n); return nums; &#125; void quickSort(vector&lt;int&gt;&amp; nums, int l, int r) &#123; if(r - l &lt;= 1) return; int part = partition(nums,l, r); quickSort(nums,l,part); quickSort(nums,part, r); &#125; int partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int midIdx = (r - l)/2 + l; swap(nums[l],nums[midIdx]); int first = l, last = r - 1, mid = nums[l]; while(first &lt; last) &#123; while(first &lt; last &amp;&amp; nums[last] &gt; mid) last--; if(first &lt; last) &#123;nums[first] = nums[last];first++;&#125; while(first &lt; last &amp;&amp; nums[first] &lt; mid) first++; if(first &lt; last) &#123;nums[last] = nums[first];last--;&#125; &#125; nums[first] = mid; return first; &#125;&#125;; 这里强调一下取随机中点作为partition还是很有必要的，毕竟给了个专门卡快排的示例 模板快速选择，根据快排原理进行找到第k大的数,采用左开右闭写法 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; return quickSelect(nums,0,nums.size(), k - 1); &#125; int quickSelect(vector&lt;int&gt;&amp; nums, int l, int r, int idx) &#123; int part = partition(nums,l, r); if(part == idx) &#123; return nums[part]; &#125; else &#123; if(part &lt; idx) &#123; return quickSelect(nums,part,r,idx); &#125; else &#123; return quickSelect(nums,l,part,idx); &#125; &#125; &#125; int partition(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int midIdx = ((r - l) &gt;&gt; 1) + l; swap(nums[l],nums[midIdx]); int first = l, last = r - 1, mid = nums[l]; while(first &lt; last) &#123; while(first &lt; last &amp;&amp; nums[last] &lt; mid) last--; if(first &lt; last) &#123;nums[first] = nums[last];first++;&#125; while(first &lt; last &amp;&amp; nums[first] &gt; mid) first++; if(first &lt; last) &#123;nums[last] = nums[first];last--;&#125; &#125; nums[first] = mid; return first; &#125;&#125;; 附优先队列写法： 1234567891011121314151617181920class Solution &#123;public: string kthLargestNumber(vector&lt;string&gt;&amp; nums, int k) &#123; auto cmp = [&amp;](const string s1, const string s2)-&gt;bool &#123; if(s1.size() &gt; s2.size()) &#123; return true; &#125; else if(s1.size() &lt; s2.size()) &#123; return false; &#125; else &#123; return s1 &gt; s2; &#125; &#125;; priority_queue&lt;string, vector&lt;string&gt;, decltype(cmp) &gt; pq(cmp); for(auto&amp; str:nums) &#123; pq.push(str); if(pq.size() &gt; k) &#123;pq.pop();&#125; &#125; return pq.top(); &#125;&#125;; 手撕归并排序容易理解版本（左闭右开）12345678910111213141516171819202122232425262728293031323334func merge(arr1, arr2 []int) (ret []int) &#123; for len(arr1) &gt; 0 &amp;&amp; len(arr2) &gt; 0 &#123; if arr1[0] &gt; arr2[0] &#123; ret = append(ret, arr1[0]) arr1 = arr1[1:] &#125; else &#123; ret = append(ret, arr2[0]) arr2 = arr2[1:] &#125; &#125; for len(arr1) &gt; 0 &#123; ret = append(ret, arr1[0]) arr1 = arr1[1:] &#125; for len(arr2) &gt; 0 &#123; ret = append(ret, arr2[0]) arr2 = arr2[1:] &#125; return&#125;func MergeSort(arr []int) (ret []int) &#123; if len(arr) &lt;= 1 &#123; return arr &#125; mid := len(arr) / 2 l := len(arr) left := MergeSort(arr[0:mid]) right := MergeSort(arr[mid:l]) ret = merge(left, right) return&#125; 利用双指针和单个额外数组版本Go版本的左闭右闭 123456789101112131415161718192021222324252627282930313233343536func MergeSort(arr []int, temp []int, st, end int) &#123; if st &gt;= end &#123; return &#125; l := end - st mid := (l &gt;&gt; 1) + st MergeSort(arr, temp, st, mid) //假设此时st/mid有序了 MergeSort(arr, temp, mid+1, end) //假设此时mid+1/st有序了 //两个有序数组归并 p1 := st p2 := mid + 1 k := st for p1 &lt;= mid &amp;&amp; p2 &lt;= end &#123; if arr[p1] &lt; arr[p2] &#123; temp[k] = arr[p1] p1++ &#125; else &#123; temp[k] = arr[p2] p2++ &#125; k++ &#125; for p1 &lt;= mid &#123; temp[k] = arr[p1] k++ p1++ &#125; for p2 &lt;= end &#123; temp[k] = arr[p2] k++ p2++ &#125; for k := st; k &lt;= end; k++ &#123; arr[k] = temp[k] &#125;&#125; C++版本的左闭右开 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret(n, 0); mergeSort(nums,ret,0,n); return nums; &#125; void mergeSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; tmp, int l, int r) &#123; if(r - l &lt;= 1) return; int mid = (r-l)/2+l; mergeSort(nums,tmp,l,mid); mergeSort(nums,tmp,mid,r); int p1 = l, p2 = mid, k = l; while(p1 &lt; mid &amp;&amp; p2 &lt; r) &#123; if(nums[p1] &lt; nums[p2]) &#123; tmp[k] = nums[p1]; p1++; &#125; else &#123; tmp[k] = nums[p2]; p2++; &#125; k++; &#125; while(p1 &lt; mid) &#123; tmp[k] = nums[p1]; p1++;k++; &#125; while(p2 &lt; r) &#123; tmp[k] = nums[p2]; p2++;k++; &#125; for(int i = l;i &lt; r;++i) &#123; nums[i] = tmp[i]; &#125; &#125;&#125;; 手撕堆排序Golang版本的堆构建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func swap(arr *[]int, idx1, idx2 int) &#123; (*arr)[idx1], (*arr)[idx2] = (*arr)[idx2], (*arr)[idx1]&#125;//若子树满足堆条件，那adjust过的大树也满足堆条件func adjust(arr *[]int, last, idx int) &#123; cur_idx := idx left, right := 2*idx+1, 2*idx+2 if left &lt; last &amp;&amp; (*arr)[cur_idx] &lt; (*arr)[left] &#123; cur_idx = left &#125; if right &lt; last &amp;&amp; (*arr)[cur_idx] &lt; (*arr)[right] &#123; cur_idx = right &#125; if cur_idx != idx &#123; swap(arr, cur_idx, idx) adjust(arr, last, cur_idx) &#125;&#125;func enHeap(arr *[]int) &#123; //构建堆，从最右的非叶子节点开始可提高速度 last := len(*arr) for start := (len(*arr) - 1 - 1) / 2; start &gt;= 0; start-- &#123; adjust(arr, last, start) &#125;&#125;func heapPush(arr *[]int, num int) &#123; *arr = append(*arr, num) enHeap(arr)&#125;func heapPop(arr *[]int) (ret int) &#123; ret = (*arr)[0] swap(arr, 0, len(*arr)-1) adjust(arr, len(*arr)-1, 0) *arr = (*arr)[:len(*arr)-1] return&#125;func HeapSort(arr *[]int) &#123; enHeap(arr) //将当前堆最大（小）的数移到末尾并交换，对除末尾以外的数进行调整使之满足堆条件 for i := len(*arr) - 1; i &gt;= 0; i-- &#123; swap(arr, 0, i) adjust(arr, i, 0) &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"快速排序","slug":"快速排序","permalink":"https://kimanyang.xyz/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"https://kimanyang.xyz/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://kimanyang.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分法","slug":"二分法","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"(二)正则表达式解析算法详解","slug":"由实例开始构造正则引擎(2)正则算法详细介绍","date":"2022-01-26T11:58:24.000Z","updated":"2022-03-27T11:27:20.072Z","comments":true,"path":"2022/01/26/由实例开始构造正则引擎(2)正则算法详细介绍/","link":"","permalink":"https://kimanyang.xyz/2022/01/26/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(2)%E6%AD%A3%E5%88%99%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"正则表达式解析算法详解概述与背景知识本文将详细描述一个简单的正则引擎所需的所有算法，包括: 递归下降分析，构造正则表达式的抽象词法解析树 McMaughton-Yamada-Thompson算法，实现正则结构词法树转换成 前文讲述过的*到转换*进一步扩充，采用子集构造法 我们之前一笔带过的消除重复状态的Hopcrpft算法，也可称为到的转换 在开始讲解这些算法之前，先定义一下在这个系列中所使用的正则表达式类型为纯正则表达式，所描述的语法并不会超过乔姆斯基三型文法（正规文法）的表示范围。对扩展正则表达式不做要求。首先给出我们的正则表达式的扩展巴克斯范式文法表示，一个表达式由可选的多个“项(term)”并联而成，每个项由可选的多个因子(factor)(子因子和重复*、多次重复+、可选?)构成，每个子因子由字符(char)或者被括号括起来的表达式构成。 1234expr ::= term(\"|\"term)*term ::= factor*factor ::= (subfactor|subfactor (\"*\"|\"+\"|\"?\"))subfactor ::= char | \"(\" expr \")\" 为了更好地理解构造解析器的过程，这里没有引入过多的token，demo版本功能局限于匹配Ascii码表示范围内的非保留字符(左右小括号、星号、加号、问号)的正则表达式，很容易在这基础上进行扩充。 最后在开始之前，我们给出关于和在集合论基础上的形式化定义，这些定义有助于我们更好地理解算法，当然只要理解非确定与确定的区别在于后继转移状态是否唯一也完全足够了。 NFA（非确定有限状态自动机）： ——有限的状态集合 ——输入字母表，输入符号集合(假设空边不在中) ——转换映射，。具体来说，表示了从出发沿着边所能够到达的状态集合 ——开始状态，，有且仅有一个 ——终止状态集合， DFA（确定有限状态自动机）： ——有限的状态集合 ——输入字母表，输入符号集合(假设空边不在中) ——转换函数，。具体来说，表示了从出发沿着边所能够到达的唯一状态 ——开始状态，，有且仅有一个 ——终止状态集合， 递归下降分析我们以一个简单的正则表达式串为例讲解递归下降分析算法，我们这里采用自顶向下的最左推导方法。 给定正则表达式b?(ab+)|cd*，用表示规则的串联，则可以获得如下的词法解析树： 123456789101112131415161718192021222324252627graph TDvbar((\"|\"));add1((\"@\"));add2((\"@\"));add3((\"@\"));q((?));star((*));plus((+));char1((b));char2((a));char3((b));char4((c));char5((d));vbar --left--&gt; add1;vbar --right--&gt; add2;add1 --left--&gt;add3;add3 --left--&gt; q;q--left--&gt;char1;add3 --right--&gt;char2;add1 --right--&gt;plus;plus --left--&gt; char3;add2 --left--&gt;char4;add2 --right--&gt; star;star --left--&gt; char5; 接下来我们可以设计一个递归算法的雏形来表示递归下降构造树的过程，伪代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374token parse_expr();token parse_term();token parse_factor();token parse_char();/**文法 expr ::= term(\"|\"term)* 的解析过程 例如 term1 | temr2 | term3 的树为 expr(alt2(|)) / \\ alt1(|) term3 / \\ term1 term2**/token parse_expr() { t = parse_term(); while(cur_char == '|') { cur_char = get_next_char(); p = parse_term(); alt = new Tree_node_with_child_t_and_p(); t = alt; } return t;}/**文法 term ::= factor+ 的解析过程 例如 f1f2f3的树为(其中f1 f2 f3指三个factor) + / \\ + f3 / \\ f1 f2 **/token parse_term() { t = parse_factor(); while(currentChar == '(' || inalphabet(cur_char)) { cur_char = get_next_char(); p = parse_factor(); concat = new Tree_node_with_concat_child_t_and_p(); t = concat; } return t;}/**文法 factor ::= (subfactor|subfactor (\"*\"|\"+\"|\"?\")) 的解析过程 例如： a+ b? c* d的语法树分别为： oneMore option closure d / / / a b c**/token parse_factor() { t = parse_subfactor(); while(cur_char == '*' || cur_char == '+' || cur_char == '?') { cur_char = get_next_char(); case '*': subtype = new Tree_node_with_closure_and_child_t(); case '+': subtype = new Tree_node_with_oneMore_and_child_t(); case '?': subtype = new Tree_node_with_option_and_child_t(); t =subtype; } return t;}/**文法 subfactor ::= char | \"(\" expr \")\" 的解析过程 此处要么得到单个字符作为token返回，要么直接回到开始的表达式解析**/token parse_subfactor() { t = nullptr; if(cur_char == '(') { cur_char = get_next_char(); t = parse_expr(); cur_char = get_next_char();//这里忽略左右括号，并不单独给予token } else { t = new Tree_node_with_char_nochild(); cur_char = get_next_char(); //叶子节点可以跳过解析下一字符 } return t;} 这样我们手写的分析器就将所有的token都获取下来了，正式代码需要注意一下递归边界条件，在了解整个流程之后我们再定义一下所有的token类型： 12345678enum TokenType { CHAR, //字符 ALTER, // '|'连接符 CONCAT, //代表factor之间的连接关系，图中以'@'表示 KLEEN, //克林闭包，即符号'*' OPTION, //可选关系，即符号'?' P_KLEEN, //一个以上匹配的克林闭包，即符号'+'} Thompson算法现在我们已经将正则表达式字符串转换为一颗抽象语法解析树（AST）了，下面介绍通过Thompson算法将解析树转换为一个。该算法是语法制导的，也就是说它沿着正则表达式的语法解析树自底向上递归地进行处理，对于每一个子表达式，该算法构造一个只有一个接收状态的。再前一篇文章中有提到过这种构造法，现在我们详细复习一遍并给出伪代码实现。 基本规则 对于空边，构造如下: 1234graph LR;st((start));en{end};st -- 空边 --&gt; en; 对于字符集子表达式构造如下： 1234graph LR;st((start));en{end};st -- 字符集 --&gt; en; 归纳规则 规则的串联 12345678graph LR;st1((start));en1{end};st2((start));en2{end};st1 -- 子状态1 --&gt; en1;en1 -- 空边 --&gt; st2;st2 -- 子状态2 --&gt; en2; 规则的并联 123456789101112131415161718graph LR;st((start));en{end};st1((start));en1{end};st2((start));en2{end};st3((start));en3{end};st -- 空边 --&gt; st1;st -- 空边 --&gt; st2;st -- 空边 --&gt; st3;st1 --子状态1 --&gt;en1;st2 --子状态2 --&gt;en2;st3 --子状态3 --&gt;en3;en1 --空边--&gt;en;en2 --空边--&gt;en;en3 --空边--&gt;en; 规则的克林闭包 12345graph LR;st((start));en{end};st --子状态--&gt; en;en --空边 --&gt;st; 实例分析采用我们在递归下降分析中使用的例子b?(ab+)|cd*以及现成的语法分析树： 123456789 | / \\ @ @ / \\ / \\@ + c * / \\ / / ? a b d / b 通过后序遍历可以逐步构造出我们所需要的每一个状态，在对每一个子树的规则实施规纳规则时首先把子树规则的开始和结束状态转为普通状态。 遍历到b，对应着一个基本规则即接受b的规则 再到?，对应着串联一个左子树规则(接受b的规则)再并联一个空边的基本规则 再到a，对应这一个基本规则即接受a的规则 再到@符号，对应将左子树的规则和右子树的规则串联 再到b，对应着一个基本规则即接受b的规则 再到+，对应着左子树规则(接受b的规则)串联一个左子树(接受b的规则)规则的克林闭包 再到@，对应着左子树规则和右子树规则串联 再到c，对应着一个基本规则即接受c的规则 再到d，对应着一个基本规则即接受d的规则 再到*，对应着左子树规则(接受d的规则)的克林闭包 再到@，对应着左子树规则和右子树规则串联 最后来到根节点|，对应着左子树规则和右子树规则的并联 通过上述算法我们构造出了一个含有大量冗余状态和空边的，具体的状态机形式如下图所示： 1234567891011121314151617181920212223242526graph LR;st((start));st1((1));st3((3));st4((4));st5((5));st6((6));st7((7));st8((8));st9((9));st10((10));st11((11));st12((12));st13((13));st14((14));en{end};st -- 空边 --&gt;st1;st --空边 --&gt;st11;st1 --b--&gt;st3;st1 -- 空边 --&gt;st3;st3 --空边--&gt;st4;st4 -- 空边 --&gt; st5;st5 -- a --&gt;st6;st6--空边--&gt;st7;st7--b--&gt;st8;st8--空边--&gt;st9;st9--b--&gt;st10;st10 --空边--&gt;st9;st10 -- 空边 --&gt;en;st11 -- c --&gt; st12;st12 -- 空边 --&gt;st13;st13 -- d --&gt;st14;st14 --空边 --&gt;st13;st13 --空边--&gt;st14;st14 -- 空边 --&gt;en; 可以发现串联操作形成了大量的空边，在这里我们可以初步将这些串联操作引起空边相邻状态合并来消除空边而不影响状态机的正确性。 子集构造法在前一篇博文中我们介绍了如何消除空边的算法，但是并不能保证获得的不带空边的状态机一定会成为确定的状态机。下面先从理论上介绍完全消除不确定性的完整的子集构造法(subset construction)，再对上述例子实施子集构造法。 算法理论我们规定输入的非确定有限状态自动机是，最终输出的确定有限状态自动机是，通过子集构造法，中的每一个状态最终会是中的状态的集合。首先我们定义三种在上的操作，规定的状态集合为，设而，三种操作为： ，指从状态开始只通过空边所能够到达的上状态集合 ，指从集合中某个状态开始只通过空边所能够到达的上状态集合，即 ，指从集合中某个状态开始通过的边能够到达的上状态集合(不能走空边) 算法的流程如下： 其中指的是根据子集构造法最终能够构造出来的状态集。开始前将初始状态的加入状态集合。随后进行归纳的广度优先搜索，将经由能够到达的状态集合的作为的一个状态并不加标记，直到最终的所有状态都是被标记的。 实例分析示例给出正则表达式b?abb?|cd由Thompson算法得到的非确定有限状态自动机： 1234567891011121314151617graph LR;st((start));st1((1));st3((2));st4((3));st5((4));st6((5));st7((6));st8((7));st9((8));en{end};st -- ε --&gt; st1;st -- ε --&gt; st7;st1 -- b --&gt; st3;st1 -- ε --&gt;st3;st7 -- c --&gt; st8;st3 -- a --&gt; st4;st4 -- b --&gt; st5;st5 -- b --&gt; st6;st5 -- ε --&gt; st6;st8 -- d --&gt; st9;st9 -- ε --&gt;en;st6 -- ε --&gt;en; 对于上述的状态机模型我们采用子集构造法，首先定义字符集和状态转换表，可以看出状态总共有10个，字符集，于是有如下的状态转换表（一个状态的包括其自身）： a b c d start {st,1,2,6} {3} {2} {7} 状态1 {1,2} {3} {2} 状态2 {2} {3} 状态3 {3} {4} 状态4 {4,5,end} {5} 状态5 {5,end} 状态6 {6} {7} 状态7 {7} {8} 状态8 {8,end} end {end} 开始时刻我们的 集合下标tag表示被标记 标记初始的状态，遍历字符集， 查表状态{st, 1，2，6}经由可达状态的有{3}，于是将{3}不加标记加入状态集合中，同时将边{st, 1,2,6}经由a到{3}加入转换函数 查表状态{st, 1，2，6}经由可达状态的有{2}，于是将{2}不加标记加入状态集合中，直接将边{st, 1,2,6}经由b到{2}加入转换函数 查表状态{st, 1，2，6}经由可达状态的有{7}，于是将{7}不加标记加入状态集合中，同时将边{st, 1,2,6}经由c到{7}加入转换函数 查表状态{st, 1，2，6}经由d可达状态啥也没有 此时我们的，取出状态{3}，遍历字符集 查表状态{3}经由a/c/d啥也到达不了，经由b可以到达的状态的有{4，5，end}，于是将{4,5,end}不加标记加入状态集合中，同时将边{3}经由b到{4,5,end}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag}{ 2} {7} {4,5,end} }$，取出状态{7}，遍历字符集 查表状态{7}经由a/b/c啥也到达不了，经由b可以到达的状态的有{end,8}，于是将{end,8}不加标记加入状态集合中，同时将边{7}经由d到{end,8}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}_{tag} {2} {4,5,end} {end,8} }$，取出状态{2},遍历字符集 状态2经由b/c/d啥也到达不了，经由a到达的{3}已经在集合中了，于是将{2}经由a到达{3}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end} {end,8} }$，取出状态{4,5,end}，遍历字符集 查表状态{4,5,end}经由a/c/d啥也到达不了，经由b到达的{5,end}，于是将{5,end}不加标记地加入状态集合中，同时将边{4,5,end}经由b到{5,end}加入转换函数 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end}_{tag} {end,8} {5,end} }$，取出状态{end,8}遍历字符集，所得的{end,8}已在集合中，没有可得状态 此时我们的$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end}{tag} {end,8}{tag} {5,end} }$，取出最后一个状态{5,end}，遍历字符集，所得的{end,5}已在集合中，没有可得状态 至此算法结束，我们得到了一个状态集合$Dstates = { {st,1,2,6}{tag} {3}{tag} {7}{tag} {2}{tag} {4,5,end}{tag} {end,8}{tag} {5,end}_{tag} }，以及它们对应的边和转换函数，在算法执行过程中我们可以直接将含有end状态的新状态标记为DFA$的终止状态，让我们重新命名这几个状态并将其转换函数表展现出来： 状态 状态 a b c d {st,1,2,6} A B D C {3} B E {7} C F {2} D B {4,5,end} E G {end,8} F {5,end} G 根据上述的状态转换表得到下面的b?abb?|cd对应图: 1234567891011graph LR;A((A));B((B));C((C));D((D));E{E};F{F};G{G};A --a --&gt;B;A --b --&gt;D;A --c --&gt;C;B -- b --&gt; E;C -- d --&gt;F;D -- a --&gt;B;E -- b --&gt;G; 子集构造法在其自身运行的过程中已经完成了我们在第一篇博客中所说的的消除空边的要求以及消除不确定性的要求，因此也不需要额外运行消除空边的算法了，但单纯消除空边并模拟带回溯来验证正则表达式在某些场景下效率可能并不低，所以先前所说的算法也存在应用场景。具体可以参考3.7.5节的和效率的分析，对于构建高效的正则引擎或者不同场景下的正则引擎优化很有帮助。 在这里额外说明一下，存在算法可以直接通过正则表达式的语法分析树获得其对应，可以参考《编译原理》第二版（即大家都很熟悉的龙书）的3.9.2节内容。 Hopcrpft算法该算法用于最小化一个的状态数，正如我们在前一篇博文中所描述的解析C语言数字的正则表达式可以有 ([+-]?\\\\\\\\d+)|([+-]?((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?)\\\\\\\\d+ ([+-]?(\\\\\\\\d+(\\\\\\\\.\\\\\\\\d*)?|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?\\\\\\\\d+)? 两种，显然第二种更短，两个正则表达式对应的也很可能是不同的。进一步地，我们在做题求解自动机的过程中已经发现了存在一些相同的状态可以进行化简，Hopcrpft算法可以在的时间复杂度以内做到这件事。下面我们就介绍与化简相关的理论知识。 算法理论不加证明地给出一个结论：任何正则语言都有一个唯一的（不计同构）状态数目最小的，而且从任意一个接受相同语言的出发，通过分组合并等价的状态，我们总是可以构建得到状态数目最小的。 首先定义在中两个状态什么情况下是可区分的，这对于我们理解什么状态可以进行合并十分有帮助。 可区分性：如果我们从两个状态和出发，沿着标号为的路径到达了两个状态，这两个状态之中只有一个是终止状态，那么我们称这个串能够区分状态和。如果对于两个状态和存在这样的串，那么这两个状态就是可区分的。 显然一个空串能够区分非终止状态和非终止状态 我们的算法所要做到的事情是将一个中的状态进行分组，组内的状态不可相互区分，将整个组作为最小的一个状态。算法大致思想如下： 输入： ， 输出：，，和接收相同的语言且状态数最小 初始时刻，我们将中的状态分为两个组，分别为非接受组（包含所有非终止状态）和接受组（包含所有终止状态）。从我们的当前划分出的组中选择一个状态组，选定某个输入符号检查是否可以用于区分状态组中的某些状态，对于能够区分的我们就划分为多个组使得组内的状态在作用下都到达相同的状态。重复上述分割过程直到无法继续分割。我们把某一步的算法得到的分割方法定义为，初始划分为定义为。算法完成时的分割方法定义为。下面给出算法流程： 如先前所说划分两个组接受组和非接受组作为初始划分 如下图所示进行划分构造 如果则直接令；否则用替换并重复步骤2。 在分划出的的每个组选定一个状态作为该组的代表，这些代表构成了的状态，对于这些状态： 的开始状态是包含了开始状态的组 的终止状态是包含了终止状态的组 令是中某个组的代表，并令中在输入上离开的转换到达状态。令为所在组的代表，那么在中存在一个从到在输入上的转换。 有两个要点需要注意： 状态最小化的原理：要使得算法成立且最终得到的结果是最小化的，我们不做证明给出两个性质： 仍然位于的同一组状态不可能被任意串区分 不同子组之间的状态时可区分的 死状态的消除：最小化算法可能产生带有所有输入符号上都指向自己的非接受状态，这种状态可能使得识别无法提早退出，被称为死状态 实例分析考虑正则表达式a|abb|a*b+，通过Thompson算法获得的形式为： 123456789101112131415161718graph LR;st((0));st1((1));st2((2));st3((3));st4((4));st5((5));st6((6));st7((7));st8((8));en((end));st --ε--&gt; st1;st -- ε --&gt;st3;st -- ε --&gt;st7;st1 -- a --&gt; st2;st3 -- a --&gt;st4;st4 -- b --&gt; st5;st5 -- b --&gt;st6;st7 -- a --&gt;st7;st7 -- b --&gt;st8;st8 -- b --&gt;st8;st2 -- ε --&gt;en;st6 -- ε --&gt;en;st8 -- ε --&gt;en; 经过子集构造法可以获得如下的: 12345678910111213graph LR;st1((0137));st2{247};st3((7));st4{8};st5{68};st6{58};st1 -- a --&gt; st2;st1 -- b --&gt; st4;st2 -- a --&gt; st3;st2 -- b --&gt; st6;st3 -- a --&gt;st3;st3 -- b --&gt;st4;st4 -- b --&gt; st4;st5 -- b --&gt; st4;st6 -- b --&gt; st5; 对于上图的，其初始划分为：{0137,7} {247,8,58,68}，对于每个组内的状态，我们遍历字母表和，出现不同的状态就区分，经过多次迭代可以得到最终的区分依次是：","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"}]},{"title":"(一)字符串正则匹配的动态规划与编译原理思路","slug":"由实例开始构造正则引擎(1)字符串正则匹配的动态规划与编译原理思路","date":"2022-01-21T13:08:34.000Z","updated":"2022-03-27T11:27:20.368Z","comments":true,"path":"2022/01/21/由实例开始构造正则引擎(1)字符串正则匹配的动态规划与编译原理思路/","link":"","permalink":"https://kimanyang.xyz/2022/01/21/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(1)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF/","excerpt":"","text":"字符串正则匹配的动态规划与编译原理思路题目引入下面两道力扣题目分别代表了两种不同类型的状态机，第一种是正则表达式到到的转换，第二种是正则表达式到到的转换，选取这两道可以对状态机的设计有更深刻的认识（面试必不会考但是自己写正则引擎总得会一点）。 10.正则表达式匹配（hard)给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 .匹配任意单个字符 *匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 44.通配符匹配(hard)给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ? 和 * 的通配符匹配。 ? 可以匹配任何单个字符。 * 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和*。 动态规划解法10.正则表达式匹配（hard)字符串匹配问题通常都可以看成是二维动态规划问题，类似的题型包括子序列匹配之类的。用表示中前个字符能否和中前个字符匹配。在进行状态转移时，考虑的第个字符匹配情况： 如果的第个字符是一个小写字母，那么我们必须在中匹配一个相同的小写字母，即：$$dp[i][j]=\\left{\\right.\\notag$$如果的第个字符与的第个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符， 如果的第个字符是，那么可以对的第个字符进行0到任意次数匹配。进一步想，字母与星号的组合在匹配过程中只会出现两种情况： 匹配最末字符，使用该组合继续匹配 不进行匹配，丢弃该组合 由此可以写出模式串为时的如下的状态转移方程：$$dp[i][j]=\\left{\\right.\\notag$$ 最后只要遇到是则可以成功匹配 总结上述的三点可以获得如下的状态转移方程：$$dp[i][j]=\\left{\\begin{aligned}&amp;p[j]\\ne ‘*’=\\left{\\right.\\&amp;otherwise=\\left{\\right.\\end{aligned}\\right.\\notag$$其中判断二者是否匹配，只有是.或者时两个字符匹配。 代码实现如下： 1234567891011121314151617181920212223242526272829class Solution { public: bool isMatch(string s, string p) { int m = s.size(), n = p.size(); auto match = [&amp;](int i, int j) { if(i == 0) return false; if(p[j-1] == '.') return true; return s[i-1]=p[j-1]; }; vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1)); dp[0][0]=1; for(int i = 0;i &lt;= m;++i) { for(int j = 1;j &lt;= n;++j) { if(p[j-1] == '*') { dp[i][j] |= dp[i][j-2]; if(matches(i,j-1)) { dp[i][j] |= dp[i-1][j]; } } else { if(matches(i,j)) { dp[i][j] |= dp[i-1][j-1]; } } } } return dp[m][n] }} 44.通配符匹配(hard)模仿上述题目，我们分析题目要求的状态转移方程： 用表示中前个字符能否和中前个字符匹配。 当和匹配且不为通配符时，能否成功匹配取决于能否成功匹配。 当为通配符*时 要么和末尾匹配，取决于是否成功匹配 要么不匹配，取决于是否成功匹配 如果能匹配，那带*的也能继续匹配 边界条件写出状态转移方程：$$dp[i][j]=\\left{\\begin{aligned}&amp;p[j-1]\\ne’‘,s[i-1]\\Leftrightarrow p[j-1]\\implies dp[i][j]=dp[i-1][j-1] \\&amp;p[j-1]=’‘\\implies dp[i][j]=dp[i][j-1]||dp[i-1][j]||dp[i][j-1]\\end{aligned}\\right.\\notag$$ 1234567891011121314151617181920class Solution {public: bool isMatch(string s, string p) { int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1)); dp[0][0] = true; for(int i = 0;i &lt;= m;++i) { for(int j = 1;j &lt;= n;++j) { if(i &gt; 0 &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '?')) { dp[i][j] = dp[i-1][j-1]; } else if(p[j-1] == '*') { dp[i][j] = dp[i][j] || dp[i][j-1]; if(i &gt; 0) dp[i][j] = dp[i][j] || dp[i-1][j-1]; if(i &gt; 0) dp[i][j] = dp[i][j] || dp[i-1][j]; } } } return dp[m][n]; }}; 非确定有限状态自动机解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*用于构造NFA图的节点结构*/type Node struct { C byte //当前节点接受的字符 Parent *Node //正向生成时的母节点，用于生成自由长度0节点的可跨越边 Children map[byte][]*Node //子节点个数，一个字节可以对应多个索引（NFA） End bool //是否为终止节点 Size int //节点长度，如果携带的是*则长度为0，否则为1（只能匹配一个）}/* 核心功能实现，递归生成NFA 函数签名： @param: now 当前要递归生成的节点的根 @param: str 模式串，递归中无修改 @param: idx 当前匹配的坐标,是now要生成节点对应的字符*/func generatePattern(now *Node, str string, idx int) int { //到达当前末尾 if len(str) &lt;= idx { now.End = true return now.Size } vnow := now //用于下一次更新的节点 switch str[idx] { case '*': now.Size = 0 //无限匹配自由长度为0 now.addVertex(now.C, now) //自己可以接受自己 default: node := new(Node) //创建下一字符节点 node.C = str[idx] now.addVertex(str[idx], node) //当前字符节点后继添加 node.Parent = now //当前节点父节点设为node node.Size = 1 //节点自由长度为1 vnow = node //当前节点可以更新为新的节点 } //如果是*则不用创建新节点 ret := generatePattern(vnow, str, idx+1) //后续已无节点（或者只有x*匹配),则当前节点也可作为终止态 if ret == 0 { now.End = true } //给当前的后继节点配野爹 addParent := now for addParent.Parent != nil { //对于正常节点,vnow是我的后继，如果当前节点的长度为零，那我的后继也是我父母节点的后继 if addParent.Size == 0 { //debug(toString(vnow), \" -&gt; \", toString(addParent.Parent)) addParent.Parent.addVertex(vnow.C, vnow) //父母添加一条到我后继节点的边 addParent = addParent.Parent //递归匹配到 } else { break } } return now.Size + ret}/*为节点n添加一条经由c到达child的边，回溯时会进行新的创建*/func (n *Node) addVertex(c byte, child *Node) { m := n.Children //没有后继列表就创建一个 if m == nil { m = make(map[byte][]*Node) n.Children = m } list := m[c] //当前字符不存在就创建一个 if list == nil { list = make([]*Node, 0) } //遍历当前的可达状态，如果存在目标状态则退出 for _, v := range list { if v == child { m[c] = list return } } //状态不存在，更新列表 list = append(list, child) m[c] = list}//递归检查是否能够匹配func check(now *Node, str string, idx int) bool { if len(str) &lt;= idx { return now.End } list := now.Children['.'] for _, v := range now.Children[str[idx]] { list = append(list, v) } for _, v := range list { r := check(v, str, idx+1) if r { return true } } return false}//使用示例，判断s是否能被接受func isMatch(s string, p string) bool { begin := new(Node) //创建start节点 begin.C = '&gt;' begin.Size = generatePattern(begin, p, 0) //递归构造模式串有穷状态自动机 return check(begin, s, 0)} 所构造的图片： 状态机分别为c*..b*a*a.*a..*c和mis*is* 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950graph LR; id0xc4200809c0((&gt;)); id0xc4200809f0((c)); id0xc4200809f0 -- c --&gt; id0xc4200809f0; id0xc420080a80((.)); id0xc420080ab0((.)); id0xc420080b10((b)); id0xc420080b10 -- b --&gt; id0xc420080b10; id0xc420080ba0((a)); id0xc420080ba0 -- a --&gt; id0xc420080ba0; id0xc420080c00((a)); id0xc420080c30((.)); id0xc420080c30 -- . --&gt; id0xc420080c30; id0xc420080cc0((a)); id0xc420080cf0((.)); id0xc420080d50((.)); id0xc420080d50 -- . --&gt; id0xc420080d50; id0xc420080de0{c}; id0xc420080d50 -- c --&gt; id0xc420080de0; id0xc420080cf0 -- . --&gt; id0xc420080d50; id0xc420080cf0 -- c --&gt; id0xc420080de0; id0xc420080cc0 -- . --&gt; id0xc420080cf0; id0xc420080c30 -- a --&gt; id0xc420080cc0; id0xc420080c00 -- . --&gt; id0xc420080c30; id0xc420080c00 -- a --&gt; id0xc420080cc0; id0xc420080ba0 -- a --&gt; id0xc420080c00; id0xc420080b10 -- a --&gt; id0xc420080ba0; id0xc420080b10 -- a --&gt; id0xc420080c00; id0xc420080ab0 -- b --&gt; id0xc420080b10; id0xc420080ab0 -- a --&gt; id0xc420080c00; id0xc420080ab0 -- a --&gt; id0xc420080ba0; id0xc420080a80 -- . --&gt; id0xc420080ab0; id0xc4200809f0 -- . --&gt; id0xc420080a80; id0xc4200809c0 -- c --&gt; id0xc4200809f0; id0xc4200809c0 -- . --&gt; id0xc420080a80; id0xc420080780((&gt;)); id0xc4200807b0((m)); id0xc420080810((i)); id0xc420080870((s)); id0xc420080870 -- s --&gt; id0xc420080870; id0xc420080900{i}; id0xc420080930{s}; id0xc420080930 -- s --&gt; id0xc420080930; id0xc420080900 -- s --&gt; id0xc420080930; id0xc420080870 -- i --&gt; id0xc420080900; id0xc420080810 -- s --&gt; id0xc420080870; id0xc420080810 -- i --&gt; id0xc420080900; id0xc4200807b0 -- i --&gt; id0xc420080810; id0xc420080780 -- m --&gt; id0xc4200807b0; 上述Go代码的C++版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class NFAnode{ public: char ch; NFAnode* parent; unordered_map&lt;char,vector&lt;NFAnode*&gt;&gt; children; bool isEnd; int size; void addVertex(char ch, NFAnode* child) { auto&amp; m = this-&gt;children; auto&amp; list = m[ch]; for(auto&amp; v:list) { if(v == child) { m[ch] = list; return; } } list.push_back(child); m[ch] = list; }};class Solution {private:public: bool isMatch(string s, string p) { NFAnode* begin = new NFAnode(); begin-&gt;ch = '@'; begin-&gt;size = genneratePatern(begin,p,0); return checkHelper(begin,s,0); } int genneratePatern(NFAnode* now, string str,int idx) { if(str.length() &lt;= idx) { now-&gt;isEnd = true; return now-&gt;size; } NFAnode* vnow = now; if(str[idx] == '*') { now-&gt;size = 0; now-&gt;addVertex(now-&gt;ch,now); } else { NFAnode* node = new NFAnode(); node-&gt;ch = str[idx]; now-&gt;addVertex(str[idx],node); node-&gt;parent = now; node-&gt;size = 1; vnow = node; } int ret = genneratePatern(vnow, str, idx + 1); if(ret == 0) { now-&gt;isEnd = true; } NFAnode* addParent = now; while(addParent-&gt;parent != nullptr) { if(addParent-&gt;size == 0) { addParent-&gt;parent-&gt;addVertex(vnow-&gt;ch,vnow); addParent = addParent-&gt;parent; } else { break; } } return now-&gt;size + ret; } bool checkHelper(NFAnode* now, string str, int idx) { if(str.length() &lt;= idx) { return now-&gt;isEnd; } auto list = now-&gt;children['.']; for(auto&amp; v:now-&gt;children[str[idx]]) { list.push_back(v); } for(auto&amp; v:list) { bool r = checkHelper(v,str,idx+1); if(r) {return true;} } return false; }}; 读者们如果无法理解代码也没有关系，下一篇文章会详细讨论递归下降构造词法树到最终进行状态机匹配的过程。 从正则到或者到转换罗列知识可能比较难以理解，我们先直观地从简单的题目开始一步一步展示算法实现的过程。 状态机经典题目——65.有效数字有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 给定一个字符串，判断是否为有效数字字符串。 正则表达式解法：显然问题可以直接由正则表达式解决，首先将规则构造为正则表达式也有利于我们进一步的状态机分析。 代码如下： 12345678const regex Solution::pattern(\"[+-]?(?:\\\\\\\\d+\\\\\\\\.?\\\\\\\\d*|\\\\\\\\.\\\\\\\\d+)(?:[Ee][+-]?\\\\\\\\d+)?\");class Solution {public: static const regex pattern; bool isNumber(string str) { return regex_match(str, pattern); }}; 分析上述的表达式： 一个整数的正则表达：[+-]?\\\\\\\\d+ 一个小数的正则表达:[+-]?((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)) 组合起来再带上可选的e和E:(小数|整数)[eE]整数 展开来便是([+-]?\\\\\\\\d+)|([+-]?((\\\\\\\\d+\\\\\\\\.)|(\\\\\\\\d+\\\\\\\\.\\\\\\\\d+)|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?)\\\\\\\\d+ 需要注意C++的字符串中添加双斜杠\\\\\\\\是为了转义第二个斜杠，实际内存中还是一个\\，即\\\\\\\\d表示标准正则语法中的\\d。（两层套娃） 正则化简从化简的角度理解会更容易一些，也可以给出一些普适的结合律交换律来化简。这里先给出上述正则的简化表达，这也是一部分题解中给出的正则表达式： 1([+-]?(\\\\\\\\d+(\\\\\\\\.\\\\\\\\d*)?|(\\\\\\\\.\\\\\\\\d+)))([eE][+-]?\\\\\\\\d+)? 从正则到我们将上述抽象的正则表达式一步一步转换为状态机模型，这里的算法被称为Thompson算法。 首先我们确定正则表达式中的字符集，对于我们要进行解析的这个正则表达式来说，字符集为[+-.deE]。 其次我们分析正则表达式中的构造方法，并将其对应到中。五种构造方法分别为： 字符集接受，即一个规则集合，比如[+-]和小括号内的所有内容： 1234graph LR;st((start));en{end};st -- 字符集 --&gt; en; 规则的串联，即正则表达式中两个规则直接链接构造的新规则 12345678graph LR;st1((start));en1{end};st2((start));en2{end};st1 -- 字符集1 --&gt; en1;en1 -- 空边 --&gt; st2;st2 -- 字符集2 --&gt; en2; 规则的并联，即正则表达式中两个或以上规则以|链接 123456789101112131415161718graph LR;st((start));en{end};st1((start));en1{end};st2((start));en2{end};st3((start));en3{end};st -- 空边 --&gt; st1;st -- 空边 --&gt; st2;st -- 空边 --&gt; st3;st1 --字符集1 --&gt;en1;st2 --字符集2 --&gt;en2;st3 --字符集3 --&gt;en3;en1 --空边--&gt;en;en2 --空边--&gt;en;en3 --空边--&gt;en; 规则的重复（1次及以上），即正则表达式中的X+一个或以上匹配，为了后续分析方便采用复制状态的表示： 123456789graph LR;st((start));en{end};st1((start));en1{end};st --子状态1--&gt; en;en --空边--&gt; st1;st1 --子状态1--&gt; en1;en1 --空边--&gt;en; 规则的可选，即正则表达式中的X?,只需要将起始状态和终止状态相连接。 12345graph LR;st((start));en{end};st --子状态--&gt; en;st --空边 --&gt;en; 对于4的特殊情况X*匹配零次及以上，则直接令end同时拥有起始和终止两个状态即可。至此我们根据已有的知识构造题目正则表达式所对应的，空边用null表示则有： 1234567891011121314151617181920212223242526272829303132333435363738graph LR;st((start));st1((state1));st2((state2));st3((state3));st4((state4));st5((state5));st6((state6));st7((state7));st8((state8));st9((state9));st10((state10));st11((state11));st12((state12));en{end};st -- +- --&gt; st1;st --null --&gt;st1;st1 -- null --&gt;st2;st1 -- null --&gt;st6;st2 -- digit --&gt;st3;st3 -- digit --&gt;st3;st3 -- . --&gt; st4;st3 -- null --&gt;st5;st4 -- digit --&gt; st5;st4 -- null --&gt;st5;st5 -- digit --&gt;st5;st5 -- null --&gt;st9;st6 -- . --&gt; st7;st7 -- digit --&gt; st8;st8 -- digit --&gt;st8;st8 -- null --&gt;st9;st9 -- eE --&gt;st10;st9 -- null --&gt;en;st10 -- +- --&gt;st11;st10 -- null --&gt; st11;st11 -- digit --&gt;st12;st12 -- digit --&gt;st12;st12 -- null --&gt; en; 出于展示简便没有完全按照上述的形式得出上图展示的的模型，做了一些较为直观的冗余空边化简。 的非确定性消除非确定性的消除主要有两点：1.消除空边 2. 将转换为。 消除空边不作证明地给出以下的算法过程： 找到所有的有效状态 有效状态指存在非(空)边输入的状态。同时起始状态也是有效状态，另外如果一个状态可以通过空边到达结束状态，那么该状态也应该变成结束状态。在我们的例子中，有效状态有状态1、状态3、状态7、状态4、状态8、状态5、状态10、状态11和状态12。状态5、8和12应该被标记为结束状态。 添加必要的边 这一步为核心算法。我们针对每一个有效状态实行如下算法： 寻找该状态的**闭包，一个状态的闭包指的是：从该状态出发仅仅通过边能够到达的所有状态**。 将所有从这个闭包中输出的边的出发点全部复制到当前状态上。 我们以初始节点为例实施该算法，可以看到初始节点通过空边能够到达的状态包括状态1、2和6。实施算法后的图变为： 1234567891011121314151617181920212223242526272829303132333435363738394041graph LR;st((start));st1((state1));st2((state2));st3((state3));st4((state4));st5((state5));st6((state6));st7((state7));st8((state8));st9((state9));st10((state10));st11((state11));st12((state12));en{end};st -- +- --&gt; st1;st --null --&gt;st1;st -- digit --&gt;st3;st -- . --&gt; st6;st1 -- null --&gt;st2;st1 -- null --&gt;st6;st2 -- digit --&gt;st3;st3 -- digit --&gt;st3;st3 -- . --&gt; st4;st3 -- null --&gt;st5;st4 -- digit --&gt; st5;st4 -- null --&gt;st5;st5 -- digit --&gt;st5;st5 -- null --&gt;st9;st5 -- digit --&gt;st5;st6 -- . --&gt; st7;st7 -- digit --&gt; st8;st8 -- digit --&gt;st8;st8 -- null --&gt;st9;st9 -- eE --&gt;st10;st9 -- null --&gt;en;st10 -- +- --&gt;st11;st10 -- null --&gt; st11;st11 -- digit --&gt;st12;st12 -- digit --&gt;st12;st12 -- null --&gt; en; 对所有的有效状态实施该算法后，最后我们需要删除所有无效状态和空边。算法应用的结果如下： 1234567891011121314151617181920212223242526272829graph LR;st((start));st1((state1));st3{state3};st4((state4));st5{state5};st7((state7));st8{state8};st10((state10));st11((state11));st12{state12};st -- digit --&gt; st3;st -- +- --&gt; st1;st -- . --&gt; st7;st1 -- digit --&gt;st3;st1 -- . --&gt;st7;st3 -- digit --&gt; st3;st3 -- . --&gt;st4;st3 -- eE --&gt;st10;st4 -- digit --&gt;st5;st4 -- eE --&gt; st10;st5 -- digit --&gt;st5;st5 -- eE --&gt; st10;st7 -- digit --&gt;st8;st8 -- digit --&gt;st8;st8 -- eE --&gt; st10;st10 -- +- --&gt; st11;st10 -- digit --&gt;st12;st11 -- digit --&gt;st12; 注意到我们将状态3、5、8和12标记为结束状态，而最终的结束状态作为无效状态清除。 这个算法实际上就是我们在之前的正则表达式匹配中应用的算法。可以看到我们得到的已然是一个，不是所有时候都可以这么理想直接得到一个的，我们仍然需要算法将转换为。图中的状态仍然不是最简的，比如状态5和状态8就是重复的。述的正则表达式的简化也可以通过先将复杂正则表达式的写出后再进行重复状态合并来获得，重复状态指的是具有相同的入度字符集和出度字符集的状态。 从到在下一节我们会详细讨论编译原理中的子集构造法, 解决题目65：现在我们可以直接根据写出状态机的代码，遍历循环简单实现可以通过if语句跳转实现，这里介绍一种实际中使用的表驱动方法，代码直接采用官方的题解。 首先列举我们的状态和字符集边： 12345678910111213141516171819enum State { STATE_START, //初始状态 STATE_INT_SIGN, //状态1 STATE_INTEGER, //状态3 STATE_POINT, //状态4 STATE_POINT_WITHOUT_INT, //状态7 STATE_FRACTION, //状态5和状态8，重复可以直接合并 STATE_EXP, //状态10 STATE_EXP_SIGN, //状态11 STATE_EXP_NUMBER, //状态12 STATE_END //结束状态}; enum CharType { CHAR_NUMBER, //digit CHAR_EXP, //eE CHAR_POINT, //. CHAR_SIGN, //+- CHAR_ILLEGAL //其他非法字符 }; 接下来我们打表，基本上表驱动的表都是用哈希表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//状态转移表unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer{ { STATE_INITIAL, {//对应由初始状态出发的3条边到达的状态 {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT}, {CHAR_SIGN, STATE_INT_SIGN} } }, { STATE_INT_SIGN, {//对应由状态1出发的2条边到达的状态 {CHAR_NUMBER, STATE_INTEGER}, {CHAR_POINT, STATE_POINT_WITHOUT_INT} } }, { STATE_INTEGER, {//对应由状态3出发的3条边到达的状态 {CHAR_NUMBER, STATE_INTEGER}, {CHAR_EXP, STATE_EXP}, {CHAR_POINT, STATE_POINT} } }, { STATE_POINT, {//对应由状态4出发的2条边到达的状态 {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP} } }, { STATE_POINT_WITHOUT_INT, {//对应由状态7出发的1条边到达的状态 {CHAR_NUMBER, STATE_FRACTION} } }, { STATE_FRACTION,{//对应由状态5和8出发的2条边到达的状态 {CHAR_NUMBER, STATE_FRACTION}, {CHAR_EXP, STATE_EXP} } }, { STATE_EXP,{//对应由状态10出发的2条边到达的状态 {CHAR_NUMBER, STATE_EXP_NUMBER}, {CHAR_SIGN, STATE_EXP_SIGN} } }, { STATE_EXP_SIGN, {//对应由状态11出发的1条边到达的状态 {CHAR_NUMBER, STATE_EXP_NUMBER} } }, { STATE_EXP_NUMBER, {//对应由状态12出发的1条边到达的状态 {CHAR_NUMBER, STATE_EXP_NUMBER} } }};//终止状态集unordered_set&lt;State&gt; endStates = { STATE_INTEGER, STATE_POINT, STATE_FRACTION, STATE_EXP_NUMBER, STATE_END} 最后实现核心功能： 1234567891011121314bool isNumber(string s) { int len = s.length(); State st = STATE_INITIAL; for (int i = 0; i &lt; len; i++) { CharType typ = toCharType(s[i]); if (!transfer[st].count(typ)) { return false; } else { st = transfer[st][typ]; } } return endStates.count(st);} 小结综上我们通过三道题简单入门了一下正则表达式编译原理，涉及知识仅仅限于求解题目，限于篇幅和作者水平没有进一步讨论。下一篇文章将具体给出正则表达式到到到再到消除多余状态的每一步算法原理。","categories":[{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"}]},{"title":"Rabin-Karp字符串编码","slug":"Rabin-Krap字符串编码","date":"2022-01-19T03:22:14.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/01/19/Rabin-Krap字符串编码/","link":"","permalink":"https://kimanyang.xyz/2022/01/19/Rabin-Krap%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/","excerpt":"","text":"Rabin-Karp字符串编码基本介绍Rabin-Karp算法作为一种简单实用的哈希算法将字符串映射为一个整数。假设字符串字符不超过, 那么选取一个大于等于的整数作为，就可以将字符串看成是一个进制的整数，将其转换为十进制数字后就得到了字符串对应的编码。 假设给定的字符串,包含的字符种类为4，那么字符集。取 , 那么字符串可以看成是七进制的数字$(0123)7，转换为十进制数为66。给出如下的一般化的编码公式：$\\label{rk}encode(s) = \\sum{i=0}^{\\vert S\\vert-1}s[i]*base^{\\vert S\\vert-i-1}$$其中表示字符串长度，为对应字符位的编码，不加证明地给出关于的一个结论： 给定基底和字符集，两个字符串和相等，当且仅当它们的长度相等且编码值相等。 对于所有长度为的字符串通过比较它们的编码值可以判断它们两两之间是否相等。但对于较长的字符串很容易出现编码值超过一般语言的整数类型可表示的范围，这就需要对编码值取模，这使得中的单射性质被破坏，哈希算法可能出现哈希冲突。但是如果所取得模数足够大，那么哈希碰撞的可能性会极大降低。 如果选定单个模数，那么只有在随机产生个字符串的时候才有超过50%的几率会发生哈希碰撞。通过选择多个模数，在取多个模数结果相等时才判断相等那碰撞概率可以降到微乎其微的程度。 在正常算法题中我们只需要选定一个模数，一般选取一个质数比如，有必要多选的话再加一个。对于基底一般也选择一个质数，比如如果字符集为小写字符集，则，可以选择略大的质数31或者29。 算法实现下面针对小写字符集的Robin-Karp给出C++的算法实现： 123456789101112class Solution {public: int RobinKarpEncode(string s) { int n = s.size(); int endcode = 0; int base = 31, mod = 1000000007; for(int i = 0;i &lt; n;++i) { encode = ((long long)encode * base + (s[i] - 97)) % mod; } return encode; }}; 算法并不需要每次都去计算，这需要调用到快速幂算法，但仍然称不上快速。注意到每一次都可以重复利用到前一次的信息，假设前位的编码值为，那么第位的编码值可以表示为：可以理解为每一位都乘上基底再加上个位数构成新的编码，体现了动态规划的思想。整体的动态转移方程可以写作：$$\\label{dyn}\\left{\\right .$$同时需要注意的是未进行取模之前的乘积可能会超过int类型的取值，需要暂时地用到long long进行存储。 模板题型最长快乐前缀：「快乐前缀」是在原字符串中既是非空前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串 s，请你返回它的 最长快乐前缀。 如果不存在满足题意的前缀，则返回一个空字符串。 来源：力扣链接：https://leetcode-cn.com/problems/longest-happy-prefix 题解： 12345678910111213141516public: string longestPrefix(string s) { int n = s.length(); int mod = 100000007, base = 29, happy_pre = 0; int prefix = 0, suffix = 0, mul = 1; for(int i = 1;i &lt; n;++i) { prefix = ((long long)prefix * base + s[i-1] - 97) % mod; suffix = (suffix + (long long)(s[n-i] - 97) * mul) % mod; if(prefix == suffix) { happy_pre = i; } mul = (long long)mul * base % mod; } return s.substr(0, happy_pre); }}; 这里顺便复习一下取模的一些重要性质： ，取模的加法结合律 ，取模的乘法结合律 ，取模的乘方性质 对于代码中进行后缀计算的部分，我们使用了上述的规律 对于前缀，根据以及取模的加法结合律由下式递推计算出最终结果：对于后缀，给出如下的递推公式：$$\\left{\\begin{aligned} suffix[k] &amp;= s[k] % mod &amp;k=0\\ suffix[k] &amp;= (suffix[k-1]+mul[k] * (s[k] - 97))%mod \\ \\ &amp;k&gt;0\\ mul[k] &amp;= mul[k-1] * base % mod \\end{aligned}\\right .$$这里利用到了取模的乘法结合律（对 取模等于对内部各自取模相乘,由于字符编码较小取模之后仍然等于自身)，再同前缀方式一样利用取模的加法结合律获得后缀编码的计算方式。 恢复空格哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/re-space-lcci 示例： 12345输入：dictionary = [\"looked\",\"just\",\"like\",\"her\",\"brother\"]sentence = \"jesslookedjustliketimherbrother\"输出： 7解释： 断句后为\"jess looked just like tim her brother\"，共7个未识别字符。 这道题目我们首先得到当前的动态转移方程（完全背包问题，一个单词可以匹配无穷多次):$$\\left{能够匹配时全都不能匹配时\\right .$$完全背包的二重循环的伪代码如下： 12345678910vector&lt;int&gt; dp(n + 1, n);dp[0] = 0;for(int i = 1;i &lt;=n;++i) { dp[i] = dp[i-1] + 1; for(int j = i;j &gt;= 1;--j) { if(s[j-1:i-1] 能够匹配) { dp[i] = min(dp[i], dp[j-1]); } }} 我们的问题现在转换为如何能够快速知道s[j-1:i-1]是否在字典之中，如果采用暴力遍历字典必会超时，于是可以采用本文中所说的Rabin-Karp算法对字典预处理为哈希值的集合，在通过Rabin-Karp算法逐项匹配的特性快速计算哈希值，从而求解，完整代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {using LL = long long; //命名空间，和define作用一样private: static constexpr LL P = (1LL &lt;&lt; 31) - 1; //常数表达式，模数 static constexpr LL BASE = 41; //常数表达式，基底 //Rabin-Karp算法的实现，从后往前进行，直接用long long类型防止计算溢出 //这种实现方便我们在完全背包的循环中进行哈希值的计算而无需后缀计算的局部变量 LL getHash(const string &amp;s) { LL hashValue = 0; for (int i = s.size() - 1; i &gt;= 0; --i) { hashValue = hashValue * BASE + s[i] - 'a' + 1; hashValue = hashValue % P; } return hashValue; }public: int respace(vector&lt;string&gt;&amp; dictionary, string sentence) { unordered_set&lt;LL&gt; stringHash; //字典预处理为哈希值集合 for(auto&amp; word:dictionary) { stringHash.insert(getHash(word)); } int n = sentence.size(); vector&lt;int&gt; dp(n + 1, n); dp[0] = 0; for(int i = 1;i &lt;=n;++i) { dp[i] = dp[i-1] + 1; LL curhash = 0; for(int j = i;j &gt;= 1;--j) { //利用Rabin-Karp的逐项计算方式寻找匹配的子串，并进行动态规划的状态更新 curhash = (curhash * BASE + (sentence[j-1]- 'a' + 1)) % P; if(stringHash.count(curhash)) { dp[i] = min(dp[i], dp[j-1]); } } } return dp[n]; }}; 实际使用中的一种写法即上文第二道模板题使用的写法。 123456789101112using LL = long long;static constexpr LL P = (1LL &lt;&lt; 31) - 1;static constexpr LL BASE = 41;LL getHash(const string &amp;s) { LL hashValue = 0; for (int i = s.size() - 1; i &gt;= 0; --i) { hashValue = hashValue * BASE + s[i] - 'a' + 1; hashValue = hashValue % P; } return hashValue;} 多费点内存，少烧点脑子。 Rabin-Karp、Trie树以及KMP算法的优劣比对 KMP适合单个模式串与多个串进行匹配，不存在冲突的问题，但是多个模式串与单个目标串匹配时没有优势 Trie树可用于多个模式串与单个目标串匹配，可以给出更丰富的目标串信息（比如经典的路由解析算法可以采用Trie树进行）从而实现诸如前缀匹配、范围查找等方法，同时如果数据集是动态数据集，Trie树的插入操作也足够友好，同样不存在冲突问题具有稳定的复杂度。但缺点是占用内存较大（也存在压缩的算法）写起来比较复杂，工程实现上缺少轮子可以直接用，而且对于不同的编码诸如unicode编码还需要更多地考虑，实际工程中很少使用 本文介绍的Rabin-Karp算法不仅可以匹配多个串，相比于单纯的hash好处在于可以直接逐个单词匹配，和Trie树比起来内存占用少（因为无需为每个字典字符开辟指针节点，直接用long long或者int都能解决），时间复杂度相仿，但是存在着哈希冲突的问题。这种时候多采用几个模数就行了，在工程上是完全可以接受的，于是hash类的算法在工程中的应用更加广泛","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"},{"name":"Rabin-Karp","slug":"Rabin-Karp","permalink":"https://kimanyang.xyz/tags/Rabin-Karp/"},{"name":"哈希算法","slug":"哈希算法","permalink":"https://kimanyang.xyz/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"https://kimanyang.xyz/tags/KMP/"}]},{"title":"矩阵快速幂与状态机DP总结","slug":"矩阵快速幂与状态机DP总结","date":"2022-01-19T03:16:24.000Z","updated":"2022-03-27T11:27:20.069Z","comments":true,"path":"2022/01/19/矩阵快速幂与状态机DP总结/","link":"","permalink":"https://kimanyang.xyz/2022/01/19/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BADP%E6%80%BB%E7%BB%93/","excerpt":"","text":"状态机DP总结对于多状态的DP问题，往往可以根据给出的规则集写出相应的状态转移方程，如果是线性的DP问题其时间复杂度为，状态转移方程维数通常为2，压缩后为1。对于这类问题算法比赛中还可以通过矩阵快速幂算法使得时间复杂度降低到，在计算科学中甚至可以通过矩阵分解将时间复杂度进一步降低，这种抽象方法具有很强的扩展潜能。 本文由快速幂到矩阵快速幂逐步介绍，进一步通过例题逐步抽象出问题模型和方法。 矩阵快速幂快速幂自己实现一个double pow(double x,int n)返回x的n次方，实现代码如下： 12345678910111213141516171819double myPow(double x, int n) { long long N = n; if(N &gt;= 0) { return fastPow(x,N); } double tmp = fastPow(x,-N); return 1.0/tmp;}double fastPow(double x, long long n) { double ans = 1.0; while(n){ if( (n&amp;1) == 1){ ans *=x; } x *=x; n = n&gt;&gt;1; } return ans;} 简单举个具体例子，k的11次幂，可以分解为：$$\\begin{aligned}ans &amp;= kkkkkkkkkkk \\&amp;=k*(k^5)(k^5) \\&amp;=k(k*(k^2)^2)(k(k^2)^2) \\\\end{aligned}\\notag$$只需要经过次即4次乘方即可获得结果，不需要乘11次。具体来说就是每次为单数的时候都多乘一次，否则直接自己平方即可，可以起到加速运算的作用。具体不多做解释，直接扩展到矩阵乘法中。 矩阵拓展假设我们有如下的矩阵：要给定算法求，相应的算法如下： 1234567891011121314151617181920212223//基本原理同快速幂，单纯改变乘法，而且没有逆运算一说vector&lt;vector&lt;int&gt;&gt; fastMatrixPow(vector&lt;vector&lt;int&gt;&gt; mat, int n) { vector&lt;vector&lt;int&gt;&gt; ans = {{1,0,0},{0,1,0},{0,0,1}}; while(n != 0) { if((n&amp;1) == 1) ans = multiply_mat(ans,mat); mat = multiply_mat(mat,mat); n = n &gt;&gt; 1; } return ans;}//基础知识点，如何安排循环顺序能够使得cache命中率更高提高矩阵乘法速度vector&lt;vector&lt;int&gt;&gt; multiply_mat(vector&lt;vector&lt;int&gt;&gt; x,vector&lt;vector&lt;int&gt;&gt; y) { int n = x.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n,0)); for(int i = 0;i &lt; n;++i) { for(int j = 0;j &lt; n;++j){ for(int k = 0;i &lt; n;++k) { ret[i][j] += x[i][k] * y[k][j]; } } } return ret;} 上述矩阵乘法如此简陋速度肯定是不够快的，建议参考一下Eigen库里整的工业化模板元编程黑魔法。 模板题——Tribonacci Sequence给定递推公式且，将该递推公式改成离散的状态空间模型写作向量形式，变作能控标准型（草）:根据左乘结合律容易推导出：令,问题转换为求解 次方，复用我们在矩阵拓展一节的代码可以得到： 123456int tribonacci(int n) { vector&lt;vector&lt;int&gt;&gt; M = {{1,1,1},{1,0,0},{0,1,0}}; vector&lt;vector&lt;int&gt;&gt; ans = fastMatrixPow(M, n-2); //f(n) = ans[0][0] * f(2) + ans[0][1] * f(1) + ans[0][2] * f(0) return ans[0][0] + ans[0][1];} 如果结果最终过大还要采用long long类型和模数，用各种矩阵分解去整出复杂度的计算也不是不行，这还是交给数值计算科学库吧。 记忆化搜索、状态机DP和矩阵快速幂552.学生出勤记录可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符： A：Absent，缺勤 L：Late，迟到 P：Present，到场 如果学生能 同时满足: 缺勤次数严格小于2 连续迟到小于3次 答案可能很大，所以返回对 109 + 7 取余 的结果。。 记忆化搜索：单纯爆搜的枚举深搜函数可以写成： 1234567891011121314151617/* *@param: u 当前剩余的决策位数 *@param: a_cnt 剩余可用的Absetn次数 *@param: l_cnt 当前结尾的Late连续次数 *@param: cur_str 当前的方案字符串 *@param: set 结果集*/int dfs(int u, int a_cnt, int l_cnt, string cur_str, vector&lt;string&gt;&amp; set) { if(a_cnt &gt;= 2) return 0; if(l_cnt &gt;= 3) return 0; if(u == 0) {set.push_back(cur_str);return 1;} int ans = 0; ans += dfs(u-1,a_cnt + 1, 0,cur_str.push_back('A'),set);cur_str.pop_back(); ans += dfs(u-1,a_cnt,l_cnt + 1,cur_str.push_back('L'),set);cur_str.pop_back(); ans += dfs(u-1,a_cnt,0,cur_str.push_back('P'),set);cur_str.pop_back(); return ans} 这样很容易超时，事实上很多字符串已经被记录过了，可以使用当前方案字符串缓存哈希表或者更好的状态数组直接记录结果，由于我们只需要知道最终的结果数目，所以也不需要当前方案的缓存和结果集，修改后的记忆化搜索代码如下所示： 1234567891011121314151617181920212223static constexpr MOD = 10000000007;int solution(int n) { vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; cache(n + 1, vector&lt;int&gt;(2,vector&lt;int&gt;(3,-1))); return dfs(n, 0, 0, cache);}/* *@param: u 当前剩余的决策位数 *@param: a_cnt 剩余可用的Absetn次数 *@param: l_cnt 当前结尾的Late连续次数 *@param: cache 当前搜索的历史记忆结果*/int dfs(int u, int a_cnt, int l_cnt, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; cache) { if(a_cnt &gt;= 2) return 0; if(l_cnt &gt;= 3) return 0; if(u == 0) {return 1;} if(cache[u][a_cnt][l_cnt] != -1) return cache[u][a_cnt][l_cnt]; int ans = 0; ans += dfs(u-1,a_cnt + 1, 0) % MOD; ans += dfs(u-1,a_cnt,l_cnt + 1) % MOD; ans += dfs(u-1,a_cnt,0) % MOD; cache[u][a_cnt][l_cnt] = ans; return ans} 状态机线性DP通过对记忆化搜索的分析，可以发现下一位的决策依赖于当前位的决策，我们给定一个三维的DP数组，第一维表示决定的位数，第二维表示当前的a_cnt，第三维表示末尾连续的l_cnt。那么表示前天有个以及结尾有个的情况。边界状态。 如果第天的出勤记录是，则结尾的会清零，于是： 如果第天的出勤记录是，则结尾的清零，同时要求前一天的为0： 如果第天的出勤记录是，则要求前一天的小于2： 对应C++形式： 12345678910111213141516171819202122232425262728class Solution {public: static constexpr int M = 1'000'000'007; int checkRecord(int n) { vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;long long&gt;&gt;(2, vector&lt;long long&gt;(3))); dp[0][0][0] = 1; for(int i = 1;i &lt;= n; ++i) { //以P结尾的出勤记录数量，结尾只有0 dp[i][0][0]=(dp[i][0][0] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2])%M; dp[i][1][0]=(dp[i][1][0] + dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2])%M; //以A结尾的出勤记录数量,结尾只有0 dp[i][1][0]=(dp[i][1][0] + dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2])%M; //以L结尾的出勤数量，因要求连续于是与k-1有关 dp[i][0][1]=(dp[i][0][1] + dp[i-1][0][0])%M; dp[i][0][2]=(dp[i][0][2] + dp[i-1][0][1])%M; dp[i][1][1]=(dp[i][1][1] + dp[i-1][1][0])%M; dp[i][1][2]=(dp[i][1][2] + dp[i-1][1][1])%M; } int ans = 0; for(int j = 0;j &lt; 2;j++) { for(int k = 0;k &lt; 3;++k) { ans = (ans + dp[n][j][k])%M; } } return ans; }}; 这里就不给出空间压缩的版本了，由于dp[i]仅仅与dp[i-1]有关，空间复杂度是可以压缩到的。 矩阵快速幂对线性DP的优化从上述的状态转移方程我们能够抽象出对应的离散状态转移矩阵，首先我们定义如下的状态，以idx作为状态编号，使用： 最终的答案是，将状态整理成列向量，再由前述状态转移方程对照（暂时去除模数)： 1234567891011121314 dp[i][0][0]+=dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2];//dp[n][0] = dp[n-1][0] + dp[n-1][1] + dp[n-1][2] dp[i][1][0]+=dp[i-1][1][0] + dp[i-1][1][1] + dp[i-1][1][2];//dp[n][3] = dp[n-1][3] + dp[n-1][4] + dp[n-1][5] dp[i][1][0]+=dp[i-1][0][0] + dp[i-1][0][1] + dp[i-1][0][2];//dp[n][3] = dp[n-1][0] + dp[n-1][1] + dp[n-1][2] dp[i][0][1]+=dp[i-1][0][0];//dp[n][1] = dp[n-1][0] dp[i][0][2]+=dp[i-1][0][1];//dp[n][2] = dp[n-1][1] dp[i][1][1]+=dp[i-1][1][0];//dp[n][4] = dp[n-1][3] dp[i][1][2]+=dp[i-1][1][1];//dp[n][5] = dp[n-1][4] 写出如下矩阵状态方程:再有初值条件,定义矩阵 可以获得如下的计算式：。套用我们在矩阵快速幂中的模板 ， 12345678910111213141516171819202122232425262728293031static constexpr int mod = 1'000'000'007;//矩阵快速幂vector&lt;vector&lt;int&gt;&gt; fastMatrixPow(vector&lt;vector&lt;int&gt;&gt; mat, int n) { vector&lt;vector&lt;int&gt;&gt; ans = { {1,0,0,0,0,0}, {0,1,0,0,0,0}, {0,0,1,0,0,0}, {0,0,0,1,0,0}, {0,0,0,0,1,0}, {0,0,0,0,0,1} }; while(n != 0) { if((n&amp;1) == 1) ans = multiply_mat(ans,mat); mat = multiply_mat(mat,mat); n = n &gt;&gt; 1; } return ans;}//基础知识点，如何安排循环顺序能够使得cache命中率更高提高矩阵乘法速度vector&lt;vector&lt;int&gt;&gt; multiply_mat(vector&lt;vector&lt;int&gt;&gt; x,vector&lt;vector&lt;int&gt;&gt; y) { int n = x.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n,0)); for(int i = 0;i &lt; n;++i) { for(int j = 0;j &lt; n;++j){ for(int k = 0;i &lt; n;++k) { ret[i][j] += x[i][k] * y[k][j]; } } } return ret;} 1220.统计元音字母给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串： 字符串中的每个字符都应当是小写元音字母（’a’, ‘e’, ‘i’, ‘o’, ‘u’） 每个元音 ‘a’ 后面都只能跟着 ‘e’ 每个元音 ‘e’ 后面只能跟着 ‘a’ 或者是 ‘i’ 每个元音 ‘i’ 后面 不能 再跟着另一个 ‘i’ 每个元音 ‘o’ 后面只能跟着 ‘i’ 或者是 ‘u’ 每个元音 ‘u’ 后面只能跟着 ‘a’ 由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。 官方给出的n=2情况的示例，可以据此直接写出状态机： 12345/\"ua\"\"ea\"\"ia\"//\"ae\"\"ie\"/ /\"ei\"\"oi\"/ /\"io\"/ /\"iu\"\"ou\"/ 状态机线性DP有了前面一道题的铺垫，根据题目给出的示例，我们可以很容易看出这道题的状态转移方程：初始边界条件。那么代码就很清晰了： 1234567891011121314151617181920212223class Solution {private: static constexpr int MOD = 1'000'000'007; using ll = long long;public: int countVowelPermutation(int n) { vector&lt;ll&gt; dp0(5, 1); vector&lt;ll&gt; dp1(5, 0); for(int i = 2;i &lt;= n;++i) { dp1[0] = (dp0[1] + dp0[2] + dp0[4]) % MOD; dp1[1] = (dp0[0] + dp0[2]) % MOD; dp1[2] = (dp0[1] + dp0[3]) % MOD; dp1[3] = (dp0[2]) % MOD; dp1[4] = (dp0[2] + dp0[3]) % MOD; dp0 = dp1; } int ret = 0; for (int i = 0;i &lt; 5;++i) { ret = (ret + dp0[i]) % MOD; } return ret; }}; 矩阵快速幂对线性DP的优化根据的状态转移方程可以写出如下的状态转移矩阵： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using LL = long long;using Mat = vector&lt;vector&lt;LL&gt;&gt;;class Solution {public: Mat multiply(const Mat &amp; matrixA, const Mat &amp; matrixB, LL mod) { int m = matrixA.size(); int n = matrixB[0].size(); Mat res(m, vector&lt;LL&gt;(n, 0)); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { for (int k = 0; k &lt; matrixA[i].size(); ++k) { res[i][j] = (res[i][j] + matrixA[i][k] * matrixB[k][j]) % mod; } } } return res; } Mat fastPow(const Mat &amp; matrix, LL n, LL mod) { int m = matrix.size(); Mat res(m, vector&lt;LL&gt;(m, 0)); Mat curr = matrix; for (int i = 0; i &lt; m; ++i) { res[i][i] = 1; } for (int i = n; i != 0; i &gt;&gt;= 1) { if (i &amp; 1) { res = multiply(curr, res, mod); } curr = multiply(curr, curr, mod); } return res; } int countVowelPermutation(int n) { LL mod = 1e9 + 7; Mat factor = { {0, 1, 0, 0, 0}, {1, 0, 1, 0, 0}, {1, 1, 0, 1, 1}, {0, 0, 1, 0, 1}, {1, 0, 0, 0, 0} }; Mat res = fastPow(factor, n - 1, mod); long long ans = 0; for (int i = 0; i &lt; 5; ++i) { ans = (ans + accumulate(res[i].begin(), res[i].end(), 0LL)) % mod; } return ans; }};","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"动态规划","slug":"动态规划","permalink":"https://kimanyang.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态机DP","slug":"状态机DP","permalink":"https://kimanyang.xyz/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://kimanyang.xyz/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"}]},{"title":"Stability Theorems for Non-autonomous Systems","slug":"Stability Theorems for Non-autonomous Systems","date":"2022-01-01T03:29:01.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2022/01/01/Stability Theorems for Non-autonomous Systems/","link":"","permalink":"https://kimanyang.xyz/2022/01/01/Stability%20Theorems%20for%20Non-autonomous%20Systems/","excerpt":"","text":"Stability Theorems for Non-autonomous SystemsComparison FunctionsDefinition of class functionsA continuous function is said to belong to class if it is strictly increasing and . It is of class if and as Definition of class functionsA continuous function is said to belong to class if, for each fixed , the mapping belong to class with respect to and, for each fixed , the mapping is decreasing with respect to and as . examples: , class but not class , class , class , class , , class . Lemma(Properties)Let on and and denotes the inverse of : is defined on and belongs to is defined on and belongs to class belongs to class belongs to class belongs to class LemmaLet be a continuous positive definite function defined on a domain that contains the origin. Let for some . Then there exist defined on such that:If , and are defined on . Moreover, if is radially unbounded, then . example:Consider a quadratic positive definite function:We know that:and so we can define and . Non-autonomous Systems is piecewise continuous in and locally Lipschitz in for all and all . The origin is an equilibrium point at if Definition:The equilibrium point of the non-autonomous system is: Stable: If such that stands Uniformly Stable: stable and is independent of Asymptotically Stable: stable and such that as , Uniformly Asymptotically Stable: if is independent of and the convergence is uniformly in , that is: Globally Uniformly Asymptotically Stable: if can be chosen to satisfies and : It’s easier to define uniform stability and uniform asymptotic stability using comparison functions: is uniformly stable if there exists a class- function and a constant such thatfor all and for every initial condition such that uniformly asymptotically stable: if there exists a class such that:for all and for every initial condition such that globally uniformly asymptotically table: if uniformly exponentially stable: if for some :for all and for every initial condition such that . example:Consider a nonlinear system:Its solution is:Missing or unrecognized delimiter for \\left \\begin{aligned} x(t) &amp;= x(t_0)exp\\left{\\int_{t_0}^t(6\\tau\\sin\\tau-2\\tau)d\\tau \\right}\\\\ &amp;=x(t_0)exp\\left{6\\sin t-6t\\cos t-t^2-6\\sin t_0+6t_0\\cos t_0-t_0^2 \\right} \\end{aligned} \\notag Note We have:Missing or unrecognized delimiter for \\left \\Vert x(t)\\Vert\\le\\Vert x(t_0)\\Vert\\cdot \\exp\\left{ 15-6\\sin t_0+6t_0\\cos t_0-t_0^2 \\right}\\triangleq c(t_0)\\cdot\\Vert x(t_0)\\Vert \\notag For any , choose . Then we obtain:which implies that the origin is stable. We study the sensitivity of the system solutions due to the changes in . Let . We examine at .Missing or unrecognized delimiter for \\left \\begin{aligned} x(t_0+\\pi)=x(t_0)\\exp\\left{(4k+1)(6-\\pi)\\pi \\right} \\end{aligned} \\notag Thus we have:Missing or unrecognized delimiter for \\left \\frac{x(t_0+\\pi)}{x(t_0)}=\\exp\\left{(4k+1)(6-\\pi)\\pi \\right}\\to\\infty,as\\ k\\to\\infty \\notag Therefore, given any , there is no independent of that could satisfy the uniform stability definition. example:consider the following system, defined for :Its solution is . Because the origin is uniformly stable with . The origin is also asymptotically stable, but not uniformly asymptotically stable, because the convergence rate depends on . Time-Dependent Positive Definite FunctionsDefinition: is said to be positive semidefinite if is said to be positive definite if , for some positive definite function . is said to be decrescent if , for some positive definite function . is radially unbounded if as examples:Let . Find . Find and . Find and TheoremLyapunov Stability for Non-autonomous SystemLet the origin be an equilibrium point of and be a domain containing . Suppose is piecewise continuous in and locally Lipschitz in for all and . Let be a continuously differentiable function such that:for all and , where and are continuous positive definite functions on . Then, the origin is uniformly stable. Further theoremSuppose the assumptions of the previous theorem are satisfied with:for all and , where is a continuous positive definite function on . Then, the origin is uniformly asymptotically stable. Moreover, if and are chosen such that and , then every trajectory starting in satisfiesfor some class function . Finally, if and is radially unbounded, then the origin is globally uniformly asymptotically stable. example:Consider the following nonlinear system:We consider the following Lyapunov function candidate(“你们别问我这是怎么来的，反正就这样”——梅老师原话)：Since:Hence, is positive definite, decrescent, and radially unbounded. The derivative of along the system trajectories is given by:Hence the origin is globally uniformly asymptotically stable (exponentially stable) Linear Time-Varying Systems the solution can be represented as: TheoremThe equilibrium point of the linear system is globally uniformly asymptotically stable (GUAS) if and only if:for some positive constants and . Remark that: for linear systems GUASExponential stability for linear time-varying system, GUAS cannot be characterized by the location of the eigenvalues of . example: For each , . Yet the origin is unstable. is given by: Corollary:The system is uniformly asymptotically stable if there exists such that:Proof: Let , then: Corollary:Assume that there exists which is continuously differentiable and symmetric, and there exist such that:Further assume for some , continuous and symmetric such that:Then the system is globally uniformly asymptotically stable. Proof: Let is positive definite and decrescent. And : Corollary:Assume that at any time , the eigenvalues of all have negative real parts. In addition, if is bounded, and , then is globally uniformly asymptotically stable. Barbalat’s Lemma(very important)How about the asymptotically stability when is only negative semi-definite? For autonomous system, LaSalle’s invariance theorem can be used. But it is not valid for non-autonomous systems. Barbalat’s Lemma is a purely mathematical result concerning the asymptotically properties of functions and their derivatives. an example: can convergence of ? Definition: Uniform Continuity(一致连续)A function is said to be uniformly continuous if: Lemma(Barbalat):If the differentiable function: has a finite limit as . is uniformly continuous. ( is bounded) Then . Note: A sufficient condition for a differentiable function to be uniformly continuous is that its derivative be bounded. Lemma(“Lyapunov-Like”):If a scalar function satisfies the following conditions: is lower bounded is negative semidefinite () is uniformly continuous ( is bounded) then . example:In adaptive control, we will often encounter the following non-autonomous system:where is a bounded continuous function, and are two states of the closed-loop system, representing the tracking error and parameter error. Consider the quadratic scalar function:Its derivative:is negative semi-definite. Check . Note that , which implies that . Therefore and are bounded. With being bounded, we can conclude that is also bounded. From Barbalat’s Lemma, we can conclude that , that is, . Theorem(La Salle-Yoshizawa):Let be an equilibrium point of and suppose that is locally Lipschitz in and uniformly in . Let be a continuously differentiable function such that:, where and are class $\\mathcal{K}\\inftyW(x)$ is a continuous function. Then all solutions of satisfy:$$\\lim\\limits{t\\to\\infty}W(x(t))=0\\notag$$In addition, if is positive definite, is globally uniformly asymptotically stable. Proof: (Revisit if has a finite limit, uniformly continuous, then so if has a finite limit, is uniformly continuous, then ) Note, , so is monotonous non-decreasing. From we know and thus:so monotonous non-decreasing function has upper bound, thus it has a finite limit. Since and is bounded, is bounded. Assume that . Note that a continuous function is uniformly continuous on a closed set. is uniformly continuous in . For all , we have:Then is uniformly continuous in , and thus is also uniformly continuous in . From Barbalat’s Lemma, . Theorem( norm)For function of time, the norm is given by:for , while:We say that when . Corollary 0.1If and $\\dot{x}\\in\\mathbb{L}\\infty\\lim\\limits{t\\to\\infty}x(t)=0$. Proof: Define:Since , we can get has a finite limit as . Furthermore:From the fact that $x,\\dot{x}\\in\\mathbb{L}\\infty\\ddot{f}(t)\\in\\mathbb{L}\\infty\\dot{f}\\lim\\limits{t\\to\\infty}\\dot{f}(t)=0\\lim\\limits{t\\to\\infty}x(t)=0$. Boundedness and Ultimate BoundednessThe concept of stability in the sense of Lyapunov are formulated with respect to an equilibrium point. Often, systems are designed to operate in the presence of disturbances and other uncertainties. Until now we have used Lyapunov theory to study the behavior of the system about the equilibrium point. What happens when the system does not have any equilibrium point ? We will see that Lyapunov analysis can be used to show boundedness of the solution of the state equation. example: Its solution is given by:The solution satisfies:which shows that the solution is uniformly bounded. Further, for any number , it can be easily seen that:The bound , which again is independent of , gives a better estimate of the solution after a transient period has passed. In this case, the solution is said to be uniformly ultimately bounded and is called the ultimate bound. This can be also done via Lyapunov analysis without the explicit solution of th state equation. /Todo Here/ DefinitionThe solution of are Uniformly Bounded (UB): if there exists a , independent of such that: Globally Uniformly Bounded (GUB): if can be arbitrarily large Uniformly Ultimately Bounded (UUB): with ultimate bound , if there exists (independent of ) such that: Globally Uniformly Ultimately Bounded (GUUB): if can be arbitrarily large. Remark: For a Lyapunov function candidate , if we have such that: Input-to-state StabilityFor a linear time-variant system with Hurwitz. The solution is given by:Using the bound:we conclude that:And it is GUAS. This doesn’t hold for a general nonlinear system example when , the equilibrium point is GAS. Yet, when and , the solution is given by:which is unbounded. It even has a finite escape time. Definition of Input to State Stability(ISS)The system is is said to be input-to-state stable if there exist and such that for any initial state and any bounded input , the solution exists for all and satisties: Remarks: For any bounded input , the state will be bounded As increases, the state will be ultimately bounded by a class function of If as then as Since for of the unforced system is GUAS. TheoremLet be a function such that:. and . Then the system is ISS with . LemmaSuppose that is and globally Lipschitz in , uniformly in . If the unforced system has a globally exponentially stable equilibrium point at , then the system is ISS. Cascade System","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"非自治系统","slug":"非自治系统","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"Stability of Autonomous System","slug":"Stability of autonomous system","date":"2021-12-25T08:23:01.000Z","updated":"2022-03-27T11:27:20.377Z","comments":true,"path":"2021/12/25/Stability of autonomous system/","link":"","permalink":"https://kimanyang.xyz/2021/12/25/Stability%20of%20autonomous%20system/","excerpt":"","text":"Stability of Autonomous SystemConsider the autonomous system:along is locally Lipschitz map from . Assume that , i.e. , is an equilibrium point. Definition:The equilibrium point of (1) is stable: if, for each there is , such that unstable: if it is not stable asymptotically stable: if it is stable and can be chosen such that: . exponentially stable: if there exists two real constants such that . exponentially asymptotically. Note that does not necessarily imply stability: one can construct an example where trajectories converge to the origin, but only after a large detour that violates the stability definition. Stability of autonomous system.assets\\homoclinic_orbit.PNG) Exanple: Consider exponentially converge to with a rate . In fact . Example: and . Its solution is which is asymptotically stable but not exponentially stable. marginally stable: if is stable but not asymptotically stable. globally asymptotically/exponentially stable: if it holds for all initial states. Positive Definite Functions–”Energy-Like” FunctionsDefinition: A function is said to be: positive definite if and positive semidefinite if and negative definite(resp. negative semi definite) if is positive definite(resp. definite semi positive). Example: The simplest and perhaps the most important class of positive definite functions is a quadratic form:V is PD , Q is PD V is PSD , Q is PSD Example: Let is PD when and PSD when . Example: Consider the pendulum system with state equations: Define . State space: . one can compute the following energy function(kinetic and potential energy):The derivative of with respect to is:Canveats: Positive definite function can be seen as an abstraction of the total “energy” stored in the system All the Lyapunov stability theorems focus on the study of the time derivative of a positive definite function along the trajectories of the system. Stability Theorems for Autonomous SystemsTheorem: Lyapunov’s stability theoremLet be an equilibrium point for and be a domain containing . Let be a continuously differentiable function such that: which means is positive definite which means is negative semidefinite Then is stable. Moreover, if which meas is negative definite then is asymptotically stable. Example:Consider the pendulum example without friction:Assume the following energy function:Clearly and .Thus the origin is stable. Since we can also conclude that the origin is not asymptotically stable. Next we consider the pendulum example with friction:Consider:Then which is negative semidefinite. We can only conclude that the origin is stable. But actually the system is asymptotically stable. The chosen Lyapunov function candidate fails to show this fact. Replace the term by the more general quadratic form for some positive definite matrix . We define:where and . The time derivative along the system is:$$\\begin{aligned}\\dot{V}(x)&amp;=\\frac{1}{2}\\begin{bmatrix}\\dot{x}1 \\ \\dot{x}2\\end{bmatrix}+a\\sin x_1\\cdot x_2 \\&amp;=\\begin{bmatrix}p{11} &amp; p{12} \\ p_{12} &amp; p_{22} \\end{bmatrix}+a\\sin x_1\\cdot x_2 \\&amp;=p_{11}\\cdot x_1x_2-p_{12}x_1(a\\sin x_1+bx_2)+p_{12}x_2^2-p_{22}x_2[a\\sin x_1+bx_2]+a\\sin x_1\\cdot x_2 \\&amp;=(p_{11}-p_{12}b)x_1x_2-p_{12}a\\cdot x_1\\sin x_1-(p_{22}b-p_{12})x_2^2+(1-p_{22})a\\sin x_1\\cdot x_2\\end{aligned}\\notag\\dot{V}=-\\frac{ab}{2}x_1\\cdot\\sin x_1-\\frac{b}{2}x_2^2\\le0$$when , the system is negative definite. Thus we can conclude that the origin is asymptotically stable. This example emphasizes an important feature: the Lyapunov theorem;s conditions are only sufficient Example:Let’s study the following nonlinear system:with the equilibrium point at the origin. Consider the following positive definite function:Its derivative along the system is: is negative definite over the ball . Therefore, the origin is locally asymptotically stable. Theorem-Globally Asymptotically Stable(GAS)Let be an equilibrium point for . Let be a continuously differentiable function such that: and ( PD) (radially unbounded,径向无界) (ND) Then is globally asymptotically stable(GAS) Example: is radically unbounded and is not radically unbounded Global Asymptotic stability:Consider . Stability of autonomous system.assets/gloablStability.PNG) Caveat: The reason for radial boundedness condition is to assure that the contour curves correspond to closed curves. If the curves are not closed, it is possible for state trajectories to drift away from the equilibrium point, even though the state keeps going through contours corresponding to smaller and smaller ’s. The Invariance Principle(不变集原理)Definition:A set is an invariant set with respect to ifA set is a positively invariant set with respect to if: approaches a set as if (有限时间内距离小于任意正值)where . (边界严格定义) Example: Equilibrium Points are invariant set. the whole space with . limit cycle (极限环) A trajectory of a system is called close if it is not a constant but returns to its starting point, i.e., there exists some such that . An isolated closed orbit is called a limit cycle. There are three types of limit cycles: Stable Limit Cycle: all trajectories in vicinity(邻域) of the limit cycle converge to it as ; Unstable Limit Cycle: all trajectories in vicinity of the limit cycle diverge to it as ; Semi-stable Limit Cycle: some trajectories in vicinity of the limit cycle converge to it, while others diverge from it as . Theorem-La Salle’s TheoremLet be a compact positively invariant set. be a continuously differentiable function such that in . . be the largest invariant set in . ( and can stand identically in itself,) Then every solution starting in approaches as . Example: Consider the pendulum example without friction:Differentiable function with We chose , thus and . Consider the pendulum example with friction:Differentiable function . We chose , . Thus Remark: Besides often yielding conclusions on asymptotic stability when is only negative semi-definite, the invariant set theorem also allow us to extend the concept of Lyapunov function so as to describe convergence to dynamic behaviors more general than equilibrium, e.g., convergence to a limit cycle. When is the origin ? Corollary 4.1Let be an equilibrium point of . Let be a positive definite function containing the origin such that in . Let and suppose that no solution can stay identically in , other than the trivial solution . Then, origin is asymptotically stable. Corollary 4.2Let be an equilibrium point of . Let be a , radically unbounded, positive definite function such that for all . Let and suppose that no solution can stay identically in , other than the trivial solution . Then is GAS. ExamplesExample: Still consider pendulum example with friction, chose . From , use corollary 4.1 can prove the asymptotically stable of the origin. Example: Consider the following first-order system:together with the adaptive control lawTaking , we can obtain:The line is an equilibrium set. We want to show that the trajectories approach this equilibrium set as , which means the adaptive controller regulates . Consider the following Lyapunov function candidate:where is a constant. The derivative of along the trajectories is given by:Step 1 : Define the set , which is an invariant set. Step 2: The set Step 3: The largest invariant set . From La Salle’s Theorem, we can conclude that . Moreover, since is radially unbounded, the conclusion is global. Example: Consider the following nonlinear system:The origin is an equilibrium point. Also, the set of points defined by the circle continue an invariant set. Solution 1: Assume that . We have:Solution 2: We now investigate the stability of the limit cycle using La Salle’s Theorem. To this end, consider the following function (not PD function):which represents a measure of the “distance” to the limit cycle. Then we have:Step 1: Chose Step 2: Find Clearlay . Step 3: Find , the largest invariant set in . . Thus choosing such that . includes the limit cycle but not the origin. The application of La Salle’s theorem with shows that every motion starting in converges to the limit cycle, and therefore the limit cycle is stable. Assume . satisfies will converges to the limit cycle, thus the origin is unstable. Linear Systems and LinearizationConsider the time-invariant linear system: Caveats: Some reasons for investigating stability of LTI systems via Lyapunov method: The Lyapunov analysis permits studying linear and nonlinear systems under the same framework, where LTI is a special case. We will introduce a very useful class of Lyapunov functions that appears frequently in the literature. We will study the stability of nonlinear systems via linearization of the state equation and try to get some insights into the limitations associated with this process. Consider a quadratic Lyapunov function candidate:where is positive definite. The derivative along LTI system:where is a symmetric matrix defined by called (Lyapunov equation). Lypunov TheoremA matrix is Hurwitz, that is, for all eigenvalues of , if and only if, for any given there exists a that satisfies the Lyapunov equation:Moreover, if is Hurwitz, then is the unique solution (9). When it comes to nonlinear system , we using linearization. We have:where is Jacobian matrix:$$A=\\frac{\\partial f(x)}{\\partial x}\\bigg|{x=0}=\\bigg|{x=0}$$and as . Consider the following Lyapunov function candidate:The derivative of along the trajectories is given by:Since is Hurwitz, . Regarding the other term, note that:Therefore such that . Hence :When Note that:It follows that:Choosing such that , is negative definite. Therefore is locally asymptotically stable. Theorem-Lyapunov’s indirect methodLet be an equilibrium point for the nonlinear system where is and is a neighborhood of the origin. Let Then, The origin is asymptotically stable if for all eigenvalues of The origin is unstable if for one ore more eigenvalues of We have no conclusion for some in nonlinear system. Example:It has two equilibrium points: and .","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"自治系统","slug":"自治系统","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"Nonlinear and Adaptive Control of Robotic Manipulators","slug":"Nonlinear and Adaptive Control of Robotic Manipulators","date":"2021-12-23T05:35:41.000Z","updated":"2022-03-27T11:27:20.379Z","comments":true,"path":"2021/12/23/Nonlinear and Adaptive Control of Robotic Manipulators/","link":"","permalink":"https://kimanyang.xyz/2021/12/23/Nonlinear%20and%20Adaptive%20Control%20of%20Robotic%20Manipulators/","excerpt":"","text":"Nonlinear and Adaptive Control of Robotic ManipulatorsThe dynamic equations of a robot manipulator in closed form are always written in the form of Euler-Lagrange equation. A dynamic system with degree of freedom can be described by the EL equation aswhere is the vector of generalized coordinates, is the symmetric positive definite inertia matrix, is the vector of Coriolis and centrifugal forces, is the vector of gravitational force, and is the vector of control force. And it has the following properties: Properties: is positive definite and ; . is skew symmetric where is the regressor and is an unknown but constant vector. 1. Position ControlControl Objective: , . Define the errors: , . The error dynamics:Define , , such that we obtain the following autonomous system:Design the following control input:where and are positive definite matrices. Then the closed-loop system is:Consider the following Lyapunov function candidate:Its derivative isSince is skew symmetric . And we haveTill now, we can consider the following Lyapunov function candidate:Its derivative is:which is negative semidefinite. Note the closed-loop system is autonomous, we can use LaSalle’s Theorem. Define . Let be a solution that belongs identically to . $x_2\\equiv0\\implies\\dot{x}2\\equiv0\\implies x_1\\equiv0E\\lim \\limits{t\\rightarrow\\infty}\\tilde{q}(t)=0,\\lim \\limits_{t\\rightarrow\\infty}\\dot{\\tilde{q}}(t)=0$. With Damping: in which is positive semidefinite, the control law can still work. Definition of Potential: if then the Lyapunov function is and and we can design some control law.(Final exam question) 2. Tracking ControlControl Objective: , , , and are bounded. Define the tracking errors: and . The error dynamics:Design the following control input(the inner of and are non-autonomous)Then the closed-loop system is:Then the closed-loop system is:Consider the following Lyapunov function candidateIts derivative along (13) is :Since our system is non-autonomous, LaSalle’s Theorem can not be used. From (15), , which implies that . Note that:Since and is bounded, we can get from (13) that $\\ddot{\\tilde {q}}(t)\\in\\mathcal{L}\\infty\\ddot{V}\\in\\mathcal{L}\\infty\\lim \\limits{t\\rightarrow 0}\\dot{V}(t)=0\\lim \\limits{t\\rightarrow\\infty}\\dot{\\tilde{q}}(t)=0$. Unfortunately, from the study sketched above, it is not possible to derive any immediate conclusion about the asymptotic behavior of the position error . 3. Sliding Mode Control (for tracking control)Define a sliding surface:and an auxiliary variable:Then we have:So we define the following control input:$$\\tau=g(q)+M(q)\\ddot{q}_r+C(q,\\dot{q})\\dot{q}r-KsM(q)\\dot{s}+C(q,\\dot{q})s=-KsV=\\frac{1}{2}s^TMs$$which is negative definite. Therefore the origin is exponentially stable, i.e., $\\lim \\limits{t\\rightarrow\\infty}s(t)=0s=\\dot{\\tilde{q}}(t)+\\lambda\\tilde{q}(t)$ we know that the system is input-to-state stable(ISS). final exam question Design controller . Then we have . 4. Adaptive Control （&amp;Robust)When there exist parametric uncertainties, sliding mode control law can not be implemented directly. Note that:Since is unknown, we propose the following control input:Thus using (26) for (19):Consider the following Lyapunov function candidate:Its derivative along (27) is:Design we have wich negative semidefinite. Robust Adaptive Control: 5. Backstepping Control for Robotic Manipulators(不考)Consider the following system for a robotic manipulator:where and represent respectively, the vector of link positions and motor angles, is the positive diagonal matrix representing the joint stiffness, and is the positive diagonal matrix representing the actuator inertia. Define and . The above dynamics can be described as:","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"自适应控制","slug":"自适应控制","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/"},{"name":"控制系统设计","slug":"控制系统设计","permalink":"https://kimanyang.xyz/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"机械臂","slug":"机械臂","permalink":"https://kimanyang.xyz/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"}]},{"title":"Adaptive Control","slug":"Adaptive Control","date":"2021-12-17T14:12:23.000Z","updated":"2022-03-27T11:27:20.069Z","comments":true,"path":"2021/12/17/Adaptive Control/","link":"","permalink":"https://kimanyang.xyz/2021/12/17/Adaptive%20Control/","excerpt":"","text":"Adaptive ControlBasic Steps Characterize the desired behavior of the closed-loop systems Determine a suitable control law containing adjustable parameters find a mechanism(an adaptation law) for adjusting those parameters Analyze the convergence properties and implement the control law Some approachesGain SchedulingSelf-Tuning Controller(STC) Combines a controller with an on-line plant parameter estimator Performs simultaneous (实时) parameters identification and control Uses Certainty Equivalence Principle: controller parameters are computed from the estimates of the plant parameters as if they were the true ones Model Reference Adaptive Control(MRAC) Plan: containing unknown parameters and having a known structure Reference model: specifying the desired output of the control system Feedback control law: containing adjustable parameters Adaptation mechanism: updating the adjustable parameters Indirect and Direct Adaptive ControlIndirected Adaptive Control:The process model and possible the disturbance characteristics are first determined. The controller parameters are designed on the basis of this information. Directed Adaptive Control:The controller parameters are changed directly without the characteristics of the process and its disturbances first being determined *Some Examples of Adaptive ControlConsider the following first-order scalar system:where is an unknown parameter, is the state and is the control input. Control Object: Design , such that all signals in the closed-loop system are bounded and tracks the state of the following reference model given by:$$\\dot{x}{ref}=-a{ref}x_{ref}+b_{ref}u_c$$where (Input-to-State Stable) and are unknown parameters, and is the reference input command which is bounded and piecewise continuous. We proposed the control law:$$u^*=k_1^x+k_2^u_c\\dot{x}=(a+k_1^*)x+k_2^u_c$$If $a+k_1^=-a_{ref}k_2^*=b_{ref}e=x-x_{ref}ak_1^*$ Direct Adaptive Control: what is like ? Indirect Adaptive Control: we got , what is like? Direct MRAC Design for Scalar SystemConsidering system: where and are unknown parameters but the sign of is known. Construct the same reference model given by(2), we have:$$\\begin{aligned}\\dot{x} &amp;= ax+b(k_1^x+k_2^u_c) \\&amp;=(a+bk_1^*)x+k_2^u_c\\end{aligned}k_1^=\\frac{-a-a_{ref}}{b},k_2^*=\\frac{b_{ref}}{b}u=\\hat{k_1}(t)x+\\hat{k_2}(t)u_c(t)$$there $\\hat{k}1\\hat{k}2k_1^*k_2^*$\\dot{x}=(a+b\\hat{k}1(t))x+\\hat{k}2(t)u_c(t)\\begin{aligned}\\dot{x} &amp;= (a+b\\hat{k}1(t))x+\\hat{k}2(t)u_c(t)-a{ref}x + b{ref}u_c+a{ref}x-b{ref} \\&amp;=-a{ref}x + b{ref}u_c+(a_{ref}+a+b\\hat{k}1)x + (b\\hat{k}2-b{ref})u_c \\&amp;=-a{ref}x+b_{ref}u_c+b(\\hat{k}1-k_1^*)x+b(\\hat{k}2-k_2^*)u_c \\&amp;=-a{ref}x+b{ref}u_c+b\\tilde{k}_1(t)x+b\\tilde{k}_2(t)u_c\\end{aligned}$$where and . Define the tracking error:Then from (14) and (2), the error dynamics is:$$\\dot{e}=\\dot{x}-\\dot{x}{ref}=-a{ref}e+b\\tilde{k}_1(t)x+b\\tilde{k}_2(t)u_cV=\\frac{1}{2}e^2+\\frac{\\vert b\\vert}{2\\gamma_1}\\tilde{k}_1^2+\\frac{\\vert b\\vert}{2\\gamma_2}\\tilde{k}_2^2\\begin{aligned}\\dot{V} &amp;= e\\dot{e}+\\tilde{k}_1\\dot{\\tilde{k}}_1|b|/\\gamma_1+\\tilde{k}_2\\dot{\\tilde{k}}2|b|/\\gamma_2 \\&amp;=-a{ref}e^2+\\frac{|b|}{\\gamma_1}\\tilde{k}_1(\\dot{\\hat{k}}_1+\\gamma_1\\cdot sgn(b)xe)+\\frac{|b|}{\\gamma_2}\\tilde{k}_2(\\dot{\\hat{k}}_2+\\gamma_2\\cdot sgn(b)u_ce)\\end{aligned}\\dot{\\hat{k}_1}=-\\gamma_1\\cdot sgn(b)xe\\ \\dot{\\hat{k}2}=-\\gamma_2\\cdot sgn(b)u_ce\\dot{V}=-a{ref}e^2\\le0 \\notag$$Thus . From(31), $e,\\tilde{k}_1,\\tilde{k}2x\\dot{e}\\ddot{V}\\lim \\limits{t\\rightarrow \\infty}e(t)=0$. summary Find a controller structure(based on known parameters) Derive the error dynamics Design a suitable Lyapunov function Derive parameter updating laws such that Direct MRAC Design for Scalar SystemConsider the following first-order scalar system:where with begin a bounded and continuous known function, and are unknown parameters but the sign of is known. The reference model is still given by$$\\dot{x}{ref}=-a{ref}x_{ref}+b_{ref}u_cu(t)=\\hat{k}1(t)x+\\hat{k}2(t)u_c(t)-\\phi(x)\\hat{\\theta}(t)\\begin{aligned}\\dot{x} &amp;= -a{ref}x+b{ref}u_c+b\\tilde{k}1(t)x+b\\tilde{k}2(t)u_c-b(\\hat{\\theta}-\\theta)\\phi(x) \\&amp;= -a{ref}x+b{ref}u_c+b\\tilde{k}_1(t)x+b\\tilde{k}_2(t)u_c-b\\tilde{\\theta}\\phi(x) \\\\end{aligned}$$where , and . Then the error dynamics isConsider the following Lyapunov function candidate:$$V=\\frac{1}{2}e^2+\\frac{|b|}{2\\gamma_1}\\tilde{k}_1^2+\\frac{|b|}{2\\gamma_2}\\tilde{k}2^2+\\frac{|b|}{2\\gamma_3}\\tilde{\\theta}^2\\dot{V}=-a{ref}e^2+\\frac{|b|}{\\gamma_1}\\tilde{k}_1(\\dot{\\hat{k}}_1+\\gamma_1\\cdot sgn(b)xe)+\\frac{|b|}{\\gamma_2}\\tilde{k}_2(\\dot{\\hat{k}}_2+\\gamma_2\\cdot sgn(b)u_ce)\\+\\frac{|b|}{\\gamma_3}\\tilde{\\theta}(\\dot{\\hat{\\theta}}-\\gamma_3\\cdot sgn(b)\\phi(x)e)$$Tips(important）: Consider a system different from(43) like are unknown. We should transfer the system into the following form:Then the previous MRAC method design with nonlinear term can be applied to this problem. Indirect MRAC Design for Scalar SystemIn directed adaptive control, $\\hat{k}1(t)\\hat{k}2(t)\\hat{k}1(t)\\hat{k}2(t)\\hat{a}(t)\\hat{b}(t)a,b$\\hat{k}1(t)=\\frac{-\\hat{a}-a{ref}}{\\hat{b}} \\\\hat{k}2(t)=\\frac{b{ref}}{\\hat{b}}u=\\hat{k_1}(t)x+\\hat{k_2}(t)u_c(t)=\\frac{1}{\\hat{b}}[-(\\hat{a}+a{ref})x+b{ref}u_c]\\begin{aligned} \\dot{x} &amp;= (a-\\hat{a}+\\hat{a})x+(b-\\hat{b}+\\hat{b})u \\ &amp;=-(\\hat{a}-a)x-(\\hat{b}-b)u+\\hat{a}x+\\hat{b}u \\ &amp;= -(\\hat{a}-a)x-(\\hat{b}-b)u+\\hat{a}x+\\hat{b}u \\ &amp;= -a{ref}x+b{ref}u_c-\\tilde{a}x-\\tilde{b}u\\end{aligned}$$where ,. Then the error dynamics can be written as:Consider the following Lyapunov function candidate:The time derivative of along is given by:In order to yield , we choose:Then , which implies that , are all bounded. In order to claim the boundedness of , we need to modify the adaptation law(61) and prevent from going through zero. Such a modification can be achieved using the following a prior knowedge:Assumption: The and a lower bound for are known. Let us consider the following modification of in (61)$$\\dot{\\hat{b}}=\\left{\\right.$$The main motivation here is to stop adaptation of if the parameter reaches its lower absolute limit value with a nonzero time derivative. We need to argue that the modification(62) does indeed prevent from going through zero and at the same time, it preserves . For this to be true, it is sufficient to show that:We check when and . Notice that . Overall, we can get that under the modification(62), inequality (63) holds, thus the following inequality holds:And thus are bounded. Since are bounded, are all bounded. From LaSalle Yoshizawa Theorem . Remark: Another Proof Integrating both sides of (64) yields:Furthermore, from the above analysis we have . From Barbalat’s Lemma we have the same conclusion. Direct MRAC Design for MIMO SystemsIn this section, we will extend applicability of the MRAC design from scalar dynamics to multi-input multi-output nonlinear systems in the form:where is the system state, is the control input, and is the known control matrix, while and are unknown constant matrices. In addition, it is assumed that is diagonal, its elements are strictly positive and the pair is controllable. The uncertainty in is introduced to model control failures or modeling errors, in the sense that there may exist uncertain control gains or the designer may have incorrectly estimated the system control effectiveness. Control Objective: Design such that all signals in the closed-loop system are bounded and tracks the state of the following reference model given by:$$\\dot{x}{ref}=-A{ref}x_{ref}+B_{ref}u_c$$where is Hurwitz, and is the external bounded command vector. If the matrices and were known, we can apply the control law:$$u = K_1^x+K_2^u_c\\dot{x}=(A+B\\Lambda K_1^*)x+B\\Lambda K_2^u_c$$In general, there is no guarantee that the ideal gain $K_1^K_2^*ABA_{ref}B_{ref}K_1^*K_2^*$u=\\hat{K}1(t)x+\\hat{K}2(t)u_c\\begin{aligned}\\dot{x} &amp;= A{ref}x+B{ref}u_c-A_{ref}x-B_{ref} + Ax B\\Lambda \\hat{K}1(t)x+B\\Lambda \\hat{K}2(t)u_c \\&amp;=A{ref}x+B{ref}u_c +(A+B\\Lambda\\hat{K}1(t)-A{ref})x +(B\\Lambda \\hat{K}2(t)-B{ref})u_c \\&amp;=A_{ref}x+B_{ref}u_c+B\\Lambda \\tilde{K}_1(t)x + B\\Lambda \\tilde{K}_2(t)u_c \\\\end{aligned}$$where and $\\tilde{K}2:=\\hat{K}2-K_2^*e := x-x{ref}e$\\dot{e}=A{ref}e+B\\Lambda \\tilde{K}_1(t)x+B\\Lambda\\tilde{K}_2(t)u_cV=\\frac{1}{2}e^2+\\frac{1}{2}\\tr\\left{\\tilde{K}_1^T\\tilde{K}_1\\right}+\\frac{1}{2}\\tr\\left {\\tilde{K}_2^T\\tilde{K}_2\\right}$$*Use sum of every column vector’s inner product makes sense here, still this Lyapunov candidate can not lead to asymptotically stable. Since is Hurwitz, we can get from Lyapunov’s Theorem that for any positive definite there exists a unique positive definite such that:We then consider the following Lyapunov function candidate:Missing or unrecognized delimiter for \\left V=e^TPe +\\tr\\left{\\tilde{K}^T_1\\Lambda\\tilde{K}_1 \\right} +\\tr\\left{\\tilde{K}^T_2\\Lambda\\tilde{K}_2 \\right} Its derivative along (73) can be written as:$$\\begin{aligned}\\dot{V} =&amp; \\dot{e}^TPe+e^TP\\dot{e}+2\\tr\\left{\\tilde{K}^T_1\\Lambda\\dot{\\hat{K}}1 \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda\\dot{\\hat{K}}2 \\right} \\=&amp;(A{ref}e)^TPe+e^TP(A{ref}e)+2e^TPB\\Lambda\\tilde{K}_1x+\\cdots \\&amp;+2e^TPB\\Lambda\\tilde{K}_2u_c+2\\tr\\left{\\tilde{K}^T_1\\Lambda\\dot{\\hat{K}}_1 \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda\\dot{\\hat{K}}_2 \\right} \\=&amp;-e^TQe+2\\tr\\left{\\tilde{K}^T_1\\Lambda B^TPex^T \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda B^TPeu_c^T\\right} +\\cdots\\&amp;+2\\tr\\left{\\tilde{K}^T_1\\Lambda\\dot{\\hat{K}}_1 \\right}+2\\tr\\left{\\tilde{K}^T_2\\Lambda\\dot{\\hat{K}}_2 \\right} \\\\end{aligned}\\dot{\\hat{K}}_1=-B^TPex^T,\\ \\dot{\\hat{K}}_2=-B^TPeu_c^T$$Then we have . Thus , which implies that $e,\\tilde{K}1,\\tilde{K}2A{ref}u_cx{ref}x\\dot{e}\\ddot{V}=-2e^TQ\\dot{e}\\lim \\limits_{t\\rightarrow \\infty}\\dot{V}(t)=0\\lim \\limits_{t\\rightarrow\\infty}e(t)=0$. Final Exam Question: Q1: with all negative elements? Missing or unrecognized delimiter for \\left\\tr\\left{\\tilde{K}^T_2(-\\Lambda)\\dot{\\hat{K}}_2 \\right} ​ with some negative elements? Missing or unrecognized delimiter for \\left\\tr\\left{\\tilde{K}^T_2|\\Lambda|\\dot{\\hat{K}}_2 \\right} Q2: Consider the following question with nonlinear term:where is unknown and . The controller can be: Nussbaum gainsConsider the following system:where and are unknown constants and but unlike previous discussion the direction of is unknown. Use control law , the closed-loop system is :Define ideal gain $u=k^xa+bk^:=k_0\\le0\\dot{\\hat{k}}(t)=-\\gamma\\cdot sgn(b)x^2\\hat{k}(t)$. Nussbaum gainsis one kind of Nussbaum gain. It satisfies the following condition: changes its sign an infinite number of times as . Other Nussbaum gains: , ,… By using nussbaum gain in the form of (86), the closed-loop system(82) is:We derive the following expression:Integrating both sides of (88) from to :Thus we have:where ( and ) Note that is monotone nondecreasing. must either approach a finite limit or grow without bound. If grows without bound, the sign of will be dominated by the term , which can assume a large negative value independent of the sign of . As a result , the right side of (90) is negative. Clearly, there is a contradiction with . Therefore, must be bounded. Then from (90) and from . From (87) we known $\\dot{x}\\in\\mathcal{L}\\infty\\lim \\limits{t\\rightarrow\\infty}=0$. Robust Adaptive ControlParameter DriftOur starting point is the following scalar system: where is the state, is the control input, is a continuous known function, is the unknown constant, and is a bounded time-dependent disturbance with . Control Objective: Design , such that all signals in the closed-loop system are bounded, and the state is derived to zero. (or to a small neighbor of zero) When , we proposed the following control inputThe the closed-loop system is :Consider a Lyapunov function candidate:Its derivative along (93) is :Then the adaptation law can be designed as:But when , the closed-loop system is:The derivative of in (94) along (97) is:Clearly, outside the set Missing or unrecognized delimiter for \\leftE_0=\\left{(x,\\tilde{\\theta}):\\Vert x\\Vert \\le\\frac{d_{max}}{k}:=e_0 \\right}. Inside , might be positive, and as a consequence, the parameter error can grow freely and even become unbounded. This phenomenon is known as parameter drift. It is caused by the disturbance. This is argument shows that the proposed adaptive law is not robust. Q: Does the state remain bounded? No existing answer. An Example of Parameter Drift Assume That . Consider a certain example for (91) as following:$$\\left{\\right. $$ The Dead-Zone ModificationIn order to enforce robustness, we consider an adaptive law with the dead-zone modification:$$\\dot{\\hat{\\theta}}=\\left{\\right.n_1 \\triangleq \\left{t:\\Vert x(t)\\Vert\\lt e_0+\\delta \\right} \\n_2 \\triangleq \\left{t:\\Vert x(t)\\Vert \\ge e_0+\\delta \\right}$$ If , and the trajectory reaches the boundary of , and is outside at , we have:When , . We can conclude that at is monotonously decreasing. Finally, we can get is bounded, and . Advantage of Dead-Zone Modification: Simplicity and effectiveness Drawbacks: The assumption that an upper bound for the disturbances need is known a priori In the absence of disturbance, asymptotic stability of the tracking error cannot be recovered. In other words, robustness is achieved at the expense of destroying some of the ideal properties of the adaptive law. The -ModificationThe -modification scheme, developed by Ioanon and Kokotovic does not require any priori information on the disturbance upper bounds. The adaptive law with the -modification is (with the ideal of feedback control) :where and are positive constants. In essence, this modification adds some damping to the ideal adaptive law. The motivation here is to prevent parameter drift. Under (105), the derivative of (94) along (93) is :Note that:and:Substituting (108) and (107) into (106) yields:We have . By adjusting , the convergence rate of can be modified.","categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"}],"tags":[{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"自适应控制","slug":"自适应控制","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/"}]},{"title":"Go语言GMP模型","slug":"Go语言GMP模型 54845","date":"2021-07-28T01:58:24.000Z","updated":"2022-03-10T15:39:10.657Z","comments":true,"path":"2021/07/28/Go语言GMP模型 54845/","link":"","permalink":"https://kimanyang.xyz/2021/07/28/Go%E8%AF%AD%E8%A8%80GMP%E6%A8%A1%E5%9E%8B%2054845/","excerpt":"","text":"Go语言GMP模型为什么学习Go语言： Go语言的吉祥物是土拨鼠，开发者自称Gopher, 完美契合当代越南青年的鼠人形象 GMP模型中的Worker（Goroutine）和越南青年一样只能任人摆布调度剥削，资源掌握在深不见底的内核之中 简单，快速上手，没有复杂的面向对象 快速的并发编程，自带GC无需关注内存细节同时速度够快 前置知识——进程、线程与协程之间的关系：进程的定义： 一个正在执行中的程序 一个正在计算机中执行的程序实例 能分配给处理器并且由处理器执行的实体 包括如下单元：一组指令序列的执行、一个当前状态和相关的系统资源集 进程信息被存放在进程控制块之中详细内容可见《操作系统–精髓与设计原理（第七版）》P80 图3.1 进程最重要的两个特点：1.进程拥有独立的资源所有权，进程间的资源是互斥的 2.进程被操作系统内核调度和执行 由此带来的问题是进程间对于资源的持有是不透明的，需要通过陷入内核的进程间的通信才能够交换彼此间的信息。进程内存占用开销几十MB到几百MB到几GB不等线程的定义多个线程可以存在于一个进程之中，对于单个线程存在如下资源： 线程的执行状态（运行、就绪、挂起or阻塞等等） 线程不在运行时的上下文（寄存器状态、程序计数器啥的），可以看作进程内的独立程序计数器 进程内的线程共享资源，线程对于资源的修改对于其他线程是透明的，其通信无需陷入内核 随着多线程多进程而来的问题：线程、进程的切换成本高昂，多线程之间的资源竞争带来的同步问题 协程的定义：进一步细化粒度，在程序内部对多个可执行的过程进行调度并提供一整套调度方式，在大部分的时间内无需陷入内核，不需要依赖操作系统的调度操作。也就是直接在线程内部交替执行模拟多线程，由于每一个协程只有几kb，因此可以大量地创建。（其实也存在着用户态线程的说法，纯粹的用户态线程应该也可以称为协程） 线程与线程比值以及相应地效果： 1：N 事实上地单核运行，无法发挥多核地优势，容易出现阻塞瓶颈 1：1 本质上相当于多线程多进程模型，切换协程也要切换线程，每次都得陷入内核 M:N 可以利用好多核心的优势同时协程的切换代价也会相应地降低，但是依赖调度算法的设计与优化 Go语言协程模型（GMP）何为GMP： G—Goroutine go协程，一段可执行的二进制代码和其拥有的堆栈资源 P—Processor 处理器，提供了运行上下文、调度队列, 对于G来说相当于一个CPU M—Machine 事实上是OS内核线程（区别于用户态线程）的抽象，代表实际的运算资源 （图片取自 刘丹冰Aceld Golang协程调度及其思想） 除此以外一个GMP模型还维护着各个P的本地队列以及一个全局队列 该模型的G和P部分可以理解为在用户态的层面自己实现了一个多核CPU 其中P的数量可以自己决定，通过命令配置环境变量 1go env -w GOMAXPROCS=n //n为你想要的P个数 对于M的数量其大小最大为10000（一般也达不到），如果一个M被P阻塞了，一个新的M会被创建，如果一个M空闲，那么就会被回收或者sleep 调度器策略线程复用机制： work stealing机制：线程M和绑定的P无可运行的G时尝试从其他绑定的M和P处偷取G来运行而不是直接销毁线程 hand off机制：当一个线程因为G的调用产生阻塞时，线程释放绑定的P，将P转移给其他空闲的线程进行执行 并行(Parallelism)与并发(Concurrency)机制： 关于并发与并行机制，Go语言创始人之一的Rob Pike说过这样一段话：Concurrency Is Not Parallelism. Concurrency is dealing lots of things at once. Parallelism is doing lots of things at once. Not the same, but related. One is about structure and one is about execution. Concurrency is not parallelism, although it enables parallelism. 并行在多个核心进行，一个操作系统中各个同时运行的进程可以看作是并行的，不同进程中正在同时执行的线程也可以看作并行的。 而并发是在一个核心之中分时复用CPU资源，使用者看起来是同时执行的样子而已，并非实际执行，dealing和doing两个词完美地指出了二者的区别。 对于go语言来说，一个P本地队列中的G肯定是并发的，如果两个P对应的两个M在同一个进程中那么G也只能算是并发的，但是OS可以调度M使之运行在多个CPU核心之上，所以Goroutine虽然主要是并发的，但语言本身也提供了并行的支持。 抢占调度机制： 一个goroutine最多占用CPU10ms的时间片，防止Goroutine在非阻塞情况下大量占用运算资源导致其他的Goroutine饥饿 全局队列机制： 在M无法在work stealing机制下获得G时，M会到全局队列获取G 经典八股文：一个go func()的执行经历了什么 go func()创建了一个goroutine (下文简称G) 这时G有两个选择，优先进入调度器P的本地队列，若本地队列满了进入全局队列 G运行在一个M中，M与P是1：1的关系，M会从P的本地队列中弹出一个G来执行，如果本地队列为空那么M会去其他MP那里偷取G来执行 M调度G的过程是一个循环的状态机模型 M执行G时发生了系统调用（意味着此时要陷入内核）或者go语言自带的阻塞机制(通道、waitgroup等)发挥作用时，M会进入阻塞状态，于是乎runtime会将P从该M上摘除，创建一个新的进程来为这个P服务 M系统调用或者阻塞结束的时候，位于其上G尝试获取一个空闲的P来执行并进入其本地队列，如果没有一个空闲的P可用，那么M会进入休眠，G被扔到全局队列 关于M位于自旋线程状态时的情况：自旋线程即本地队列为空且拥有的Goroutinue被执行完的MP组合，它们去全局队列拿G，没有的话就会去偷取其他的MP组合的G来执行，成功的话会退出自旋的状态，具体偷取和执行的方式细节十分丰富，详细说明如何执行这个策略可以参考https://www.notion.so/Go-GMP-dd55f3cf178c43c5bb31fc2ff791df8e#b7907ba58d3c4ebba937c5f5c4eccf36，但作为面试来说以上内容应该已经很足够了。 调度器的生命周期： M0为程序执行的主线程，其实例位于全局变量runtime.m0之中，不需要在堆内存上分配,M0负责执行初始化和启动第一个G，之后M0和其他的M一样被调度。 G0时每一次启动的M都会第一个创建的goroutine，G0仅仅用于负责调度的G，G0不指向任何可执行函数，每个M都有自己的G0，在进行协程调度或者系统调用的时候G0的栈空间被使用 关于GO语言堆栈空间以及内存的分配相关内容将会在同一个系列的另一篇文章里介绍 进一步阅读： https://zhuanlan.zhihu.com/p/360034857 这篇文章详解了Go语言的三种结构，interface&#x2F;goroutine&#x2F;channel在底层地实现方式，相关内容主要 123456789101112func largestNumber(nums []int) string &#123; sort.Slice(nums,func(i,j int)bool&#123; tempa := strconv.Itoa(nums[i])+strconv.Itoa(nums[j]) tmpeb := strconv.Itoa(nums[j])+strconv.Itoa(nums[i]) return tempa &gt; tmpeb &#125;) trans:=[]string&#123;&#125; for _,v:=range nums &#123; trans = append(trans,strconv.Itoa(v)) &#125; return strings.Join(trans,&#x27;&#x27;)&#125;","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"GMP模型","slug":"GMP模型","permalink":"https://kimanyang.xyz/tags/GMP%E6%A8%A1%E5%9E%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://kimanyang.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Go语言内存模型","slug":"Go语言内存模型 a2cd6","date":"2021-07-28T01:58:24.000Z","updated":"2022-03-10T15:39:05.061Z","comments":true,"path":"2021/07/28/Go语言内存模型 a2cd6/","link":"","permalink":"https://kimanyang.xyz/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%20a2cd6/","excerpt":"","text":"Go语言内存模型物理地址、地址空间与虚拟内存总之先推荐一下虚拟内存讲解得非常好的一个视频。 https://www.bilibili.com/video/BV18v411a7Vk?from=search&seid=8049687409040152217&spm_id_from&#x3D;333.337.0.0 物理内存顾名思义指内存芯片的内部存储结构，CPU寻址时根据物理地址获取改地址对应的数据字。 地址空间是一个非负整数集合，包含$[0,2^{n}-1]$。对于物理内存来说n是地址总线的个数，对于我们虚拟地址空间来说n是任意决定的，而且计算机中每一个进程独自拥有一整片完整的虚拟地址空间。CPU在进行索引时使用虚拟地址，经过MMU（内存管理单元）以及页表机制等硬件提供的映射服务将虚拟地址转换为对应的物理地址，这便是虚拟内存的工作流程简介。细节可以参考开头给出的视频以及CSAPP。 对于这篇文章来说，最重要的是理解如下几点： 理解虚拟内存即使已经获取并分配也并不一定占用实际的物理内存 虚拟内存提供了多进程之间的隔离，Go语言内存分配器分配的是独占的虚拟内存 Go内存分配器的设计(Tcmalloc)Go内存分配器基于谷歌研发的tcmalloc内存分配器（ThreadCache Malloc)。 以下图片引用https://zhuanlan.zhihu.com/p/29216091的图示进行代码讲解与分析。 分配的基本结构——Span与Object在第一节我们讲述了操作系统内存的分页结构（Page），Go内存分配在这基础上引入了Span和Object两个概念，其中Span是由多个页组成的较大块不定长内存；而Object是使用中为我们的程序实例对象分配内存的实际单元，由不同大小的Span切割对齐而来。 对于Span的管理，Go语言采用了类似于内存池分配的方法，为不同大小的对象预先切割好内存并利用隐式链表的方法进行管理。 1234567891011121314151617181920212223242526272829type mspan struct &#123; next *mspan // 显式链表下一节点 prev *mspan // 显式链表前一节点 startAddr uintptr // 首字节指针 npages uintptr // Span中的内存页数量 manualFreeList gclinkptr // 待分配的Object列表 freeindex uintptr //位于0和nelems中，表示以分配的内存块索引 nelems uintptr // Span中的Object数量 allocCache uint64 //gc相关 allocBits *gcBits //gc相关 gcmarkBits *gcBits //gc相关 sweepgen uint32 divMul uint16 // 元素大小切分 baseMask uint16 // if non-0, elemsize is a power of 2, &amp; this will get object allocation base allocCount uint16 // 已分配Object数量 spanclass spanClass // uint8的结构，决定了内部Object的大小 state mSpanStateBox // mspan状态，gc多线程相关以及内存管理使用 needzero uint8 // 进行内存分配前需要归0的标志位 divShift uint8 // for divide by elemsize - divMagic.shift divShift2 uint8 // for divide by elemsize - divMagic.shift2 elemsize uintptr // 由内存页数目或者spanClass决定的Object大小 limit uintptr // span的尾指针&#125; （虽然图示讲的是Page，但是我们可以暂且将其看作是一个Span，其结构可以和单个Span对应） Span的大小在8B到32KB之间不等，并非严格的按照2的幂次进行分配以减少内部碎片。超过32KB的对象会以另外的方式进行分配。除此以外，分配器对于多个微小的对象会尝试组合到一个Object内部进行内存分配以提高分配效率。 上述管理方式还存在着外部碎片的问题：不同大小的Span在连续的内存页中混杂共存，相同大小的内存通过指针进行联系。如果程序中有大量的小内存对象申请，分配器会将大的Span拆分为小的Span提高内存利用率，但是当小内存对象释放内存的时候程序如果需要大的内存空间就只能再向上级的分配器申请，原先的小内存对象释放后的span成为了外部碎片。为了避免这个问题直观的想法是将释放内存后的span前后的空闲span合并，由于page地址空间连续，span地址空间不连续，我们需要一个page（即地址）到span的映射来获取span前后的其他span状态。 再TCmalloc中，采用RadixTree结构来完成这一映射，这是一种特殊的前缀树，详细的介绍可以参考https://en.wikipedia.org/wiki/Radix_tree这里不再进行赘述。在源码之中这一映射被存放在mheap中进行管理。 内存的管理组件由于Span以及Heap为我们提供了从虚拟地址空间到Span内存池之间的一层抽象映射，底层的内存管理组件只需要关心Span的可用性以及待分配对象大小即可。 goruntime提供了三种内存分配组件：mcache、mcentral以及mheap。 mcache被每一个线程独占（也就是Go语言GMP模型中的P），在tcmalloc中被称为ThreadCache，可以进行无锁分配，拥有预分配好的一批span，分配时若对象在mcache中有合适的span就直接分配在其上，没有合适的span时会向所需span规格的mcentral进行申请 对于不同大小的对象有不同个mcentral（并非图中所示的一个），每个mcentral维护具有相同大小的span的一个spanlist，mcache申请时需要加锁访问。 如果mcentral没有合适的span可供mcache使用，那么mcentr会向mheap申请span。正如上一节所述mheap维护了内存页和span之间的映射，它首先会尝试合并空闲的span并将其交给mcentral，如果失败了，则陷入系统调用向操作系统申请新的内存。 mcache结构体内容12345678910111213141516171819type mcache struct &#123; next_sample uintptr // heap相关 local_scan uintptr // heap相关 //对于非指针的微小对象特殊处理相关，在一个object里面挤一挤 tiny uintptr tinyoffset uintptr local_tinyallocs uintptr //对于小对象可以根据numSpanClasses直接分配在span上 alloc [numSpanClasses]*mspan stackcache [_NumStackOrders]stackfreelist // 当前分配器的状态 local_largefree uintptr // 可用于大对象（&gt;32kB)的字节指针 local_nlargefree uintptr // 可用于大对象的块数目 (&gt;32kB) local_nsmallfree [_NumSizeClasses]uintptr // 可用于对应大小小对象的块数目指针桶(&lt;=32KB)&#125; mcentral结构体内容1234567891011121314type mcentral struct &#123; lock mutex //mcache申请时的互斥锁 spanclass spanClass //当前mcentral属于的span大小 nonempty mSpanList // 具有空闲的object的span称为非空span empty mSpanList // 被mcache取走或者没有空闲object的span //GC相关的span集合 partial [2]spanSet // list of spans with a free object full [2]spanSet // list of spans with no free objects //累加的整数，用于记录被分配出去的对象数目，假设所有被mcache拿走的span被完全分配 nmalloc uint64&#125; mheap结构体内容heap结构体相对复杂，包含了一些初始化时的内存连续地址划分以及垃圾回收算法的相关字段。简单介绍一下初始化时预分配的地址空间内容。上一节没有详细说明的大于32KB的对象会直接在mheap进行分配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465type mheap struct &#123; lock mutex pages pageAlloc // 内存页存储结构 sweepgen uint32 // gc相关 sweepdone uint32 // gc相关 sweepers uint32 // gc相关 // allspans包含所有已构建的span指针列表. 每个span只出现一次 //其内存地址会随着堆的增长进行移动和再分配 allspans []*mspan // gc相关 sweepSpans [2]gcSweepBuf _ uint32 // uint64对齐到32-bit，保证原子性 // gc相关 pagesInUse uint64 pagesSwept uint64 pagesSweptBasis uint64 sweepHeapLiveBasis uint64 sweepPagesPerByte float64 //堆持有的虚拟内存总量，runtime通过将内存交还操作系统来维持 scavengeGoal uint64 // Page reclaimer state reclaimIndex uint64 reclaimCredit uintptr // 分配状态 largealloc uint64 // 为大对象分配的字节数目 nlargealloc uint64 // 可以分配的大对象数目 largefree uint64 // 剩余大对象可分配字节数目 nlargefree uint64 // 剩余大对象可分配数目 nsmallfree [_NumSizeClasses]uint64 // 可分配小对象数目 //该数组用于管理所有的heapArena，包含了span指针区，bitmap区和真正的堆区 arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena // 堆分配相关 heapArenaAlloc linearAlloc arenaHints *arenaHint arena linearAlloc // 可用大对象地址空间的迭代 allArenas []arenaIdx // GC相关 sweepArenas []arenaIdx // GC相关 markArenas []arenaIdx // 堆增长的位置 curArena struct &#123; base, end uintptr &#125; // 核心功能，对应的mcentral列表 central [numSpanClasses]struct &#123; mcentral mcentral pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]byte &#125;&#125; 堆区的内存页以arena的数组的形式进行保存，大内存对象（&gt;32KB）直接经过arena进行分配，其结构如下所示： 123456789101112131415161718192021type heapArena struct &#123; //用于垃圾回收时的标记位图，表示对应span的情况，在gc章节会详细讲述 bitmap [heapArenaBitmapBytes]byte //虚地址页ID在span上的ID映射与spans指针集合(页号对应的已分配span指针) spans [pagesPerArena]*mspan // 页号所处的span是否被使用，GC相关 pageInUse [pagesPerArena / 8]uint8 // 页号所处的span是否被标记，GC相关 pageMarks [pagesPerArena / 8]uint8 // pageSpecials is a bitmap that indicates which spans have // specials (finalizers or other). Like pageInUse, only the bit // corresponding to the first page in each span is used. pageSpecials [pagesPerArena / 8]uint8 // 标志本arena第一页的第一个字节 zeroedBase uintptr&#125; 全貌总结 总结一下全文， 本文所讲的内存分配基本上是关于堆区的内存分配，但是我们在写代码时可以尽量使得对象和变量位于栈区，在编译器能够确定内存大小就不必走本文的内存分配机制。 堆区在Go语言中提供了两种基本抽象，一种是包含并管理虚拟内存页的heapArena，另一种是针对32KB以下对象进行管理的具有不同大小的span 与操作系统的交互、内存管理伙伴系统的实现由堆区进行，同时堆区也维持了虚拟页号到span的映射用于合并内存减少外部碎片问题 mcentral管理不同类型的 span集合，每一个process（Go中指线程）向所需mecentral申请span同时拥有自己的span缓存","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"内存模型","slug":"内存模型","permalink":"https://kimanyang.xyz/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"Tcmalloc","slug":"Tcmalloc","permalink":"https://kimanyang.xyz/tags/Tcmalloc/"}]},{"title":"Go语言垃圾回收","slug":"Go语言垃圾回收 54997","date":"2021-07-28T01:58:24.000Z","updated":"2022-03-10T15:38:56.147Z","comments":true,"path":"2021/07/28/Go语言垃圾回收 54997/","link":"","permalink":"https://kimanyang.xyz/2021/07/28/Go%E8%AF%AD%E8%A8%80%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2054997/","excerpt":"","text":"Go语言垃圾回收垃圾回收的基本概念对于存在于栈区的内存，当栈所对应的进程、线程或者协程终止时，其中分配的内存会被自动销毁。但是如果所需的内存较大并且内存分配在堆区，事情变得复杂起来，可能有多个进程、线程或者协程甚至只是简单的不同的函数共享一个对象的内存，如果对象不再被使用后这部分内存没有被销毁，那么会造成内存泄漏，当内存泄漏积累到一定程度内存被耗尽则可能造册内存溢出。因此设计一套合理的内存释放方法十分有必要。 在C++、C中内存释放的时机交由程序员自己手动管理，Rust在语言层面采取了RAII（资源获取即初始化）的设计模式，在编译阶段保证了内存不会泄露，但这也给程序书写的灵活性带来极大的困难。更多的现代语言采用专门垃圾收集器（Garbage Collector, GC)来保证用户不需要耗费过多的精力在内存管理上而是专注于功能的实现。 垃圾回收方法介绍RAII资源获取即初始化严格来说这不能称为GC算法，利用了局部变量自动销毁的特性，声明全局对象的生命周期或者进行引用计数，在对象不再被使用后确保会被清除，在C++中通过各种智能指针以及类的析构函数来实现这一思想，还有Object-C提供的ARC自动引用计数方法，也是一种语言层面的RAII。但是这种内存管理方法这仍然会给我这种菜比程序员带来很大的心智负担。 标记清除最为原始的GC方法，程序使用替身能力开启STW（stop the world）停止所有任务的执行，垃圾收集器从主程序的栈开始递归遍历所有被引用的对象并进行标记，所有没有被标记的对象都将被清除。这种想法很好理解，在Go早期采用过这样的方法，采用Muatator&#x2F;Allocator&#x2F;Collector对mheap区的内存进行标记、分配以及回收。 但这么做显然会带来很大的性能问题，一般是假定内存占用达到某个阈值开始进行STW，如果阈值太低那么STW触发过于频繁导致总体性能下降，阈值太高则容易使得标记清除时间过长用户程序等待过久，在很多时候这种情况是令人无法忍受的。 上图分别表示了标记阶段与清除阶段的操作，箭头指示了引用关系。 三色标记最最基础三色标记本身并不比原始的标记清除高效许多，其标记过程可能可以通过一定的多线程手段加速，但是这个过程仍然无法并发进行，需要进行STW ，它的存在更重要的是作为一层抽象成为进一步GC算法的基础。其原理仍然很简单，如果说原始的标记清除法递归地查找根节点可达对象树是深度优先搜索，那么三色标记就是其广度优先搜索版本。 三色指的是三种对象标记： 灰色对象：存在指向白色对象的指针的对象，属于活跃对象 黑色对象：根节点可达且不存在引用白色对象外部指针的对象，属于活跃对象 白色对象：潜在的垃圾，可能会被垃圾回收器回收（不一定会立刻回收） 我们将标记阶段归纳为： 一开始将所有的对象标记为白色，根节点标记为灰色 从灰色对象集合中选取一个对象标记为黑色，再将其引用的所有对象都标记为灰色 重复步骤2直到没有灰色对象 标记阶段结束后垃圾收集器回收所有的白色对象。 显然如果在标记过程中采用并发执行程序导致引用关系被修改，产生“悬浮指针”是十分危险的 三色不变性读写屏障假设我们要在三色标记的同时对对象进行操作，要求操作后的所有对象不会产生诸如上述的“悬浮指针”这样的错误清除操作，这使得清除阶段可以和程序运行交替进行或者并发进行，从而大大提高垃圾回收的效率，这时候我们需要做些什么呢？保证三色不变性的读写屏障技术可以帮助我们解决这个问题。 首先介绍一下三色不变性： 强三色不变性：保证黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象 弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径(P. P. Pirinen. Barrier techniques for incremental tracing. In ACM SIGPLAN Notices, 34(3), 20–25, October 1998. https://dl.acm.org/doi/10.1145/301589.286863 ↩︎) 满足两个不变性中的一个即可保证GC算法的正确性，强三色不变性很好理解，根本上不可能产生悬浮指针，而弱三色不变性则保证了指向的白色对象由于终将染成黑色所以也能保证不产生悬浮指针。采用屏障技术从而保证三色不变性，编程语言有两种选择——读屏障（Read Barrier)和写屏障(Write Barrier)两种，一般来说读操作在程序执行时远远多于写操作，而屏障技术属于一种钩子或者触发器函数在对象进行读写时触发，有一定的开销，所以选取更少触发的写屏障可以更好地提高程序执行的效率。 Go语言的垃圾回收技术采用了两种写屏障：Dijkstra插入写屏障和Yuasa删除写屏障 Dijkstra插入写屏障 当黑色对象修改其引用，指向了一个白色对象时，将白色对象染为灰色，从而保证了强三色不变性，下图展示了其工作流程，标记时切换到主程序，主程序在修改A对象指针时将白色对象C染为灰色，在下一轮切换回标记时灰色对象被染黑。 这种保守的写法可能将不再存活的B标记为黑色，而若是下一次切换到主程序时A又把C的指针改回去，那么标记为黑色的C不再存活却得等到下一轮GC标记开始才能被回收。 同时由于栈上元素也被认为是根节点元素，同一个对象可能是多个根节点可达的，而一次标记可能只从单个根节点开始，所以要么将栈上的对象也纳入读写屏障的范围，要么在每次切换到GC时都咋瓦鲁多标记栈上元素为恒灰（为什么不能是黑？因为用户程序可能在栈上引用了白色节点破坏了三色不变性） Yuasa删除写屏障 针对所有的指针，当该指针所引用的对象发生改变或者指针被删除时，指针原本所引用的对象标记为灰色，通过这种屏障操作能够实现弱三色不变性。一开始GC标记到A为黑B为灰，切到了主程序，图中A指向B的指针drop到C时将B标记为灰色，由于B本来就是灰的所以无影响，此时弱三色不变性得以保证（C可有灰色对象B到达）；下一步主程序B指向C的指针drop掉，由于删除写屏障C被标记为灰色，弱三色不变性仍然得以保证。 增量垃圾回收与并发垃圾回收有了三色不变性以及屏障技术的理论支持，我们可以将基本的三色标记法扩展为增量以及并发的版本。回忆一下之前所说的STW垃圾回收的缺点：STW间隔时间过长，导致内存过大，GC时用户程序无响应时间过长导致用户无法忍受（想象一下程序流畅运行一段时间后完全无响应，之后才有响应）；STW间隔过短浪费CPU资源。 增量垃圾回收 这种方法减少的是最长暂停时间，虽然将完整的一次垃圾回收时间拉长，但是减少了用户程序的等待时间。具体做法跟我们示例读写屏障中的切换垃圾回收与用户程序类似，触发垃圾回收后将时间切换为时间片，GC标记程序和用户程序用完各自时间片后暂停交由对方运行。 不过这要求用户程序在GC期间运行写屏障，会导致一定的开销，不过总体上利大于弊。 并发垃圾回收 GC和用户程序并发运行，具体设计十分复杂，在下一章会详细分析Go所用的并发垃圾回收技术。并发不能完全避免STW，会占用一定的CUP以及内存资源影响用户程序执行。但可以无限接近完美。 混合写屏障该方法用于解决我们所说的Dijkstra写屏障的弊端，之前说过为了安全没有被扫描的栈的根对象要么纳入写屏障，要么STW进行添加，但是在Go中几百个Goroutine都有自己栈，全部扫描一遍是不可接受的，完全纳入写屏障开销也十分巨大，那么采用混合写屏障可以缓解这个问题。 混合写屏障：在保证执行汤浅写屏障的前提下，如果当前栈没有被扫描，执行Dijkstra写屏障 同时在GC期间所有新创建的对象都设置为黑色，防止新分配的栈内存和堆内存对象被错误回收。 Go语言垃圾回收简介未完待续","categories":[{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://kimanyang.xyz/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]}],"categories":[{"name":"控制理论","slug":"控制理论","permalink":"https://kimanyang.xyz/categories/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"},{"name":"Golang学习","slug":"Golang学习","permalink":"https://kimanyang.xyz/categories/Golang%E5%AD%A6%E4%B9%A0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/categories/Javascript/"},{"name":"CSS","slug":"CSS","permalink":"https://kimanyang.xyz/categories/CSS/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"由实例开始构造正则引擎","slug":"由实例开始构造正则引擎","permalink":"https://kimanyang.xyz/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"卡尔曼滤波","slug":"卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"优化算法","slug":"优化算法","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},{"name":"分布式卡尔曼滤波","slug":"分布式卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"Golang","slug":"Golang","permalink":"https://kimanyang.xyz/tags/Golang/"},{"name":"Cookie","slug":"Cookie","permalink":"https://kimanyang.xyz/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"https://kimanyang.xyz/tags/Token/"},{"name":"Session","slug":"Session","permalink":"https://kimanyang.xyz/tags/Session/"},{"name":"身份认证","slug":"身份认证","permalink":"https://kimanyang.xyz/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"},{"name":"扩展卡尔曼滤波","slug":"扩展卡尔曼滤波","permalink":"https://kimanyang.xyz/tags/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"},{"name":"模型预测控制","slug":"模型预测控制","permalink":"https://kimanyang.xyz/tags/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/"},{"name":"matlab","slug":"matlab","permalink":"https://kimanyang.xyz/tags/matlab/"},{"name":"二次规划","slug":"二次规划","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/"},{"name":"多智能体","slug":"多智能体","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/"},{"name":"图论","slug":"图论","permalink":"https://kimanyang.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"一致性","slug":"一致性","permalink":"https://kimanyang.xyz/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://kimanyang.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Javascript","slug":"Javascript","permalink":"https://kimanyang.xyz/tags/Javascript/"},{"name":"页面事件","slug":"页面事件","permalink":"https://kimanyang.xyz/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/"},{"name":"前端经典案例","slug":"前端经典案例","permalink":"https://kimanyang.xyz/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"},{"name":"事件流模型","slug":"事件流模型","permalink":"https://kimanyang.xyz/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/"},{"name":"DOM事件","slug":"DOM事件","permalink":"https://kimanyang.xyz/tags/DOM%E4%BA%8B%E4%BB%B6/"},{"name":"DOM模型","slug":"DOM模型","permalink":"https://kimanyang.xyz/tags/DOM%E6%A8%A1%E5%9E%8B/"},{"name":"H5标签","slug":"H5标签","permalink":"https://kimanyang.xyz/tags/H5%E6%A0%87%E7%AD%BE/"},{"name":"CSS过渡","slug":"CSS过渡","permalink":"https://kimanyang.xyz/tags/CSS%E8%BF%87%E6%B8%A1/"},{"name":"CSS3新特性","slug":"CSS3新特性","permalink":"https://kimanyang.xyz/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"CSS布局","slug":"CSS布局","permalink":"https://kimanyang.xyz/tags/CSS%E5%B8%83%E5%B1%80/"},{"name":"CSS三角与精灵图","slug":"CSS三角与精灵图","permalink":"https://kimanyang.xyz/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/"},{"name":"CSS 溢出显示","slug":"CSS-溢出显示","permalink":"https://kimanyang.xyz/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/"},{"name":"CSS浮动与定位","slug":"CSS浮动与定位","permalink":"https://kimanyang.xyz/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/"},{"name":"CSS选择器","slug":"CSS选择器","permalink":"https://kimanyang.xyz/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"},{"name":"CSS盒模型","slug":"CSS盒模型","permalink":"https://kimanyang.xyz/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"name":"C++","slug":"C","permalink":"https://kimanyang.xyz/tags/C/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://kimanyang.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LRU","slug":"LRU","permalink":"https://kimanyang.xyz/tags/LRU/"},{"name":"LFU","slug":"LFU","permalink":"https://kimanyang.xyz/tags/LFU/"},{"name":"STL容器","slug":"STL容器","permalink":"https://kimanyang.xyz/tags/STL%E5%AE%B9%E5%99%A8/"},{"name":"BitSet","slug":"BitSet","permalink":"https://kimanyang.xyz/tags/BitSet/"},{"name":"STL","slug":"STL","permalink":"https://kimanyang.xyz/tags/STL/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"https://kimanyang.xyz/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"优先队列","slug":"优先队列","permalink":"https://kimanyang.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"多路归并","slug":"多路归并","permalink":"https://kimanyang.xyz/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/"},{"name":"动态规划","slug":"动态规划","permalink":"https://kimanyang.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"快速排序","slug":"快速排序","permalink":"https://kimanyang.xyz/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"https://kimanyang.xyz/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"https://kimanyang.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分法","slug":"二分法","permalink":"https://kimanyang.xyz/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"编译原理","slug":"编译原理","permalink":"https://kimanyang.xyz/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"刷题总结","slug":"刷题总结","permalink":"https://kimanyang.xyz/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"Rabin-Karp","slug":"Rabin-Karp","permalink":"https://kimanyang.xyz/tags/Rabin-Karp/"},{"name":"哈希算法","slug":"哈希算法","permalink":"https://kimanyang.xyz/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"https://kimanyang.xyz/tags/KMP/"},{"name":"状态机DP","slug":"状态机DP","permalink":"https://kimanyang.xyz/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"https://kimanyang.xyz/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"非线性控制","slug":"非线性控制","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/"},{"name":"非自治系统","slug":"非自治系统","permalink":"https://kimanyang.xyz/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"},{"name":"自治系统","slug":"自治系统","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/"},{"name":"自适应控制","slug":"自适应控制","permalink":"https://kimanyang.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/"},{"name":"控制系统设计","slug":"控制系统设计","permalink":"https://kimanyang.xyz/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"机械臂","slug":"机械臂","permalink":"https://kimanyang.xyz/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"},{"name":"八股文","slug":"八股文","permalink":"https://kimanyang.xyz/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"GMP模型","slug":"GMP模型","permalink":"https://kimanyang.xyz/tags/GMP%E6%A8%A1%E5%9E%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://kimanyang.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内存模型","slug":"内存模型","permalink":"https://kimanyang.xyz/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"Tcmalloc","slug":"Tcmalloc","permalink":"https://kimanyang.xyz/tags/Tcmalloc/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://kimanyang.xyz/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]}