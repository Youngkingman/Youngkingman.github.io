<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>敏感词匹配问题——KMP、Trie到AC自动机 - Brief Candle</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="敏感词匹配问题——KMP、Trie到AC自动机寅宝最近向我炫耀了他在业务中用到的最先进的算法居然是字典树，并解释这个业务是要做敏感词匹配。 没有打过比赛的我第一反应觉得应该使用DFA（或正则调库）来解决这个问题，编译一个模式串就可以判断有无敏感词。 但是这种解决方法的缺点就是随着敏感词增加模式串增加每次都需要重新编译出一次DFA。 寅宝提出的方案是字典树，实际上如果正则引擎有做优化的话那编译出来的">
<meta property="og:type" content="article">
<meta property="og:title" content="敏感词匹配问题——KMP、Trie到AC自动机">
<meta property="og:url" content="https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/index.html">
<meta property="og:site_name" content="Brief Candle">
<meta property="og:description" content="敏感词匹配问题——KMP、Trie到AC自动机寅宝最近向我炫耀了他在业务中用到的最先进的算法居然是字典树，并解释这个业务是要做敏感词匹配。 没有打过比赛的我第一反应觉得应该使用DFA（或正则调库）来解决这个问题，编译一个模式串就可以判断有无敏感词。 但是这种解决方法的缺点就是随着敏感词增加模式串增加每次都需要重新编译出一次DFA。 寅宝提出的方案是字典树，实际上如果正则引擎有做优化的话那编译出来的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton1.gif">
<meta property="og:image" content="https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton2.gif">
<meta property="og:image" content="https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton3.gif">
<meta property="article:published_time" content="2022-04-15T06:06:14.000Z">
<meta property="article:modified_time" content="2022-04-20T10:31:57.718Z">
<meta property="article:author" content="Kiman Yang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="KMP">
<meta property="article:tag" content="编译原理">
<meta property="article:tag" content="正则表达式">
<meta property="article:tag" content="刷题总结">
<meta property="article:tag" content="Trie字典树">
<meta property="article:tag" content="AC自动机">
<meta property="article:tag" content="路径压缩">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton1.gif">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1650450827413">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1650450827413">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1650450827413">
    <link rel="stylesheet" href="/css/style.css?v=1650450827413">
    
        <link rel="stylesheet" href="/css/dark.css?v=1650450827413">
     
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(/images/yuanxiang.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Kiman Yang" class="mdui-btn mdui-btn-icon"><img src="/images/aqua.png" alt="Kiman Yang"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Kiman Yang">
            <img src="/images/aqua.png" alt="Kiman Yang" alt="Kiman Yang">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>33</div>
        <div><span>标签</span>71</div>
        <div><span>分类</span>6</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/Youngkingman" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/401742377" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/Youngkingman" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CSS/">CSS</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Golang学习/">Golang学习</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Javascript/">Javascript</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/控制理论/">控制理论</a>
          <span class="category-list-count">9</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/由实例开始构造正则引擎/">由实例开始构造正则引擎</a>
          <span class="category-list-count">2</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 10px;">AC自动机</a> <a href="/tags/BitSet/" style="font-size: 10px;">BitSet</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/" style="font-size: 10px;">CSS 溢出显示</a> <a href="/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 10px;">CSS3新特性</a> <a href="/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/" style="font-size: 10px;">CSS三角与精灵图</a> <a href="/tags/CSS%E5%B8%83%E5%B1%80/" style="font-size: 11.67px;">CSS布局</a> <a href="/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">CSS浮动与定位</a> <a href="/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">CSS盒模型</a> <a href="/tags/CSS%E8%BF%87%E6%B8%A1/" style="font-size: 10px;">CSS过渡</a> <a href="/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/" style="font-size: 10px;">CSS选择器</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/DOM%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">DOM事件</a> <a href="/tags/DOM%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">DOM模型</a> <a href="/tags/GMP%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">GMP模型</a> <a href="/tags/Golang/" style="font-size: 18.33px;">Golang</a> <a href="/tags/H5%E6%A0%87%E7%AD%BE/" style="font-size: 10px;">H5标签</a> <a href="/tags/HJB%E6%96%B9%E7%A8%8B/" style="font-size: 10px;">HJB方程</a> <a href="/tags/Javascript/" style="font-size: 11.67px;">Javascript</a> <a href="/tags/KMP/" style="font-size: 11.67px;">KMP</a> <a href="/tags/LFU/" style="font-size: 10px;">LFU</a> <a href="/tags/LQR%E7%AE%97%E6%B3%95/" style="font-size: 10px;">LQR算法</a> <a href="/tags/LRU/" style="font-size: 10px;">LRU</a> <a href="/tags/Rabin-Karp/" style="font-size: 10px;">Rabin-Karp</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/STL%E5%AE%B9%E5%99%A8/" style="font-size: 11.67px;">STL容器</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Tcmalloc/" style="font-size: 10px;">Tcmalloc</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Trie%E5%AD%97%E5%85%B8%E6%A0%91/" style="font-size: 10px;">Trie字典树</a> <a href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">lambda表达式</a> <a href="/tags/matlab/" style="font-size: 11.67px;">matlab</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 10px;">一致性</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">事件流模型</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 10px;">二分法</a> <a href="/tags/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/" style="font-size: 10px;">二次规划</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">优化算法</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 13.33px;">八股文</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">内存模型</a> <a href="/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" style="font-size: 10px;">凸优化</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" style="font-size: 10px;">分布式卡尔曼滤波</a> <a href="/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 13.33px;">刷题总结</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/" style="font-size: 10px;">前端经典案例</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 11.67px;">动态规划</a> <a href="/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" style="font-size: 11.67px;">卡尔曼滤波</a> <a href="/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">哈希算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">堆排序</a> <a href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 10px;">多智能体</a> <a href="/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/" style="font-size: 10px;">多路归并</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" style="font-size: 10px;">扩展卡尔曼滤波</a> <a href="/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">控制系统设计</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 13.33px;">数据结构与算法</a> <a href="/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/" style="font-size: 10px;">机械臂</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">模型预测控制</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 16.67px;">正则表达式</a> <a href="/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/" style="font-size: 10px;">状态机DP</a> <a href="/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 10px;">矩阵快速幂</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 13.33px;">编译原理</a> <a href="/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">自治系统</a> <a href="/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/" style="font-size: 11.67px;">自适应控制</a> <a href="/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/" style="font-size: 10px;">路径压缩</a> <a href="/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" style="font-size: 10px;">身份认证</a> <a href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/" style="font-size: 15px;">非线性控制</a> <a href="/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">非自治系统</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">页面事件</a>
    </div>
    
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Kiman Yang
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 77.16666666666666%;"> 
              <img data-src="/cover/yuanxiangcover45.jpg" data-sizes="auto" alt="敏感词匹配问题——KMP、Trie到AC自动机" class="lazyload">
              <h1>敏感词匹配问题——KMP、Trie到AC自动机</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年04月15日</a>
</div>

      

      <h1 id="敏感词匹配问题——KMP、Trie到AC自动机"><a href="#敏感词匹配问题——KMP、Trie到AC自动机" class="headerlink" title="敏感词匹配问题——KMP、Trie到AC自动机"></a>敏感词匹配问题——KMP、Trie到AC自动机</h1><p><a target="_blank" rel="noopener" href="https://github.com/ChenZhenyin">寅宝</a>最近向我炫耀了他在业务中用到的最先进的算法居然是字典树，并解释这个业务是要做敏感词匹配。</p>
<p>没有打过比赛的我第一反应觉得应该使用DFA（或正则调库）来解决这个问题，编译一个模式串就可以判断有无敏感词。</p>
<p>但是这种解决方法的缺点就是随着敏感词增加模式串增加每次都需要重新编译出一次DFA。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ChenZhenyin">寅宝</a>提出的方案是字典树，实际上如果正则引擎有做优化的话那编译出来的DFA也就是一颗字典树（大概类似用<code>|</code>连接每一个敏感词模式串然后进行捕捉替换），比起我的想法这种更加适合热更新，每次只要执行脚本修改内存中的字典树即可。</p>
<p>但显然我们都太菜了，在实际中采用的方案通常是AC自动机。这个方案结合了KMP算法中<code>next</code>数组的思路和字典树多模式匹配的优势，本文先回忆了一下KMP的基本思想，然后再给出正常的字典树写法，最后介绍AC自动机。</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>首先我们描述单模式匹配要解决的问题，我们有一个长度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>文本字符串<code>text</code>和一个对应的长度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>模式串<code>pattern</code>，我们要寻找文本字符串<code>text</code>中是否包含模式串，必要的时候把所有模式串的起点都标出来（返回数组表示每个对应模式文本起始位置）。</p>
<p>最容易想到的就是从文本串的每个字符开始往后按位遍历模式串看是否满足匹配，这种做法的缺点显而易见，时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.83ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3019 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2030,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2630,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p>
<h3 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h3><p>在解释KMP算法之前我们先完整展示下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> algorithm<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KMPMatch</span><span class="hljs-params">(text <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> {<br>	<span class="hljs-keyword">if</span> pattern == <span class="hljs-string">""</span> {<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	}<br>	next := getNext(pattern)<br>	pat_ptr, tar_ptr := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> tar_ptr &lt; <span class="hljs-built_in">len</span>(text) {<br>		<span class="hljs-keyword">if</span> text[tar_ptr] == pattern[pat_ptr] {<br>			tar_ptr += <span class="hljs-number">1</span><br>			pat_ptr += <span class="hljs-number">1</span><br>		} <span class="hljs-keyword">else</span> {<br>			<span class="hljs-keyword">if</span> pat_ptr == <span class="hljs-number">0</span> {<br>				tar_ptr += <span class="hljs-number">1</span><br>			} <span class="hljs-keyword">else</span> {<br>				pat_ptr = next[pat_ptr<span class="hljs-number">-1</span>]<br>			}<br>		}<br>		<span class="hljs-keyword">if</span> pat_ptr == <span class="hljs-built_in">len</span>(pattern) {<br>			<span class="hljs-keyword">return</span> tar_ptr - pat_ptr<br>		}<br>	}<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNext</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>)</span></span> (next []<span class="hljs-type">int</span>) {<br>	pre_ptr, itr_ptr := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>	next = <span class="hljs-built_in">append</span>(next, <span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">for</span> itr_ptr &lt; <span class="hljs-built_in">len</span>(pattern) {<br>		<span class="hljs-keyword">if</span> pattern[pre_ptr] == pattern[itr_ptr] {<br>			pre_ptr += <span class="hljs-number">1</span><br>			itr_ptr += <span class="hljs-number">1</span><br>			next = <span class="hljs-built_in">append</span>(next, pre_ptr)<br>		} <span class="hljs-keyword">else</span> {<br>			<span class="hljs-keyword">if</span> pre_ptr == <span class="hljs-number">0</span> {<br>				next = <span class="hljs-built_in">append</span>(next, <span class="hljs-number">0</span>)<br>				itr_ptr += <span class="hljs-number">1</span><br>			} <span class="hljs-keyword">else</span> {<br>				pre_ptr = next[pre_ptr<span class="hljs-number">-1</span>]<br>			}<br>		}<br>	}<br>	<span class="hljs-keyword">return</span><br>}<br></code></pre></td></tr></table></figure>

<p>上述代码匹配成功后是直接退出的，但是也可以匹配成功后记录结果回退后文要讲的<code>next</code>数组继续匹配，从而寻找所有成功匹配点，这种做法通常也被称作所谓的“KMP自动机”。</p>
<h3 id="匹配部分解析"><a href="#匹配部分解析" class="headerlink" title="匹配部分解析"></a>匹配部分解析</h3><p>对于每一个模式串，即我们要匹配的敏感词其自身拥有一个待匹配的数组成为<code>next</code>数组，其严格定义为：<code>next</code>数组长度于模式串长度相同，其每一位<code>i</code>对应的值<code>k</code>表示对于模式串从0到<code>i</code>的子串前<code>k</code>位和后<code>k</code>位恰好相同的最大的<code>k</code>，特别的<code>k</code>不能取为<code>i+1</code>，因为自身肯定和自身相等（这一点是为了回退考虑）。</p>
<p>比如对于下面的模式串：<code>TobeOrNoTobe</code>来说，它的<code>next</code>数组为<code>000000001234</code>，仅仅有后四位跟模式串的前四位分别匹配。</p>
<p>比如我们要匹配<code>TobeOrNoTobringTobeOrNoTobe</code>，显然在<code>bring</code>处失配了，那么此时对应的模式串适配位置<code>next</code>数组的值就是4，我们只需要将头指针移动到失配处往前移动4位开始下一轮匹配即可；如果失配处是0，那么前面的部分可以完全舍弃，直接将头指针移动到失配的下一位开始下一轮匹配即可。这部分作为核心框架</p>
<p>这种做法能够将复杂度降低到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="9.596ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4241.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2252.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3252.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3852.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>的水平，相比原来提高了许多。</p>
<h3 id="获取Next数组"><a href="#获取Next数组" class="headerlink" title="获取Next数组"></a>获取Next数组</h3><p>那么我们如何获得<code>next</code>数组呢？我们具有在<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.473ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2419 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2030,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>的时间复杂度之内构造<code>next</code>数组的方法，也即上面代码的核心部分<code>getNext()</code>，这部分也是<code>KMP</code>算法的核心思想，即模式串与模式串自己匹配来求取<code>Next</code>数组。</p>
<p>在初始时刻我们有一个前缀指针<code>pre_ptr</code>设置为0和迭代指针<code>itr_ptr</code>设置为1，<code>next</code>数组出于其自身性质首位被设置为0。</p>
<p>在每次循环中我们考虑两种情况：</p>
<ul>
<li>前缀指针的字符能够和当前的迭代指针匹配：两个指针各自后移一位，<code>next</code>数组的<code>itr_ptr-1</code>位设置为当前<code>pre_ptr</code>的值（或者如代码中直接插入，效率较低）</li>
<li>前缀指针字符和当前迭代指针失配：<ul>
<li>如果<code>pre_ptr</code>是首位，那么<code>itr_ptr</code>位设为0，<code>itr_ptr</code>后移一位，否则：</li>
<li>当前的<code>pre_ptr</code>不在首位。这一步利用到了<code>next</code>数组的<strong>递推</strong>构造性质，也是构造过程实现线性时间复杂度的核心所在，**<code>pre_ptr</code>位会退回当前<code>pre_ptr</code>前一位的<code>next</code>数组值**</li>
</ul>
</li>
</ul>
<p>这里我们详细解释一下为什么是回退当前前一位的的<code>next</code>数组值。例如我们构造了模式串：<code>abcabxxxabcabc</code>，那我们的<code>next</code>数组将会是<code>00012000123453</code>，当我们按照上述算法在匹配到最后一位的时候会出现<code>pre_ptr=5,itr_ptr=13</code>，此时<code>next[itr_ptr]</code>的值应该设置为3，这恰好是<code>next[pre_ptr-1]+1</code>的值，也就是说我们失配的时候前缀数组的指针移动到了<code>next[pre_ptr-1]</code>的位置，这是因为我们希望在失配后当前位置重新匹配的前缀要尽可能地长，而失配前我们已经完整匹配了<code>abcab</code>五个字母，那么下一次检验是否匹配的起始位置就应该<code>pre_ptr</code>的前一个位置所能完整匹配的前缀起始位置。</p>
<p>自此我们完整描述了<code>KMP</code>算法的完整过程，读者可以用手执行一遍上述例子更好理解这个算法。</p>
<h2 id="Trie字典树"><a href="#Trie字典树" class="headerlink" title="Trie字典树"></a>Trie字典树</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>字典树要解决的问题的是单词查找的问题，也即多模匹配。“多模”意味着多个模式串，而KMP问题仅仅只能解决单个模式串的匹配。字典树能够做到：给出一个字典集合，我们能在<strong>线性时间</strong>复杂度内实现某个待查找的串是否<strong>属于</strong>字典。注意我们此时还未考虑子串匹配的问题。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先给出<code>Trie</code>的代码实现。思路很好理解，看代码即可，实质上就是一个<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>叉树，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>为字符集大小，下面两份代码展现小写字母情况下的Trie树构建，分别是C++和Golang。</p>
<p>插入单词时递推构建树的节点，如果有重复则无需重新构造对应字符</p>
<h4 id="Go版本"><a href="#Go版本" class="headerlink" title="Go版本"></a>Go版本</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> {<br>    Inner <span class="hljs-type">byte</span><br>    Children []*Trie<br>    IsEnd <span class="hljs-type">bool</span><br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie {<br>    ori := <span class="hljs-built_in">make</span>([]*Trie,<span class="hljs-number">26</span>)<br>    <span class="hljs-keyword">return</span> Trie {<br>        <span class="hljs-type">byte</span>(<span class="hljs-string">'0'</span>),<br>        ori,<br>        <span class="hljs-literal">false</span>,<br>    }<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  {<br>    cur := this<br>    <span class="hljs-keyword">for</span> i, ch:=<span class="hljs-keyword">range</span> word {<br>        <span class="hljs-keyword">if</span> cur.Children[ch-<span class="hljs-string">'a'</span>] != <span class="hljs-literal">nil</span> {<br>            cur = cur.Children[ch-<span class="hljs-string">'a'</span>]<br>            cur.IsEnd = (i == <span class="hljs-built_in">len</span>(word)<span class="hljs-number">-1</span>) || (cur.IsEnd) <br>        } <span class="hljs-keyword">else</span> {<br>            tmp := <span class="hljs-built_in">make</span>([](*Trie),<span class="hljs-number">26</span>)<br>            node := Trie {<br>                <span class="hljs-type">byte</span>(ch),<br>                tmp,<br>                i == <span class="hljs-built_in">len</span>(word) <span class="hljs-number">-1</span>,<br>            }<br>            cur.Children[ch-<span class="hljs-string">'a'</span>] = &amp;node <br>            cur = cur.Children[ch-<span class="hljs-string">'a'</span>]<br>        }<br>    }<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> {<br>    cur := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word {<br>        <span class="hljs-keyword">if</span> cur.Children[ch-<span class="hljs-string">'a'</span>] == <span class="hljs-literal">nil</span> {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        }<br>        cur = cur.Children[ch-<span class="hljs-string">'a'</span>]<br>    }<br>    <span class="hljs-keyword">return</span> cur.IsEnd<br>}<br></code></pre></td></tr></table></figure>

<h4 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-type">bool</span> isEnd;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>){}<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>{<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch:word){<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch-<span class="hljs-string">'a'</span>]==<span class="hljs-literal">nullptr</span>){<br>                node-&gt;children[ch-<span class="hljs-string">'a'</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            }<br>            node = node-&gt;children[ch - <span class="hljs-string">'a'</span>];<br>        }<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>{<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch:word){<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            node = node-&gt;children[ch - <span class="hljs-string">'a'</span>];<br>        }<br>        <span class="hljs-keyword">return</span> node-&gt;isEnd;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>{<br>        Trie* node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch:prefix){<br>            <span class="hljs-keyword">if</span>(node-&gt;children[ch - <span class="hljs-string">'a'</span>] == <span class="hljs-literal">nullptr</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            node = node-&gt;children[ch - <span class="hljs-string">'a'</span>];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></table></figure>

<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>接下来到了这篇文章最重点的部分AC自动机了，建议读者能够把前两个算法完全理解再来看这部分。</p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/string/ac-automaton/">AC 自动机 - OI Wiki (oi-wiki.org)</a>这篇文章写的很好强烈推荐一下。笔者按照自己的理解给出代码并进行解释。</p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>Aho–Corasick算法是由<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%B0%94%E4%BD%9B%E9%9B%B7%E5%BE%B7%C2%B7%E8%89%BE%E4%BE%AF">Alfred V. Aho</a>和Margaret J.Corasick 发明的字符串搜索算法。已知<code>KMP</code>虽然能够实现随机长度文本的线性时间复杂度单模匹配但是多模匹配的时间复杂度是乘方的；<code>Tire</code>能够实现定长文本的线性时间多模匹配但是对于随机长度文本的多模匹配时间复杂度也是乘方的。</p>
<p>自然我们的任务是<strong>敏感词匹配</strong>，对于给定的敏感词字典在不确定长度的文本中进行匹配，匹配成功后进行屏蔽或者封号之类的操作，非常具有拆腻子特色了，是一个简中互联网实用算法。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>AC自动机相比于普通的字典树多了一个<code>fail</code>指针来给定失败情况下需要跳转到哪一个状态重新开始匹配，这很类似于KMP中的<code>next</code>数组做的事，只不过我们从模式串指针变为了节点，这两者之间主要的不同是：<code>next</code>指针失配仅仅需要针对当前模式求最长相同前后缀，但是<code>fail</code>指针需要匹配<strong>所有模式串</strong>能够匹配当前状态的最长后缀。比如<code>soobxxxoob/oob</code>都在字典中，那么在模式串<code>soobxxxoob</code>的多个<code>oob</code>处其<code>fail</code>指针指向另外一个模式串<code>oob</code>对应的<code>oob</code>处。</p>
<p>总结一下就是建立AC自动机分为两步：</p>
<ol>
<li>将所有模式串构建为一颗Trie树</li>
<li>参考<code>KMP</code>算法的思想，对<code>Trie</code>树上的每个节点构造对应的<code>fail</code>指针</li>
</ol>
<p>字典树的搭建就不多赘述，算法的核心就在于构造每个结点的<code>fail</code>指针。</p>
<h3 id="构造fail指针"><a href="#构造fail指针" class="headerlink" title="构造fail指针"></a>构造fail指针</h3><p>基本的想法是这样的：考虑字典树中的节点<code>u</code>，其父节点为<code>p</code>，边<code>(p,u)</code>通过字符<code>ch</code>连接，这种状态转移记作<code>Trie[p,ch]=u</code>。由于<code>fail</code>指针是按照广度优先的方式进行遍历的，我们假设高度小于<code>u</code>节点的所有节点都已求得<code>fail</code>指针。</p>
<ol>
<li>如果<code>Trie[fail[p],ch]</code>存在（此时<code>fail[p]</code>可以是根节点），那么<code>u</code>的<code>fail</code>指针指向<code>trie[fail[p],ch]</code></li>
<li>如果<code>Trie[fail[p],ch]</code>不存在：<ul>
<li><code>fail[p]</code>为根节点：那<code>fail</code>指针指向根节点</li>
<li><code>fail[p]</code>不为根节点，递归查找集合<code>Trie[fail[fail[p]],ch]</code></li>
</ul>
</li>
</ol>
<p>其中<code>fail[u]</code>表示<code>u</code>节点的<code>fail</code>指针</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton1.gif" alt="AC_automation_gif_b_3.gif" class="lazyload"></p>
<p>这个例子取自<a target="_blank" rel="noopener" href="https://oi-wiki.org/string/ac-automaton/">AC 自动机 - OI Wiki (oi-wiki.org)</a>，给出了 <code>i</code> <code>he</code> <code>his</code> <code>she</code> <code>hers</code> 组成的字典树构建 fail 指针的过程。下面代码也取自该文。</p>
<h3 id="自动机构建过程"><a href="#自动机构建过程" class="headerlink" title="自动机构建过程"></a>自动机构建过程</h3><p>虽然解释起来很复杂，但是如果对并查集路径压缩、KMP、图论搜索和字典树构造都足够熟悉的话，代码写起来还是相当简洁的。假设我们已经构建完成字典树了，采用的是二维数组的形式便于状态转移以及后续现实工程化的状态压缩（字母表通过掩模+按位获取来压缩内存）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>{<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>    <span class="hljs-keyword">if</span> (tr[<span class="hljs-number">0</span>][i]) q.<span class="hljs-built_in">push</span>(tr[<span class="hljs-number">0</span>][i]);<br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) {<br>    <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {<br>      <span class="hljs-keyword">if</span> (tr[u][i])<br>        fail[tr[u][i]] = tr[fail[u]][i], q.<span class="hljs-built_in">push</span>(tr[u][i]);<br>      <span class="hljs-keyword">else</span><br>        tr[u][i] = tr[fail[u]][i];<br>    }<br>  }<br>}<br></code></pre></td></tr></table></figure>

<p>上述代码通过广度优先搜索层序构造各个节点<code>fail</code>指针，同时进行自动机的构造。我们采用一个<code>fail</code>数组来表示第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>个节点的fail指针。这里有一个和并查集路径压缩类似的做法：如果<code>fail</code>指针在<code>u</code>处失配会多次跳转，那不如一开就走到<code>fail[u]</code>能够转移到的匹配位置，对于字符集中少量不存在的字符可能就直接转移回到原点了，效率很高。</p>
<p><img src="/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton2.gif"></p>
<p>具体的构造过程如图所示，其中：</p>
<ol>
<li>蓝色结点：BFS 遍历到的结点 u</li>
<li>蓝色的边：当前结点下，AC 自动机修改字典树结构连出的边。</li>
<li>黑色的边：AC 自动机修改字典树结构连出的边。</li>
<li>红色的边：当前结点求出的 fail 指针</li>
<li>黄色的边：fail 指针</li>
<li>灰色的边：字典树的边</li>
</ol>
<p>原先的树在经过<code>fail</code>指针构造和自动机构造之后已经变成了<code>DFA</code>图。</p>
<p>读者可能会发现采用数组的方法无法额外添加<code>IsEnd</code>属性，我们可以选择在外部新开一个<code>endWith</code>数组，在插入的时候统计以节点<code>u</code>为末尾的个数，具体可以看下方完整代码。</p>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *t)</span> </span>{<br>  <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; t[i]; i++) {<br>    u = tr[u][t[i] - <span class="hljs-string">'a'</span>];  <span class="hljs-comment">// 转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = u; j &amp;&amp; e[j] != <span class="hljs-number">-1</span>; j = fail[j]) {<br>      res += e[j], e[j] = <span class="hljs-number">-1</span>;<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure>

<p>对于字符串中的每一位进行转移，如果匹配到以当前传为结尾的那匹配次数加上当前结尾次数再清零（如果要多次使用就不必进行这一步，直接记录匹配时的<code>i</code>和对应字符深度一次性将前文清空即可）。</p>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/ac-automaton3.gif" alt="AC_automation_gif_c.gif" class="lazyload"></p>
<ol>
<li>红色结点： 结点</li>
<li>粉色箭头： 在自动机上的跳转，</li>
<li>蓝色的边：成功匹配的模式串</li>
<li>蓝色结点：示跳 fail 指针时的结点（状态）。</li>
</ol>
<h3 id="完整代码C"><a href="#完整代码C" class="headerlink" title="完整代码C++"></a>完整代码C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">namespace</span> AC {<br>    <span class="hljs-type">int</span> tr[N][<span class="hljs-number">26</span>], tot;<br>    <span class="hljs-type">int</span> e[N], fail[N];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> </span>{<br>      <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; s[i]; i++) {<br>        <span class="hljs-keyword">if</span> (!tr[u][s[i] - <span class="hljs-string">'a'</span>]) tr[u][s[i] - <span class="hljs-string">'a'</span>] = ++tot;  <span class="hljs-comment">// 如果没有则插入新节点</span><br>        u = tr[u][s[i] - <span class="hljs-string">'a'</span>];                              <span class="hljs-comment">// 搜索下一个节点</span><br>      }<br>      e[u]++;  <span class="hljs-comment">// 尾为节点 u 的串的个数</span><br>    }<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>{<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>        <span class="hljs-keyword">if</span> (tr[<span class="hljs-number">0</span>][i]) q.<span class="hljs-built_in">push</span>(tr[<span class="hljs-number">0</span>][i]);<br>      <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) {<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {<br>          <span class="hljs-keyword">if</span> (tr[u][i]) {<br>            fail[tr[u][i]] =<br>                tr[fail[u]][i];  <span class="hljs-comment">// fail数组：同一字符可以匹配的其他位置</span><br>            q.<span class="hljs-built_in">push</span>(tr[u][i]);<br>          } <span class="hljs-keyword">else</span><br>            tr[u][i] = tr[fail[u]][i];<br>        }<br>      }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *t)</span> </span>{<br>      <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; t[i]; i++) {<br>        u = tr[u][t[i] - <span class="hljs-string">'a'</span>];  <span class="hljs-comment">// 转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = u; j &amp;&amp; e[j] != <span class="hljs-number">-1</span>; j = fail[j]) {<br>          res += e[j], e[j] = <span class="hljs-number">-1</span>;<br>        }<br>      }<br>      <span class="hljs-keyword">return</span> res;<br>    }<br>} <br></code></pre></td></tr></table></figure>

<h3 id="完整代码Go带测试样例"><a href="#完整代码Go带测试样例" class="headerlink" title="完整代码Go带测试样例"></a>完整代码Go带测试样例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">"fmt"</span><br>	<span class="hljs-string">"strings"</span><br>	<span class="hljs-string">"testing"</span><br>)<br><br><span class="hljs-keyword">const</span> alphabetSize = <span class="hljs-number">26</span><br><br><span class="hljs-keyword">type</span> ACnode <span class="hljs-keyword">struct</span> {<br>	char      <span class="hljs-type">byte</span>      <span class="hljs-comment">// the char hold by a node</span><br>	children  []*ACnode <span class="hljs-comment">//child in a tree struct</span><br>	fail      *ACnode   <span class="hljs-comment">//fail pointer to others</span><br>	acceptLen <span class="hljs-type">int</span>       <span class="hljs-comment">// Accepted status with nonnegative length</span><br>	isRoot    <span class="hljs-type">bool</span>      <span class="hljs-comment">// is root status</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetWordFilter</span><span class="hljs-params">(slist []<span class="hljs-type">string</span>)</span></span> (ret ACnode) {<br>	ret = getRoot()<br>	ret.buildFromWordList(slist)<br>	ret.buildfail()<br>	<span class="hljs-keyword">return</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRoot</span><span class="hljs-params">()</span></span> ACnode {<br>	ori := <span class="hljs-built_in">make</span>([]*ACnode, alphabetSize)<br>	<span class="hljs-keyword">return</span> ACnode{<br>		<span class="hljs-type">byte</span>(<span class="hljs-string">'0'</span>),<br>		ori,<br>		<span class="hljs-literal">nil</span>,<br>		<span class="hljs-number">0</span>,<br>		<span class="hljs-literal">true</span>,<br>	}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *ACnode)</span></span> buildFromWordList(slist []<span class="hljs-type">string</span>) {<br>	<span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> slist {<br>		lword := strings.ToLower(word)<br>		node.insert(lword)<br>	}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(node *ACnode)</span></span> insert(word <span class="hljs-type">string</span>) {<br>	cur := node<br>	<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> word {<br>		<span class="hljs-keyword">if</span> cur.children[ch-<span class="hljs-string">'a'</span>] != <span class="hljs-literal">nil</span> {<br>			cur = cur.children[ch-<span class="hljs-string">'a'</span>]<br>		} <span class="hljs-keyword">else</span> {<br>			tmp := <span class="hljs-built_in">make</span>([](*ACnode), alphabetSize)<br>			node := ACnode{<br>				<span class="hljs-type">byte</span>(ch),<br>				tmp,<br>				<span class="hljs-literal">nil</span>, <span class="hljs-comment">//build later</span><br>				<span class="hljs-number">0</span>,<br>				<span class="hljs-literal">false</span>,<br>			}<br>			cur.children[ch-<span class="hljs-string">'a'</span>] = &amp;node<br>			cur = cur.children[ch-<span class="hljs-string">'a'</span>]<br>		}<br>		<span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(word)<span class="hljs-number">-1</span> &amp;&amp; cur.acceptLen == <span class="hljs-number">0</span> {<br>			cur.acceptLen = i + <span class="hljs-number">1</span><br>		}<br>	}<br>}<br><br><span class="hljs-comment">// BFS construct the AC automaton</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *ACnode)</span></span> buildfail() {<br>	root.fail = root<br>	q := <span class="hljs-built_in">make</span>([]*ACnode, <span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; alphabetSize; i++ {<br>		<span class="hljs-keyword">if</span> root.children[i] != <span class="hljs-literal">nil</span> {<br>			q = <span class="hljs-built_in">append</span>(q, root.children[i])<br>			root.children[i].fail = root<br>		} <span class="hljs-keyword">else</span> {<br>			root.children[i] = root<br>		}<br>	}<br>	<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> {<br>		u := q[<span class="hljs-number">0</span>]<br>		q = q[<span class="hljs-number">1</span>:]<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; alphabetSize; i++ {<br>			<span class="hljs-keyword">if</span> u.children[i] != <span class="hljs-literal">nil</span> {<br>				u.children[i].fail = u.fail.children[i]<br>				q = <span class="hljs-built_in">append</span>(q, u.children[i])<br>			} <span class="hljs-keyword">else</span> {<br>				u.children[i] = u.fail.children[i]<br>			}<br>		}<br>	}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *ACnode)</span></span> MaskText(text <span class="hljs-type">string</span>, mask <span class="hljs-type">byte</span>) (ret []<span class="hljs-type">byte</span>) {<br>	ret = []<span class="hljs-type">byte</span>(text)<br>	text = strings.ToLower(text)<br>	cur := root<br>	<span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> text {<br>		cur = cur.children[ch-<span class="hljs-string">'a'</span>]<br>		j := cur<br>		<span class="hljs-keyword">for</span> !j.isRoot {<br>			<span class="hljs-keyword">if</span> j.acceptLen &gt; <span class="hljs-number">0</span> {<br>				maskSingleWord(ret, i-j.acceptLen+<span class="hljs-number">1</span>, j.acceptLen, mask)<br>			}<br>			j = j.fail<br>		}<br>	}<br>	<span class="hljs-keyword">return</span><br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maskSingleWord</span><span class="hljs-params">(target []<span class="hljs-type">byte</span>, start <span class="hljs-type">int</span>, l <span class="hljs-type">int</span>, mask <span class="hljs-type">byte</span>)</span></span> {<br>	<span class="hljs-keyword">if</span> start &lt; <span class="hljs-number">0</span> {<br>		<span class="hljs-keyword">return</span><br>	}<br>	<span class="hljs-keyword">for</span> i := start; i &lt; start+l &amp;&amp; i &lt; <span class="hljs-built_in">len</span>(target); i++ {<br>		target[i] = mask<br>	}<br>}<br><br><span class="hljs-comment">// used as a Trie tree, check if a word in the built tree</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *ACnode)</span></span> IsInIndex(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> {<br>	cur := root<br>	<span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word {<br>		<span class="hljs-keyword">if</span> cur.children[ch-<span class="hljs-string">'a'</span>].isRoot {<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		}<br>		cur = cur.children[ch-<span class="hljs-string">'a'</span>]<br>	}<br>	<span class="hljs-keyword">return</span> cur.acceptLen &gt; <span class="hljs-number">0</span><br>}<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	ouput: "dadfsef*****asdfew***asef**r"</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_AC</span><span class="hljs-params">(t *testing.T)</span></span> {<br>	wordlist := []<span class="hljs-type">string</span>{<span class="hljs-string">"i"</span>, <span class="hljs-string">"she"</span>, <span class="hljs-string">"his"</span>, <span class="hljs-string">"hers"</span>, <span class="hljs-string">"he"</span>}<br>	filter := GetWordFilter(wordlist)<br>	<span class="hljs-comment">//fmt.Print(filter.IsInIndex("rhe"))</span><br>	fmt.Println(<span class="hljs-type">string</span>(filter.MaskText(<span class="hljs-string">"dadfsefsheheasdfewhisasefher"</span>, <span class="hljs-string">'*'</span>)))<br>}<br></code></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这三个算法除了字典树很多时候确实没啥大用处（被哈希吊打）以外，另外两个都有各自的典型使用场景，比如unix系统中需要把多个文件名文件筛选出来就会用到AC自动机，vim里面替换所有文本的<code>%s/x/y</code>命令就会使用<code>KMP</code>（我猜的）。就连确实很废的字典树都可以很适合用来实现<code>Web</code>框架中的一部分路由匹配任务。</p>
<p>能够理解上面的算法对于业务还是很有帮助的（显然AC自动机我肯定是直接抄或者找库，不打比赛能够默写出来也就我刚写完博客这几天），业务中能够用到的高级算法并不只是字典树而已。</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Kiman Yang<br>
        <strong>本文链接：</strong><a href="https://kimanyang.xyz/2022/04/15/%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" title="https:&#x2F;&#x2F;kimanyang.xyz&#x2F;2022&#x2F;04&#x2F;15&#x2F;%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;kimanyang.xyz&#x2F;2022&#x2F;04&#x2F;15&#x2F;%E6%95%8F%E6%84%9F%E8%AF%8D%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94KMP%E3%80%81Trie%E5%AD%97%E5%85%B8%E6%A0%91%E5%88%B0AC%E8%87%AA%E5%8A%A8%E6%9C%BA&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC自动机</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/C/" rel="tag">C++</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Golang/" rel="tag">Golang</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/KMP/" rel="tag">KMP</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Trie%E5%AD%97%E5%85%B8%E6%A0%91/" rel="tag">Trie字典树</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">刷题总结</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/" rel="tag">路径压缩</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1650450827419"></script>


	<script async src="/js/search.js?v=1650450827419"></script>


<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":240,"height":480},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
