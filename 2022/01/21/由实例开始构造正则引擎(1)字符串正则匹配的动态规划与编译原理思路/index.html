<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>(一)字符串正则匹配的动态规划与编译原理思路 - Brief Candle</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="字符串正则匹配的动态规划与编译原理思路题目引入下面两道力扣题目分别代表了两种不同类型的状态机，第一种是正则表达式到$NFA$到$DFA$的转换，第二种是正则表达式到$\epsilon-NFA$到$DFA$的转换，选取这两道可以对状态机的设计有更深刻的认识（面试必不会考但是自己写正则引擎总得会一点）。 10.正则表达式匹配（hard)给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’">
<meta property="og:type" content="article">
<meta property="og:title" content="(一)字符串正则匹配的动态规划与编译原理思路">
<meta property="og:url" content="https://kimanyang.xyz/2022/01/21/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(1)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF/index.html">
<meta property="og:site_name" content="Brief Candle">
<meta property="og:description" content="字符串正则匹配的动态规划与编译原理思路题目引入下面两道力扣题目分别代表了两种不同类型的状态机，第一种是正则表达式到$NFA$到$DFA$的转换，第二种是正则表达式到$\epsilon-NFA$到$DFA$的转换，选取这两道可以对状态机的设计有更深刻的认识（面试必不会考但是自己写正则引擎总得会一点）。 10.正则表达式匹配（hard)给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-21T13:08:34.000Z">
<meta property="article:modified_time" content="2022-03-10T15:29:33.252Z">
<meta property="article:author" content="Kiman Yang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Golang">
<meta property="article:tag" content="编译原理">
<meta property="article:tag" content="正则表达式">
<meta property="article:tag" content="刷题总结">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1647310810015">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1647310810015">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1647310810015">
    <link rel="stylesheet" href="/css/style.css?v=1647310810015">
    
        <link rel="stylesheet" href="/css/dark.css?v=1647310810015">
     
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(/images/yuanxiang.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Kiman Yang" class="mdui-btn mdui-btn-icon"><img src="/images/aqua.png" alt="Kiman Yang"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Kiman Yang">
            <img src="/images/aqua.png" alt="Kiman Yang" alt="Kiman Yang">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>27</div>
        <div><span>标签</span>54</div>
        <div><span>分类</span>6</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/Youngkingman" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/401742377" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/Youngkingman" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CSS/">CSS</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Golang学习/">Golang学习</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Javascript/">Javascript</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/控制理论/">控制理论</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/由实例开始构造正则引擎/">由实例开始构造正则引擎</a>
          <span class="category-list-count">2</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/BitSet/" style="font-size: 10px;">BitSet</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/" style="font-size: 10px;">CSS 溢出显示</a> <a href="/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 10px;">CSS3新特性</a> <a href="/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/" style="font-size: 10px;">CSS三角与精灵图</a> <a href="/tags/CSS%E5%B8%83%E5%B1%80/" style="font-size: 12px;">CSS布局</a> <a href="/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">CSS浮动与定位</a> <a href="/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">CSS盒模型</a> <a href="/tags/CSS%E8%BF%87%E6%B8%A1/" style="font-size: 10px;">CSS过渡</a> <a href="/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/" style="font-size: 10px;">CSS选择器</a> <a href="/tags/DOM%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">DOM事件</a> <a href="/tags/DOM%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">DOM模型</a> <a href="/tags/GMP%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">GMP模型</a> <a href="/tags/Golang/" style="font-size: 18px;">Golang</a> <a href="/tags/H5%E6%A0%87%E7%AD%BE/" style="font-size: 10px;">H5标签</a> <a href="/tags/Javascript/" style="font-size: 12px;">Javascript</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/LFU/" style="font-size: 10px;">LFU</a> <a href="/tags/LRU/" style="font-size: 10px;">LRU</a> <a href="/tags/Rabin-Karp/" style="font-size: 10px;">Rabin-Karp</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/STL%E5%AE%B9%E5%99%A8/" style="font-size: 12px;">STL容器</a> <a href="/tags/Tcmalloc/" style="font-size: 10px;">Tcmalloc</a> <a href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">lambda表达式</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 10px;">一致性</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">事件流模型</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 10px;">二分法</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 14px;">八股文</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">内存模型</a> <a href="/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 12px;">刷题总结</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/" style="font-size: 10px;">前端经典案例</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 12px;">动态规划</a> <a href="/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">哈希算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">堆排序</a> <a href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 10px;">多智能体</a> <a href="/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/" style="font-size: 10px;">多路归并</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">控制系统设计</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 14px;">数据结构与算法</a> <a href="/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/" style="font-size: 10px;">机械臂</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 16px;">正则表达式</a> <a href="/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/" style="font-size: 10px;">状态机DP</a> <a href="/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 10px;">矩阵快速幂</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 12px;">编译原理</a> <a href="/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">自治系统</a> <a href="/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/" style="font-size: 12px;">自适应控制</a> <a href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/" style="font-size: 16px;">非线性控制</a> <a href="/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">非自治系统</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">页面事件</a>
    </div>
    
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Kiman Yang
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 77.16666666666666%;"> 
              <img data-src="/cover/yuanxiangcover5.jpg" data-sizes="auto" alt="(一)字符串正则匹配的动态规划与编译原理思路" class="lazyload">
              <h1>(一)字符串正则匹配的动态规划与编译原理思路</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年01月21日</a>
</div>

      

      <h1 id="字符串正则匹配的动态规划与编译原理思路"><a href="#字符串正则匹配的动态规划与编译原理思路" class="headerlink" title="字符串正则匹配的动态规划与编译原理思路"></a>字符串正则匹配的动态规划与编译原理思路</h1><h2 id="题目引入"><a href="#题目引入" class="headerlink" title="题目引入"></a>题目引入</h2><p>下面两道力扣题目分别代表了两种不同类型的状态机，第一种是正则表达式到$NFA$到$DFA$的转换，第二种是正则表达式到$\epsilon-NFA$到$DFA$的转换，选取这两道可以对状态机的设计有更深刻的认识（面试必不会考但是自己写正则引擎总得会一点）。</p>
<h3 id="10-正则表达式匹配（hard"><a href="#10-正则表达式匹配（hard" class="headerlink" title="10.正则表达式匹配（hard)"></a>10.正则表达式匹配（hard)</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li><code>.</code>匹配任意单个字符</li>
<li><code>*</code>匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<h3 id="44-通配符匹配-hard"><a href="#44-通配符匹配-hard" class="headerlink" title="44.通配符匹配(hard)"></a>44.通配符匹配(hard)</h3><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 <code>?</code> 和 <code>*</code> 的通配符匹配。</p>
<ul>
<li><code>?</code> 可以匹配任何单个字符。</li>
<li><code>*</code> 可以匹配任意字符串（包括空字符串）。</li>
</ul>
<p>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和<code>*</code>。</li>
</ul>
<h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><h3 id="10-正则表达式匹配（hard-1"><a href="#10-正则表达式匹配（hard-1" class="headerlink" title="10.正则表达式匹配（hard)"></a>10.正则表达式匹配（hard)</h3><p>字符串匹配问题通常都可以看成是二维动态规划问题，类似的题型包括子序列匹配之类的。用$dp[i][j]$表示$s$中前$i$个字符能否和$p$中前$j$个字符匹配。在进行状态转移时，考虑$p$的第$j$个字符匹配情况：</p>
<ul>
<li><p>如果$p$的第$j$个字符是一个小写字母，那么我们必须在$s$中匹配一个相同的小写字母，即：<br>$$<br>dp[i][j]&#x3D;<br>\left{<br>\begin{aligned}<br>&amp;dp[i-1][j-1],&amp;s[i]&#x3D;p[j] \<br>&amp;false,&amp;s[i]\ne p[j]<br>\end{aligned}<br>\right.<br>\notag<br>$$<br>如果$p$的第$i$个字符与$p$的第$j$个字符不相同，那么无法进行匹配；否则我们可以匹配两个字符串的最后一个字符，</p>
</li>
<li><p>如果$p$的第$j$个字符是$*$，那么可以对$p$的第$j-1$个字符进行0到任意次数匹配。进一步想，字母与星号的组合在匹配过程中只会出现两种情况：</p>
<ul>
<li>匹配$s$最末字符，使用该组合继续匹配</li>
<li>不进行匹配，丢弃该组合</li>
</ul>
<p>由此可以写出模式串为$*$时的如下的状态转移方程：<br>$$<br>dp[i][j]&#x3D;<br>\left{<br>\begin{aligned}<br>&amp;dp[i-1][j]\or dp[i][j-2],&amp;s[i]&#x3D;p[j-1] \<br>&amp;dp[i][j-2],&amp;s[i]\ne p[j-1]<br>\end{aligned}<br>\right.<br>\notag<br>$$</p>
</li>
<li><p>最后只要遇到是$.$则可以成功匹配</p>
</li>
</ul>
<p>总结上述的三点可以获得如下的状态转移方程：<br>$$<br>dp[i][j]&#x3D;<br>\left{<br>\begin{aligned}<br>&amp;p[j]\ne ‘*’&#x3D;<br>\left{\begin{aligned}<br>&amp;dp[i-1][j-1],&amp;match(s[i-1],p[j-1])\<br>&amp;false,    &amp;otherwise<br>\end{aligned}\right.\<br>&amp;otherwise&#x3D;<br>\left{\begin{aligned}<br>&amp;dp[i-1][j]\or dp[i][j-2],&amp;matches(s[i-1],p[j-2]) \<br>&amp;dp[i][j-2],&amp;otherwise<br>\end{aligned}\right.<br>\end{aligned}<br>\right.<br>\notag<br>$$<br>其中$match(x,y)$判断二者是否匹配，只有$y$是<code>.</code>或者$x&#x3D;y$时两个字符匹配。</p>
<p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), n = p.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> match = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> s[i<span class="hljs-number">-1</span>]=p[j<span class="hljs-number">-1</span>];<br>        &#125;;<br>        <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>    	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= m;++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;++j) &#123;<br>                <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    dp[i][j] |= dp[i][j<span class="hljs-number">-2</span>];<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">matches</span>(i,j<span class="hljs-number">-1</span>)) &#123;<br>                        dp[i][j] |= dp[i<span class="hljs-number">-1</span>][j];<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">matches</span>(i,j)) &#123;<br>                        dp[i][j] |= dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="44-通配符匹配-hard-1"><a href="#44-通配符匹配-hard-1" class="headerlink" title="44.通配符匹配(hard)"></a>44.通配符匹配(hard)</h3><p>模仿上述题目，我们分析题目要求的状态转移方程：</p>
<p>用$dp[i][j]$表示$s$中前$i$个字符能否和$p$中前$j$个字符匹配。</p>
<p>当$s[i-1]$和$p[j-1]$匹配且$p[j-1]$不为通配符时，$dp[i][j]$能否成功匹配取决于$dp[i-1][j-1]$能否成功匹配。</p>
<p>当$p[j-1]$为通配符<code>*</code>时</p>
<ul>
<li>要么和$s$末尾匹配，取决于$dp[i-1][j-1]$是否成功匹配</li>
<li>要么不匹配，取决于$dp[i-1][j]$是否成功匹配</li>
<li>如果$dp[i][j-1]$能匹配，那带<code>*</code>的$dp[i][j]$也能继续匹配</li>
</ul>
<p>边界条件$dp[0][0]&#x3D;true$写出状态转移方程：<br>$$<br>dp[i][j]&#x3D;<br>\left{\begin{aligned}<br>&amp;p[j-1]\ne’<em>‘,s[i-1]\Leftrightarrow p[j-1]\implies dp[i][j]&#x3D;dp[i-1][j-1] \<br>&amp;p[j-1]&#x3D;’</em>‘\implies dp[i][j]&#x3D;dp[i][j-1]||dp[i-1][j]||dp[i][j-1]<br>\end{aligned}\right.<br>\notag<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>(), n = p.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n + <span class="hljs-number">1</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= m;++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;++j) &#123;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                   dp[i][j] = dp[i][j] || dp[i][j<span class="hljs-number">-1</span>];<br>                   <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) dp[i][j] = dp[i][j] || dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                   <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) dp[i][j] = dp[i][j] || dp[i<span class="hljs-number">-1</span>][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="非确定有限状态自动机解法"><a href="#非确定有限状态自动机解法" class="headerlink" title="非确定有限状态自动机解法"></a>非确定有限状态自动机解法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">/*用于构造NFA图的节点结构*/</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>	C        <span class="hljs-type">byte</span>             <span class="hljs-comment">//当前节点接受的字符</span><br>	Parent   *Node            <span class="hljs-comment">//正向生成时的母节点，用于生成自由长度0节点的可跨越边</span><br>	Children <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>][]*Node <span class="hljs-comment">//子节点个数，一个字节可以对应多个索引（NFA）</span><br>	End      <span class="hljs-type">bool</span>             <span class="hljs-comment">//是否为终止节点</span><br>	Size     <span class="hljs-type">int</span>              <span class="hljs-comment">//节点长度，如果携带的是*则长度为0，否则为1（只能匹配一个）</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	核心功能实现，递归生成NFA</span><br><span class="hljs-comment">	函数签名：</span><br><span class="hljs-comment">	@param: now 当前要递归生成的节点的根</span><br><span class="hljs-comment">  	@param: str 模式串，递归中无修改</span><br><span class="hljs-comment">	@param: idx	当前匹配的坐标,是now要生成节点对应的字符</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generatePattern</span><span class="hljs-params">(now *Node, str <span class="hljs-type">string</span>, idx <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-comment">//到达当前末尾</span><br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str) &lt;= idx &#123;<br>		now.End = <span class="hljs-literal">true</span><br>		<span class="hljs-keyword">return</span> now.Size<br>	&#125;<br>	vnow := now <span class="hljs-comment">//用于下一次更新的节点</span><br>	<span class="hljs-keyword">switch</span> str[idx] &#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>		now.Size = <span class="hljs-number">0</span>              <span class="hljs-comment">//无限匹配自由长度为0</span><br>		now.addVertex(now.C, now) <span class="hljs-comment">//自己可以接受自己</span><br>	<span class="hljs-keyword">default</span>:<br>		node := <span class="hljs-built_in">new</span>(Node) <span class="hljs-comment">//创建下一字符节点</span><br>		node.C = str[idx]<br>		now.addVertex(str[idx], node) <span class="hljs-comment">//当前字符节点后继添加</span><br>		node.Parent = now             <span class="hljs-comment">//当前节点父节点设为node</span><br>		node.Size = <span class="hljs-number">1</span>                 <span class="hljs-comment">//节点自由长度为1</span><br>		vnow = node                   <span class="hljs-comment">//当前节点可以更新为新的节点</span><br>	&#125;<br>	<span class="hljs-comment">//如果是*则不用创建新节点</span><br>	ret := generatePattern(vnow, str, idx+<span class="hljs-number">1</span>)<br>	<span class="hljs-comment">//后续已无节点（或者只有x*匹配),则当前节点也可作为终止态</span><br>	<span class="hljs-keyword">if</span> ret == <span class="hljs-number">0</span> &#123;<br>		now.End = <span class="hljs-literal">true</span><br>	&#125;<br>	<span class="hljs-comment">//给当前的后继节点配野爹</span><br>	addParent := now<br>	<span class="hljs-keyword">for</span> addParent.Parent != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-comment">//对于正常节点,vnow是我的后继，如果当前节点的长度为零，那我的后继也是我父母节点的后继</span><br>		<span class="hljs-keyword">if</span> addParent.Size == <span class="hljs-number">0</span> &#123;<br>			<span class="hljs-comment">//debug(toString(vnow), &quot; -&gt; &quot;, toString(addParent.Parent))</span><br>			addParent.Parent.addVertex(vnow.C, vnow) <span class="hljs-comment">//父母添加一条到我后继节点的边</span><br>			addParent = addParent.Parent             <span class="hljs-comment">//递归匹配到</span><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> now.Size + ret<br>&#125;<br><br><span class="hljs-comment">/*为节点n添加一条经由c到达child的边，回溯时会进行新的创建*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *Node)</span></span> addVertex(c <span class="hljs-type">byte</span>, child *Node) &#123;<br>	m := n.Children<br>	<span class="hljs-comment">//没有后继列表就创建一个</span><br>	<span class="hljs-keyword">if</span> m == <span class="hljs-literal">nil</span> &#123;<br>		m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>][]*Node)<br>		n.Children = m<br>	&#125;<br>	list := m[c]<br>	<span class="hljs-comment">//当前字符不存在就创建一个</span><br>	<span class="hljs-keyword">if</span> list == <span class="hljs-literal">nil</span> &#123;<br>		list = <span class="hljs-built_in">make</span>([]*Node, <span class="hljs-number">0</span>)<br>	&#125;<br>	<span class="hljs-comment">//遍历当前的可达状态，如果存在目标状态则退出</span><br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br>		<span class="hljs-keyword">if</span> v == child &#123;<br>			m[c] = list<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//状态不存在，更新列表</span><br>	list = <span class="hljs-built_in">append</span>(list, child)<br>	m[c] = list<br>&#125;<br><br><span class="hljs-comment">//递归检查是否能够匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(now *Node, str <span class="hljs-type">string</span>, idx <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str) &lt;= idx &#123;<br>		<span class="hljs-keyword">return</span> now.End<br>	&#125;<br>	list := now.Children[<span class="hljs-string">&#x27;.&#x27;</span>]<br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> now.Children[str[idx]] &#123;<br>		list = <span class="hljs-built_in">append</span>(list, v)<br>	&#125;<br>	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br>		r := check(v, str, idx+<span class="hljs-number">1</span>)<br>		<span class="hljs-keyword">if</span> r &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">//使用示例，判断s是否能被接受</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	begin := <span class="hljs-built_in">new</span>(Node) <span class="hljs-comment">//创建start节点</span><br>	begin.C = <span class="hljs-string">&#x27;&gt;&#x27;</span><br>	begin.Size = generatePattern(begin, p, <span class="hljs-number">0</span>) <span class="hljs-comment">//递归构造模式串有穷状态自动机</span><br>	<span class="hljs-keyword">return</span> check(begin, s, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所构造的$NFA$图片：</p>
<p>状态机分别为<code>c*..b*a*a.*a..*c</code>和<code>mis*is*</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>  id0xc4200809c0((&gt;));<br>  id0xc4200809f0((c));<br>  id0xc4200809f0 -- c --&gt; id0xc4200809f0;<br>  id0xc420080a80((.));<br>  id0xc420080ab0((.));<br>  id0xc420080b10((b));<br>  id0xc420080b10 -- b --&gt; id0xc420080b10;<br>  id0xc420080ba0((a));<br>  id0xc420080ba0 -- a --&gt; id0xc420080ba0;<br>  id0xc420080c00((a));<br>  id0xc420080c30((.));<br>  id0xc420080c30 -- . --&gt; id0xc420080c30;<br>  id0xc420080cc0((a));<br>  id0xc420080cf0((.));<br>  id0xc420080d50((.));<br>  id0xc420080d50 -- . --&gt; id0xc420080d50;<br>  id0xc420080de0&#123;c&#125;;<br>  id0xc420080d50 -- c --&gt; id0xc420080de0;<br>  id0xc420080cf0 -- . --&gt; id0xc420080d50;<br>  id0xc420080cf0 -- c --&gt; id0xc420080de0;<br>  id0xc420080cc0 -- . --&gt; id0xc420080cf0;<br>  id0xc420080c30 -- a --&gt; id0xc420080cc0;<br>  id0xc420080c00 -- . --&gt; id0xc420080c30;<br>  id0xc420080c00 -- a --&gt; id0xc420080cc0;<br>  id0xc420080ba0 -- a --&gt; id0xc420080c00;<br>  id0xc420080b10 -- a --&gt; id0xc420080ba0;<br>  id0xc420080b10 -- a --&gt; id0xc420080c00;<br>  id0xc420080ab0 -- b --&gt; id0xc420080b10;<br>  id0xc420080ab0 -- a --&gt; id0xc420080c00;<br>  id0xc420080ab0 -- a --&gt; id0xc420080ba0;<br>  id0xc420080a80 -- . --&gt; id0xc420080ab0;<br>  id0xc4200809f0 -- . --&gt; id0xc420080a80;<br>  id0xc4200809c0 -- c --&gt; id0xc4200809f0;<br>  id0xc4200809c0 -- . --&gt; id0xc420080a80;<br><br>  id0xc420080780((&gt;));<br>  id0xc4200807b0((m));<br>  id0xc420080810((i));<br>  id0xc420080870((s));<br>  id0xc420080870 -- s --&gt; id0xc420080870;<br>  id0xc420080900&#123;i&#125;;<br>  id0xc420080930&#123;s&#125;;<br>  id0xc420080930 -- s --&gt; id0xc420080930;<br>  id0xc420080900 -- s --&gt; id0xc420080930;<br>  id0xc420080870 -- i --&gt; id0xc420080900;<br>  id0xc420080810 -- s --&gt; id0xc420080870;<br>  id0xc420080810 -- i --&gt; id0xc420080900;<br>  id0xc4200807b0 -- i --&gt; id0xc420080810;<br>  id0xc420080780 -- m --&gt; id0xc4200807b0;<br></code></pre></td></tr></table></figure>

<p>上述Go代码的C++版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NFAnode</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">char</span> ch;<br>        NFAnode* parent;<br>        unordered_map&lt;<span class="hljs-type">char</span>,vector&lt;NFAnode*&gt;&gt; children;<br>        <span class="hljs-type">bool</span> isEnd;<br>        <span class="hljs-type">int</span> size;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addVertex</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, NFAnode* child)</span> </span>&#123;<br>            <span class="hljs-keyword">auto</span>&amp; m = <span class="hljs-keyword">this</span>-&gt;children;<br>            <span class="hljs-keyword">auto</span>&amp; list = m[ch];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v:list) &#123;<br>                <span class="hljs-keyword">if</span>(v == child) &#123;<br>                    m[ch] = list;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            list.<span class="hljs-built_in">push_back</span>(child);<br>            m[ch] = list;<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        NFAnode* begin = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NFAnode</span>();<br>        begin-&gt;ch = <span class="hljs-string">&#x27;@&#x27;</span>;<br>        begin-&gt;size = <span class="hljs-built_in">genneratePatern</span>(begin,p,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">checkHelper</span>(begin,s,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">genneratePatern</span><span class="hljs-params">(NFAnode* now, string str,<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">length</span>() &lt;= idx) &#123;<br>            now-&gt;isEnd = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> now-&gt;size;<br>        &#125;<br>        NFAnode* vnow = now;<br>        <span class="hljs-keyword">if</span>(str[idx] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            now-&gt;size = <span class="hljs-number">0</span>;<br>            now-&gt;<span class="hljs-built_in">addVertex</span>(now-&gt;ch,now);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NFAnode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NFAnode</span>();<br>            node-&gt;ch = str[idx];<br>            now-&gt;<span class="hljs-built_in">addVertex</span>(str[idx],node);<br>            node-&gt;parent = now;<br>            node-&gt;size = <span class="hljs-number">1</span>;<br>            vnow = node;<br>        &#125;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">genneratePatern</span>(vnow, str, idx + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>            now-&gt;isEnd = <span class="hljs-literal">true</span>;<br>        &#125;<br>        NFAnode* addParent = now;<br>        <span class="hljs-keyword">while</span>(addParent-&gt;parent != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(addParent-&gt;size == <span class="hljs-number">0</span>) &#123;<br>                addParent-&gt;parent-&gt;<span class="hljs-built_in">addVertex</span>(vnow-&gt;ch,vnow);<br>                addParent = addParent-&gt;parent;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> now-&gt;size + ret;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkHelper</span><span class="hljs-params">(NFAnode* now, string str, <span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">length</span>() &lt;= idx) &#123;<br>            <span class="hljs-keyword">return</span> now-&gt;isEnd;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> list = now-&gt;children[<span class="hljs-string">&#x27;.&#x27;</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v:now-&gt;children[str[idx]]) &#123;<br>            list.<span class="hljs-built_in">push_back</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v:list) &#123;<br>            <span class="hljs-type">bool</span> r = <span class="hljs-built_in">checkHelper</span>(v,str,idx+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(r) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>读者们如果无法理解代码也没有关系，下一篇文章会详细讨论递归下降构造词法树到最终进行状态机匹配的过程。</p>
<h2 id="从正则到-epsilon-NFA-或者-NFA-到-DFA-转换"><a href="#从正则到-epsilon-NFA-或者-NFA-到-DFA-转换" class="headerlink" title="从正则到$\epsilon-NFA$或者$NFA$到$DFA$转换"></a>从正则到$\epsilon-NFA$或者$NFA$到$DFA$转换</h2><p>罗列知识可能比较难以理解，我们先直观地从简单的题目开始一步一步展示算法实现的过程。</p>
<h3 id="状态机经典题目——65-有效数字"><a href="#状态机经典题目——65-有效数字" class="headerlink" title="状态机经典题目——65.有效数字"></a>状态机经典题目——65.有效数字</h3><p>有效数字（按顺序）可以分成以下几个部分：</p>
<ol>
<li>一个 小数 或者 整数</li>
<li>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</li>
</ol>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p>
</li>
<li><p>下述格式之一：</p>
<ol>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（’+’ 或 ‘-‘）</li>
<li>至少一位数字</li>
</ol>
<p>给定一个字符串$s$，判断是否为有效数字字符串。</p>
<h3 id="正则表达式解法："><a href="#正则表达式解法：" class="headerlink" title="正则表达式解法："></a>正则表达式解法：</h3><p>显然问题可以直接由正则表达式解决，首先将规则构造为正则表达式也有利于我们进一步的状态机分析。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> regex <span class="hljs-title">Solution::pattern</span><span class="hljs-params">(<span class="hljs-string">&quot;[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[Ee][+-]?\\d+)?&quot;</span>)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> regex pattern;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">regex_match</span>(str, pattern);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>分析上述的表达式：</p>
<ul>
<li>一个整数的正则表达：<code>[+-]?\\d+</code></li>
<li>一个小数的正则表达:<code>[+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+))</code></li>
<li>组合起来再带上可选的<code>e</code>和<code>E</code>:<code>(小数|整数)[eE]整数</code></li>
</ul>
<p>展开来便是<code>([+-]?\\d+)|([+-]?((\\d+\\.)|(\\d+\\.\\d+)|(\\.\\d+)))([eE][+-]?)\\d+</code></p>
<p>需要注意C++的字符串中添加双斜杠<code>\\</code>是为了转义第二个斜杠，实际内存中还是一个<code>\</code>，即<code>\\d</code>表示标准正则语法中的<code>\d</code>。（两层套娃）</p>
<p>正则化简从$DFA$化简的角度理解会更容易一些，也可以给出一些普适的结合律交换律来化简。这里先给出上述正则的简化表达，这也是一部分题解中给出的正则表达式：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">([+-]?(\\d+(\\.\\d*)?|(\\.\\d+)))([eE][+-]?\\d+)?<br></code></pre></td></tr></table></figure>

<h3 id="从正则到-epsilon-NFA"><a href="#从正则到-epsilon-NFA" class="headerlink" title="从正则到$\epsilon-NFA$"></a>从正则到$\epsilon-NFA$</h3><p>我们将上述抽象的正则表达式一步一步转换为状态机模型，这里的算法被称为Thompson算法。</p>
<p>首先我们确定正则表达式中的字符集，对于我们要进行解析的这个正则表达式来说，字符集为<code>[+-.deE]</code>。</p>
<p>其次我们分析正则表达式中的构造方法，并将其对应到$\epsilon-NFA$中。五种构造方法分别为：</p>
<ol>
<li><p>字符集接受，即一个规则集合，比如<code>[+-]</code>和小括号内的所有内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>en&#123;end&#125;;<br>st -- 字符集 --&gt; en;<br></code></pre></td></tr></table></figure>
</li>
<li><p>规则的串联，即正则表达式中两个规则直接链接构造的新规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st1((start));<br>en1&#123;end&#125;;<br>st2((start));<br>en2&#123;end&#125;;<br>st1 -- 字符集1 --&gt; en1;<br>en1 -- 空边 --&gt; st2;<br>st2 -- 字符集2 --&gt; en2;<br></code></pre></td></tr></table></figure>
</li>
<li><p>规则的并联，即正则表达式中两个或以上规则以<code>|</code>链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>en&#123;end&#125;;<br>st1((start));<br>en1&#123;end&#125;;<br>st2((start));<br>en2&#123;end&#125;;<br>st3((start));<br>en3&#123;end&#125;;<br>st -- 空边 --&gt; st1;<br>st -- 空边 --&gt; st2;<br>st -- 空边 --&gt; st3;<br>st1 --字符集1 --&gt;en1;<br>st2 --字符集2 --&gt;en2;<br>st3 --字符集3 --&gt;en3;<br>en1 --空边--&gt;en;<br>en2 --空边--&gt;en;<br>en3 --空边--&gt;en;<br></code></pre></td></tr></table></figure>
</li>
<li><p>规则的重复（1次及以上），即正则表达式中的<code>X+</code>一个或以上匹配，为了后续分析方便采用复制状态的表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>en&#123;end&#125;;<br>st1((start));<br>en1&#123;end&#125;;<br>st --子状态1--&gt; en;<br>en --空边--&gt; st1;<br>st1 --子状态1--&gt; en1;<br>en1 --空边--&gt;en;<br></code></pre></td></tr></table></figure>
</li>
<li><p>规则的可选，即正则表达式中的<code>X?</code>,只需要将起始状态和终止状态相连接。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>en&#123;end&#125;;<br>st --子状态--&gt; en;<br>st --空边 --&gt;en;<br></code></pre></td></tr></table></figure>

<p>对于4的特殊情况<code>X*</code>匹配零次及以上，则直接令<code>end</code>同时拥有起始和终止两个状态即可。至此我们根据已有的知识构造题目正则表达式所对应的$\epsilon-NFA$，空边用null表示则有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>st1((state1));<br>st2((state2));<br>st3((state3));<br>st4((state4));<br>st5((state5));<br>st6((state6));<br>st7((state7));<br>st8((state8));<br>st9((state9));<br>st10((state10));<br>st11((state11));<br>st12((state12));<br>en&#123;end&#125;;<br>st -- +- --&gt; st1;<br>st --null --&gt;st1;<br>st1 -- null --&gt;st2;<br>st1 -- null --&gt;st6;<br>st2 -- digit --&gt;st3;<br>st3 -- digit --&gt;st3;<br>st3 -- . --&gt; st4;<br>st3 -- null --&gt;st5;<br>st4 -- digit --&gt; st5;<br>st4 -- null --&gt;st5;<br>st5 -- digit --&gt;st5;<br>st5 -- null --&gt;st9;<br>st6 -- . --&gt; st7;<br>st7 -- digit --&gt; st8;<br>st8 -- digit --&gt;st8;<br>st8 -- null --&gt;st9;<br>st9 -- eE --&gt;st10;<br>st9 -- null --&gt;en;<br>st10 -- +- --&gt;st11;<br>st10 -- null --&gt; st11;<br>st11 -- digit --&gt;st12;<br>st12 -- digit --&gt;st12;<br>st12 -- null --&gt; en;<br></code></pre></td></tr></table></figure>

<p>出于展示简便没有完全按照上述的形式得出上图展示的$\epsilon-NFA$的模型，做了一些较为直观的冗余空边化简。</p>
<h3 id="epsilon-NFA-的非确定性消除"><a href="#epsilon-NFA-的非确定性消除" class="headerlink" title="$\epsilon-NFA$的非确定性消除"></a>$\epsilon-NFA$的非确定性消除</h3><p>非确定性的消除主要有两点：1.消除空边 2. 将$NFA$转换为$DFA$。</p>
<h4 id="消除空边"><a href="#消除空边" class="headerlink" title="消除空边"></a>消除空边</h4><p>不作证明地给出以下的算法过程：</p>
<ol>
<li><p><em>找到所有的有效状态</em></p>
<p>有效状态指<strong>存在非$\epsilon$(空)边输入的状态</strong>。同时起始状态也是有效状态，另外如果一个状态可以通过空边到达结束状态，那么该状态也应该变成结束状态。在我们的例子中，有效状态有状态1、状态3、状态7、状态4、状态8、状态5、状态10、状态11和状态12。状态5、8和12应该被标记为结束状态。</p>
</li>
<li><p><em>添加必要的边</em></p>
<p>这一步为核心算法。我们针对每一个有效状态实行如下算法：</p>
<ul>
<li>寻找该状态的**$\epsilon$闭包<strong>，一个状态的$\epsilon$闭包指的是：</strong>从该状态出发仅仅通过$\epsilon$边能够到达的所有状态**。</li>
<li>将所有从这个闭包中输出的边的出发点全部<strong>复制</strong>到当前状态上。</li>
</ul>
</li>
</ol>
<p>我们以初始节点为例实施该算法，可以看到初始节点通过空边能够到达的状态包括状态1、2和6。实施算法后的图变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>st1((state1));<br>st2((state2));<br>st3((state3));<br>st4((state4));<br>st5((state5));<br>st6((state6));<br>st7((state7));<br>st8((state8));<br>st9((state9));<br>st10((state10));<br>st11((state11));<br>st12((state12));<br>en&#123;end&#125;;<br>st -- +- --&gt; st1;<br>st --null --&gt;st1;<br>st -- digit --&gt;st3;<br>st -- . --&gt; st6;<br>st1 -- null --&gt;st2;<br>st1 -- null --&gt;st6;<br>st2 -- digit --&gt;st3;<br>st3 -- digit --&gt;st3;<br>st3 -- . --&gt; st4;<br>st3 -- null --&gt;st5;<br>st4 -- digit --&gt; st5;<br>st4 -- null --&gt;st5;<br>st5 -- digit --&gt;st5;<br>st5 -- null --&gt;st9;<br>st5 -- digit --&gt;st5;<br>st6 -- . --&gt; st7;<br>st7 -- digit --&gt; st8;<br>st8 -- digit --&gt;st8;<br>st8 -- null --&gt;st9;<br>st9 -- eE --&gt;st10;<br>st9 -- null --&gt;en;<br>st10 -- +- --&gt;st11;<br>st10 -- null --&gt; st11;<br>st11 -- digit --&gt;st12;<br>st12 -- digit --&gt;st12;<br>st12 -- null --&gt; en;<br></code></pre></td></tr></table></figure>

<p>对所有的有效状态实施该算法后，最后我们需要<strong>删除所有无效状态和空边</strong>。算法应用的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR;<br>st((start));<br>st1((state1));<br>st3&#123;state3&#125;;<br>st4((state4));<br>st5&#123;state5&#125;;<br>st7((state7));<br>st8&#123;state8&#125;;<br>st10((state10));<br>st11((state11));<br>st12&#123;state12&#125;;<br>st -- digit --&gt; st3;<br>st -- +- --&gt; st1;<br>st -- . --&gt; st7;<br>st1 -- digit --&gt;st3;<br>st1 -- . --&gt;st7;<br>st3 -- digit --&gt; st3;<br>st3 -- . --&gt;st4;<br>st3 -- eE --&gt;st10;<br>st4 -- digit --&gt;st5;<br>st4 -- eE --&gt; st10;<br>st5 -- digit --&gt;st5;<br>st5 -- eE --&gt; st10;<br>st7 -- digit --&gt;st8;<br>st8 -- digit --&gt;st8;<br>st8 -- eE --&gt; st10;<br>st10 -- +- --&gt; st11;<br>st10 -- digit --&gt;st12;<br>st11 -- digit --&gt;st12;<br></code></pre></td></tr></table></figure>

<p>注意到我们将状态3、5、8和12标记为结束状态，而最终的结束状态作为无效状态清除。</p>
<p>这个算法实际上就是我们在之前的正则表达式匹配中应用的算法。可以看到我们得到的已然是一个$DFA$，不是所有时候都可以这么理想直接得到一个$DFA$的，我们仍然需要算法将$NFA$转换为$DFA$。图中的状态仍然不是最简的，比如状态5和状态8就是重复的。述的正则表达式的简化也可以通过先将复杂正则表达式的$\epsilon-NFA$写出后再进行重复状态合并来获得，重复状态指的是<strong>具有相同的入度字符集和出度字符集的状态</strong>。</p>
<h4 id="从-NFA-到-DFA"><a href="#从-NFA-到-DFA" class="headerlink" title="从$NFA$到$DFA$"></a>从$NFA$到$DFA$</h4><p>在下一节我们会详细讨论编译原理中的子集构造法,</p>
<h3 id="解决题目65："><a href="#解决题目65：" class="headerlink" title="解决题目65："></a>解决题目65：</h3><p>现在我们可以直接根据$DFA$写出状态机的代码，遍历循环简单实现可以通过if语句跳转实现，这里介绍一种实际中使用的表驱动方法，代码直接采用官方的题解。</p>
<p>首先列举我们的状态和字符集边：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    STATE_START,	 			<span class="hljs-comment">//初始状态</span><br>    STATE_INT_SIGN,	 			<span class="hljs-comment">//状态1</span><br>    STATE_INTEGER,	 			<span class="hljs-comment">//状态3</span><br>    STATE_POINT,	 			<span class="hljs-comment">//状态4</span><br>    STATE_POINT_WITHOUT_INT,	<span class="hljs-comment">//状态7</span><br>    STATE_FRACTION,				<span class="hljs-comment">//状态5和状态8，重复可以直接合并</span><br>    STATE_EXP,					<span class="hljs-comment">//状态10</span><br>    STATE_EXP_SIGN,				<span class="hljs-comment">//状态11</span><br>    STATE_EXP_NUMBER,			<span class="hljs-comment">//状态12</span><br>    STATE_END					<span class="hljs-comment">//结束状态</span><br>&#125;;<br> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CharType</span> &#123;<br>     CHAR_NUMBER,				<span class="hljs-comment">//digit</span><br>     CHAR_EXP,					<span class="hljs-comment">//eE</span><br>     CHAR_POINT,				<span class="hljs-comment">//.</span><br>     CHAR_SIGN,					<span class="hljs-comment">//+-</span><br>     CHAR_ILLEGAL				<span class="hljs-comment">//其他非法字符</span><br> &#125;;<br></code></pre></td></tr></table></figure>

<p>接下来我们打表，基本上表驱动的表都是用哈希表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//状态转移表</span><br>unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123;<br>    &#123;<br>        STATE_INITIAL, &#123;<span class="hljs-comment">//对应由初始状态出发的3条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_INTEGER&#125;,<br>            &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;,<br>            &#123;CHAR_SIGN, STATE_INT_SIGN&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_INT_SIGN, &#123;<span class="hljs-comment">//对应由状态1出发的2条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_INTEGER&#125;,<br>            &#123;CHAR_POINT, STATE_POINT_WITHOUT_INT&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_INTEGER, &#123;<span class="hljs-comment">//对应由状态3出发的3条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_INTEGER&#125;,<br>            &#123;CHAR_EXP, STATE_EXP&#125;,<br>            &#123;CHAR_POINT, STATE_POINT&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_POINT, &#123;<span class="hljs-comment">//对应由状态4出发的2条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_FRACTION&#125;,<br>            &#123;CHAR_EXP, STATE_EXP&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_POINT_WITHOUT_INT, &#123;<span class="hljs-comment">//对应由状态7出发的1条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_FRACTION&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_FRACTION,&#123;<span class="hljs-comment">//对应由状态5和8出发的2条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_FRACTION&#125;,<br>            &#123;CHAR_EXP, STATE_EXP&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_EXP,&#123;<span class="hljs-comment">//对应由状态10出发的2条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;,<br>            &#123;CHAR_SIGN, STATE_EXP_SIGN&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_EXP_SIGN, &#123;<span class="hljs-comment">//对应由状态11出发的1条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;<br>        &#125;<br>    &#125;, &#123;<br>        STATE_EXP_NUMBER, &#123;<span class="hljs-comment">//对应由状态12出发的1条边到达的状态</span><br>            &#123;CHAR_NUMBER, STATE_EXP_NUMBER&#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//终止状态集</span><br>unordered_set&lt;State&gt; endStates = &#123;<br>    STATE_INTEGER,<br>    STATE_POINT,<br>    STATE_FRACTION,<br>    STATE_EXP_NUMBER,<br>    STATE_END<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后实现核心功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        State st = STATE_INITIAL;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            CharType typ = <span class="hljs-built_in">toCharType</span>(s[i]);<br>            <span class="hljs-keyword">if</span> (!transfer[st].<span class="hljs-built_in">count</span>(typ)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st = transfer[st][typ];<br>            &#125;<br>        &#125;<br>		<span class="hljs-keyword">return</span> endStates.<span class="hljs-built_in">count</span>(st);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上我们通过三道题简单入门了一下正则表达式编译原理，涉及知识仅仅限于求解题目，限于篇幅和作者水平没有进一步讨论。下一篇文章将具体给出正则表达式到$\epsilon-NFA$到$NFA$到$DFA$再到消除多余状态$MDFA$的每一步算法原理。</p>

  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Kiman Yang<br>
        <strong>本文链接：</strong><a href="https://kimanyang.xyz/2022/01/21/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(1)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF/" title="https:&#x2F;&#x2F;kimanyang.xyz&#x2F;2022&#x2F;01&#x2F;21&#x2F;%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(1)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;kimanyang.xyz&#x2F;2022&#x2F;01&#x2F;21&#x2F;%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E(1)%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%80%9D%E8%B7%AF&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E7%94%B1%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%A7%8B%E6%9E%84%E9%80%A0%E6%AD%A3%E5%88%99%E5%BC%95%E6%93%8E/">由实例开始构造正则引擎</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/C/" rel="tag">C++</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Golang/" rel="tag">Golang</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" rel="tag">刷题总结</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1647310810018"></script>


	<script async src="/js/search.js?v=1647310810018"></script>


<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":240,"height":480},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
