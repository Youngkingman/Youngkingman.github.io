<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>lambda表达式、C++优先队列使用方式与多路归并总结 - Brief Candle</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="lambda表达式、C++优先队列使用方式与多路归并总结虽然多次写过优先队列，但是每次写都需要查询C++的具体写法，有些还涉及到一些没有听说过的C++11特性，因此在本文给出多道类似题型的总结并一次性把设计优先队列的几种写法总结下来。顺便在开头复习一下在优先队列中可以使用的lambda表达式的相关知识。 前置知识之C++11特性lambda表达式基本形式lambda表达式也可以叫闭包、匿名函数啥的">
<meta property="og:type" content="article">
<meta property="og:title" content="lambda表达式、C++优先队列使用方式与多路归并总结">
<meta property="og:url" content="https://kimanyang.xyz/2022/02/18/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E4%B8%8EC++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Brief Candle">
<meta property="og:description" content="lambda表达式、C++优先队列使用方式与多路归并总结虽然多次写过优先队列，但是每次写都需要查询C++的具体写法，有些还涉及到一些没有听说过的C++11特性，因此在本文给出多道类似题型的总结并一次性把设计优先队列的几种写法总结下来。顺便在开头复习一下在优先队列中可以使用的lambda表达式的相关知识。 前置知识之C++11特性lambda表达式基本形式lambda表达式也可以叫闭包、匿名函数啥的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-18T07:40:24.000Z">
<meta property="article:modified_time" content="2022-03-10T15:28:52.409Z">
<meta property="article:author" content="Kiman Yang">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="lambda表达式">
<meta property="article:tag" content="优先队列">
<meta property="article:tag" content="多路归并">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="/lib/jquery.fancybox.min.css?v=1652002228282">
    
    <link rel="stylesheet" href="/lib/mdui_043tiny/css/mdui.css?v=1652002228282">
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1652002228282">
    <link rel="stylesheet" href="/css/style.css?v=1652002228282">
    
        <link rel="stylesheet" href="/css/dark.css?v=1652002228282">
     
    
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(/images/yuanxiang.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Kiman Yang" class="mdui-btn mdui-btn-icon"><img src="/images/aqua.png" alt="Kiman Yang"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Kiman Yang">
            <img src="/images/aqua.png" alt="Kiman Yang" alt="Kiman Yang">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>35</div>
        <div><span>标签</span>74</div>
        <div><span>分类</span>6</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/Youngkingman" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/401742377" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/Youngkingman" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CSS/">CSS</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Golang学习/">Golang学习</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Javascript/">Javascript</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/控制理论/">控制理论</a>
          <span class="category-list-count">9</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a>
          <span class="category-list-count">9</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/由实例开始构造正则引擎/">由实例开始构造正则引擎</a>
          <span class="category-list-count">2</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 10px;">AC自动机</a> <a href="/tags/BitSet/" style="font-size: 10px;">BitSet</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/CSS-%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA/" style="font-size: 10px;">CSS 溢出显示</a> <a href="/tags/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 10px;">CSS3新特性</a> <a href="/tags/CSS%E4%B8%89%E8%A7%92%E4%B8%8E%E7%B2%BE%E7%81%B5%E5%9B%BE/" style="font-size: 10px;">CSS三角与精灵图</a> <a href="/tags/CSS%E5%B8%83%E5%B1%80/" style="font-size: 11.67px;">CSS布局</a> <a href="/tags/CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">CSS浮动与定位</a> <a href="/tags/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">CSS盒模型</a> <a href="/tags/CSS%E8%BF%87%E6%B8%A1/" style="font-size: 10px;">CSS过渡</a> <a href="/tags/CSS%E9%80%89%E6%8B%A9%E5%99%A8/" style="font-size: 10px;">CSS选择器</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/DOM%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">DOM事件</a> <a href="/tags/DOM%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">DOM模型</a> <a href="/tags/GMP%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">GMP模型</a> <a href="/tags/Golang/" style="font-size: 18.33px;">Golang</a> <a href="/tags/H5%E6%A0%87%E7%AD%BE/" style="font-size: 10px;">H5标签</a> <a href="/tags/HJB%E6%96%B9%E7%A8%8B/" style="font-size: 10px;">HJB方程</a> <a href="/tags/Javascript/" style="font-size: 11.67px;">Javascript</a> <a href="/tags/KMP/" style="font-size: 11.67px;">KMP</a> <a href="/tags/LFU/" style="font-size: 10px;">LFU</a> <a href="/tags/LQR%E7%AE%97%E6%B3%95/" style="font-size: 10px;">LQR算法</a> <a href="/tags/LRU/" style="font-size: 10px;">LRU</a> <a href="/tags/Rabin-Karp/" style="font-size: 10px;">Rabin-Karp</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/STL%E5%AE%B9%E5%99%A8/" style="font-size: 15px;">STL容器</a> <a href="/tags/ST%E8%A1%A8/" style="font-size: 10px;">ST表</a> <a href="/tags/Session/" style="font-size: 10px;">Session</a> <a href="/tags/Tcmalloc/" style="font-size: 10px;">Tcmalloc</a> <a href="/tags/Token/" style="font-size: 10px;">Token</a> <a href="/tags/Trie%E5%AD%97%E5%85%B8%E6%A0%91/" style="font-size: 10px;">Trie字典树</a> <a href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">lambda表达式</a> <a href="/tags/matlab/" style="font-size: 11.67px;">matlab</a> <a href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7/" style="font-size: 10px;">一致性</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E6%B5%81%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">事件流模型</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 10px;">二分法</a> <a href="/tags/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/" style="font-size: 10px;">二次规划</a> <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" style="font-size: 10px;">优先队列</a> <a href="/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">优化算法</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 13.33px;">八股文</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">内存模型</a> <a href="/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" style="font-size: 10px;">凸优化</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" style="font-size: 10px;">分布式卡尔曼滤波</a> <a href="/tags/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" style="font-size: 13.33px;">刷题总结</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/" style="font-size: 10px;">前端经典案例</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 11.67px;">动态规划</a> <a href="/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" style="font-size: 11.67px;">卡尔曼滤波</a> <a href="/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/" style="font-size: 10px;">哈希算法</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">堆排序</a> <a href="/tags/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/" style="font-size: 10px;">多智能体</a> <a href="/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/" style="font-size: 10px;">多路归并</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/" style="font-size: 10px;">扩展卡尔曼滤波</a> <a href="/tags/%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">控制系统设计</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 16.67px;">数据结构与算法</a> <a href="/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/" style="font-size: 10px;">机械臂</a> <a href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" style="font-size: 11.67px;">树状数组</a> <a href="/tags/%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">模型预测控制</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 16.67px;">正则表达式</a> <a href="/tags/%E7%8A%B6%E6%80%81%E6%9C%BADP/" style="font-size: 10px;">状态机DP</a> <a href="/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 10px;">矩阵快速幂</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 13.33px;">编译原理</a> <a href="/tags/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">自治系统</a> <a href="/tags/%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6/" style="font-size: 11.67px;">自适应控制</a> <a href="/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/" style="font-size: 10px;">路径压缩</a> <a href="/tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/" style="font-size: 10px;">身份认证</a> <a href="/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8E%A7%E5%88%B6/" style="font-size: 15px;">非线性控制</a> <a href="/tags/%E9%9D%9E%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">非自治系统</a> <a href="/tags/%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/" style="font-size: 10px;">页面事件</a>
    </div>
    
  </div>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2022 Kiman Yang
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: 70.84745762711864%;"> 
              <img data-src="/cover/yuanxiangcover7.jpg" data-sizes="auto" alt="lambda表达式、C++优先队列使用方式与多路归并总结" class="lazyload">
              <h1>lambda表达式、C++优先队列使用方式与多路归并总结</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2022年02月18日</a>
</div>

      

      <h1 id="lambda表达式、C-优先队列使用方式与多路归并总结"><a href="#lambda表达式、C-优先队列使用方式与多路归并总结" class="headerlink" title="lambda表达式、C++优先队列使用方式与多路归并总结"></a>lambda表达式、C++优先队列使用方式与多路归并总结</h1><p>虽然多次写过优先队列，但是每次写都需要查询C++的具体写法，有些还涉及到一些没有听说过的C++11特性，因此在本文给出多道类似题型的总结并一次性把设计优先队列的几种写法总结下来。顺便在开头复习一下在优先队列中可以使用的lambda表达式的相关知识。</p>
<h2 id="前置知识之C-11特性lambda表达式"><a href="#前置知识之C-11特性lambda表达式" class="headerlink" title="前置知识之C++11特性lambda表达式"></a>前置知识之C++11特性lambda表达式</h2><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p>lambda表达式也可以叫闭包、匿名函数啥的，基本的构造方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (params list) <span class="hljs-keyword">mutable</span> exception-&gt; <span class="hljs-keyword">return</span> type &#123; function body &#125;<br></code></pre></td></tr></table></figure>

<p>逐项解释下内部各项的实际意义：</p>
<ul>
<li>capture list :捕获列表，表示在lambda表达式中所能捕获的外部变量</li>
<li>params list: 形参列表</li>
<li>mutable：指示符，说明捕获的变量可否修改</li>
<li>exception：异常处理</li>
<li>return type: 返回类型</li>
<li>function body：函数体</li>
</ul>
<p>也有常见地几种省略形式：</p>
<ul>
<li>声明<code>const</code>类型地表达式，捕获列表的值不能被修改</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (params list) -&gt; <span class="hljs-keyword">return</span> type &#123;function body&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里省略了返回类型，但是编译器可以自己推导，面向auto编程就完事了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (params list) &#123;function body&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>无参函数，一般也可以叫做过程</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] &#123;function body&#125;<br></code></pre></td></tr></table></figure>

<p>一个使用的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> mylambda = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a &lt; b;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">mylambda</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;fuck you&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;fuck me&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="捕获外部变量的方式"><a href="#捕获外部变量的方式" class="headerlink" title="捕获外部变量的方式"></a>捕获外部变量的方式</h3><p>目前我们没有详细讲解捕获的外部变量是否可以被函数内部修改，同参数的传递有值传递和引用传递方式一样，lambda表达式捕获外部变量的方式也有值捕获和引用捕获，除此以外还有隐式捕获和混合捕获方式。</p>
<h4 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1.值捕获"></a>1.值捕获</h4><p>对于被值捕获的变量，lambda的内部函数体无法改变值，一个具体的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string fuck = <span class="hljs-string">&quot;fuck&quot;</span>;<br><span class="hljs-keyword">auto</span> f = [fuck]&#123;std::cout &lt;&lt; fuck &lt;&lt; endl;&#125;;<br>fuck = <span class="hljs-string">&quot;good&quot;</span>;<br><span class="hljs-built_in">f</span>();<span class="hljs-comment">//输出fuck</span><br></code></pre></td></tr></table></figure>

<p>可见值捕获会在闭包内部创建一个捕获对象的副本，从而使得后续的改变无法对闭包内部的值产生影响，调用闭包时输出的仍然是捕获时对象的值。这种做法会带来额外的性能开销。需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中<strong>不能修改该外部变量的值</strong>。如果要进行修改需要把函数改为mutable，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string fuck = <span class="hljs-string">&quot;fuck&quot;</span>;<br><span class="hljs-keyword">auto</span> f = [fuck]()<span class="hljs-keyword">mutable</span> &#123; fuck = <span class="hljs-string">&quot;good&quot;</span>;std::cout &lt;&lt; fuck; &#125;; <span class="hljs-comment">// 不会报错</span><br>std::cout &lt;&lt; fuck &lt;&lt; endl; <span class="hljs-comment">// 输出：fuck</span><br><span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：good</span><br></code></pre></td></tr></table></figure>



<h4 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2.引用捕获"></a>2.引用捕获</h4><p>对于引用捕获，要在函数的外部加上引用指示符&amp;，类似的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string fuck = <span class="hljs-string">&quot;fuck&quot;</span>;<br><span class="hljs-keyword">auto</span> f = [&amp;fuck]&#123;std::cout &lt;&lt; fuck &lt;&lt; endl;&#125;;<br>fuck = <span class="hljs-string">&quot;good&quot;</span>;<br><span class="hljs-built_in">f</span>();<span class="hljs-comment">//输出good</span><br></code></pre></td></tr></table></figure>

<p>此时闭包捕获外部对象的引用，无论是在闭包内对变量的修改抑或是在外部直接对变量进行修改都会是的变量的值发生改变。</p>
<h4 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3.隐式捕获"></a>3.隐式捕获</h4><p>大部分语言实际上都采用隐式捕获让编译器自行判断捕捉啥变量，C++支持两种隐式捕获，全值捕获和全引用捕获，分别用<code>[=]</code>和<code>[&amp;]</code>表示。给出示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">string fuck1 = <span class="hljs-string">&quot;fuck you&quot;</span>;<br>string fuck2 = <span class="hljs-string">&quot;fuck me&quot;</span>;<br><br><span class="hljs-keyword">auto</span> f1 = [=]&#123;std::cout&lt;&lt;fuck1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;fuck2&lt;&lt;endl;&#125;;<br><span class="hljs-keyword">auto</span> f2 = [&amp;]&#123;std::cout&lt;&lt;fuck1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;fuck2;&#125;;<br><br>fuck1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>fuck2 = <span class="hljs-string">&quot;world&quot;</span>;<br><br><span class="hljs-built_in">f1</span>();<span class="hljs-comment">//输出 fuck you fuck me</span><br><span class="hljs-built_in">f2</span>();<span class="hljs-comment">//输出 hello world</span><br>    <br></code></pre></td></tr></table></figure>

<h4 id="4-混合捕获"><a href="#4-混合捕获" class="headerlink" title="4.混合捕获"></a>4.混合捕获</h4><p>顾名思义就是既有值捕获也有引用捕获，具体来说有如下几种：</p>
<table>
<thead>
<tr>
<th>代码形式</th>
<th>捕获说明</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>要求闭包不捕获任何外部变量</td>
</tr>
<tr>
<td>[var1, var2 …]</td>
<td>捕获对应变量名变量</td>
</tr>
<tr>
<td>[this]</td>
<td>以值捕获形式获取this指针（能不能修改？应该不能）</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>自动值捕获</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>自动引用捕获</td>
</tr>
<tr>
<td>[&#x3D;,&amp;x]</td>
<td>对于x引用捕获，其他默认值捕获</td>
</tr>
<tr>
<td>[&amp;,&#x3D;x]</td>
<td>对于x值捕获，其他默认引用捕获</td>
</tr>
</tbody></table>
<h3 id="lambda表达式参数几点注意"><a href="#lambda表达式参数几点注意" class="headerlink" title="lambda表达式参数几点注意"></a>lambda表达式参数几点注意</h3><ul>
<li>参数列表和函数不同，不能有默认参数</li>
<li>不支持可变的参数，即**不是基本变量得加个<code>const</code>**在参数名之前</li>
<li>所有参数必须有参数名</li>
</ul>
<h3 id="嵌套使用的应用实例"><a href="#嵌套使用的应用实例" class="headerlink" title="嵌套使用的应用实例"></a>嵌套使用的应用实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//lambda表达式的嵌套</span><br><span class="hljs-type">int</span> m = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> [](<span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> y * <span class="hljs-number">2</span>; &#125;(x)+<span class="hljs-number">6</span>;&#125;(<span class="hljs-number">5</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;m:&quot;</span> &lt;&lt; m &lt;&lt; std::endl; <span class="hljs-comment">//输出m:16，即5*2 + 6</span><br><br><span class="hljs-comment">//lambda表达式使用lambda表达式作为传参和返回值（开始魔幻起来了，但对脚本语言属于常规操作）</span><br><span class="hljs-keyword">auto</span> gFunc = [](<span class="hljs-type">int</span> x) -&gt; function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>)&gt; &#123; <span class="hljs-keyword">return</span> [=](<span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;; &#125;;<br><span class="hljs-keyword">auto</span> lFunc = <span class="hljs-built_in">gFunc</span>(<span class="hljs-number">4</span>);<br>std::cout &lt;&lt; <span class="hljs-built_in">lFunc</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br><br><span class="hljs-keyword">auto</span> hFunc = [](<span class="hljs-type">const</span> function&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>)&gt;&amp; f, <span class="hljs-type">int</span> z) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(z) + <span class="hljs-number">1</span>; &#125;;<br><span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">hFunc</span>(<span class="hljs-built_in">gFunc</span>(<span class="hljs-number">7</span>), <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>



<h2 id="STL中优先队列的写法"><a href="#STL中优先队列的写法" class="headerlink" title="STL中优先队列的写法"></a>STL中优先队列的写法</h2><h3 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h3><p>先抛开STL的优先队列，让我们对最大堆最小堆的原理有一个清晰的认识，常规的最大堆写法一般使用一个数组容器实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; heap;<br><br><span class="hljs-comment">//获取最大值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">//插入值，新数字在最后，并进行上浮</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    heap.<span class="hljs-built_in">push_back</span>(k);<br>    <span class="hljs-built_in">swim</span>(heap.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">//删除最大值，把最后一个数字移到开头并进行下沉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    heap[<span class="hljs-number">0</span>] = heap.<span class="hljs-built_in">back</span>();<br>    heap.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-built_in">sink</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//核心操作，下沉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(pos &gt; <span class="hljs-number">1</span> &amp;&amp; heap[pos/<span class="hljs-number">2</span>] &lt; heap[pos]) &#123;<br>        <span class="hljs-built_in">swap</span>(heap[pos/<span class="hljs-number">2</span>], heap[pos]);<br>        pos /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//核心操作，上浮</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = heap.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span> * pos &lt;= N) &#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * pos;<br>        <span class="hljs-keyword">if</span>(i &lt; N &amp;&amp; heap[i] &lt; heap[i + <span class="hljs-number">1</span>]) ++i;<span class="hljs-comment">//选取叶子中小的那个</span><br>        <span class="hljs-keyword">if</span>(heap[pos] &gt;= heap[i]) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//已经沉到底了</span><br>        <span class="hljs-built_in">swap</span>(heap[pos],heap[i]);<br>        pos = i;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><ul>
<li><code>top </code>访问队头元素</li>
<li><code>empty</code> 队列是否为空</li>
<li><code>size</code> 返回队列内元素个数</li>
<li><code>push</code> 插入元素</li>
<li><code>emplace</code> 原地构造一个元素并插入队列</li>
<li><code>pop</code> 弹出队头元素（即消除<code>top</code>，使用<code>top()</code>再用<code>pop()</code>等同于Java的poll）</li>
<li><code>swap</code> 交换内容（很少用到）</li>
</ul>
<p>最基本的一种写法，只能适应基本的数据结构：</p>
<h3 id="简单写法"><a href="#简单写法" class="headerlink" title="简单写法"></a>简单写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//默认是大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; a; <br><br><span class="hljs-comment">//升序的小顶堆</span><br> priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br><br><span class="hljs-comment">//降序的大顶堆</span><br> priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br></code></pre></td></tr></table></figure>

<p><code>greater</code>和<code>less</code>作为仿函数重载了操作符<code>()</code>从而使得数据结构的比较特性得到实现。</p>
<h3 id="结构体自定义写法"><a href="#结构体自定义写法" class="headerlink" title="结构体自定义写法"></a>结构体自定义写法</h3><p>这里介绍两种，一种是结构体内的重载实现比较，一种是定义比较结构体</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mystruct</span> <span class="hljs-comment">//运算符重载&lt;</span><br>&#123;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p;<br>    <span class="hljs-comment">//构造函数列表初始化</span><br>    <span class="hljs-built_in">mystruct</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>        p.first = a;<br>        p.second = b;<br>    &#125;<br>    <span class="hljs-comment">//重载操作符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> mystruct&amp; a) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;p.first &lt; a.p.first; <span class="hljs-comment">//大顶堆</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>具体使用时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">mystruct <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">mystruct <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>priority_queue&lt;mystruct&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(a);<br>pq.<span class="hljs-built_in">push</span>(b);<br></code></pre></td></tr></table></figure>

<p>这种方法的数据结构比较受限，很多时候数据结构是别人给的未必能够直接跑到别人的类里面去重载操作符，所以用的还是比较少。</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>我在合并K个升序列表中使用的定义方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//重载仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(ListNode* a, ListNode* b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (a-&gt;val) &gt; (b-&gt;val);<br>    &#125;<br>&#125;;<br>priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp &gt; q;<br></code></pre></td></tr></table></figure>

<p>此处详细说明一下，比较函数是用于优先队列底层容器vector中元素的比较，小顶堆重载时用大于号，大顶堆重载时用小于号，q.top()是内部元素最小的链表指针。具体使用时对于这道题如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>    ListNode dummy = <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = &amp;dummy;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;&amp; node:lists) &#123;<br>        <span class="hljs-keyword">if</span>(node)&#123;<br>            q.<span class="hljs-built_in">push</span>(node);<br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ListNode* l1 = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cur-&gt;next = l1;<br>        cur = cur-&gt;next;<br>        l1 = l1-&gt;next;<br>        <span class="hljs-keyword">if</span>(l1)&#123;<br>            q.<span class="hljs-built_in">push</span>(l1);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h4><p>根据C++11中引入的特性，使用lambda表达式，和sort函数中的使用如出一辙，给出二者代码进行一下比较：</p>
<p><em>自定义排序</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; frac; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">...some operation...</span><br><span class="hljs-comment">**/</span><br><span class="hljs-built_in">sort</span>(frac.<span class="hljs-built_in">begin</span>(), frac.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; y) &#123;<br>    <span class="hljs-keyword">return</span> x.first * y.second &lt; x.second * y.first;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><em>自定义优先队列</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2作为捕获列表的参数，当然也可以不加区分地使用[&amp;]</span><br><span class="hljs-keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; a, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp; b) &#123;<br>    <span class="hljs-keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];<br>&#125;;<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp) &gt; <span class="hljs-built_in">pq</span>(cmp);<br></code></pre></td></tr></table></figure>

<p>这里需要简单解释的是<code>decltype(cmp)</code>这一写法。由于<code>cmp</code>是自动推导出来的lambda表达式，它的类型实际上应该是一个函数（仿函数），<code>decltype(expr)</code>的结果根据<code>expr</code>的结果不同而不同：<code>expr</code>返回左值，得到该类型的左值引用；<code>expr</code>返回右值，得到该类型。和方法二略有不同的一点还在于初始化时要传入参数<code>cmp</code>，因为lambda表达式这种特殊的类（不同于<code>struct</code>和<code>class</code>）没有默认自身的构造函数，所以需要通过传入已有的lambda对象示例进行拷贝构造，使得优先队列内部能够使用。</p>
<h2 id="多路归并样板题目"><a href="#多路归并样板题目" class="headerlink" title="多路归并样板题目"></a>多路归并样板题目</h2><p>上面的内容主要为了这部分做一点点铺垫，相关性不是很大，因为在多路归并算法中大量使用了优先队列，于是需要先总结一下优先队列的知识。</p>
<h3 id="经典题目：丑数-264"><a href="#经典题目：丑数-264" class="headerlink" title="经典题目：丑数(264)"></a>经典题目：丑数(264)</h3><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和&#x2F;或 <code>5</code> 的正整数。</p>
<h4 id="解法1优先队列"><a href="#解法1优先队列" class="headerlink" title="解法1优先队列"></a>解法1优先队列</h4><p>使用一个优先队列和哈希集合判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;LL&gt; inNum;<br>        vector&lt;<span class="hljs-type">int</span>&gt; tab = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>        priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; pq;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i) &#123;<br>            LL k = pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span> k;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num : tab) &#123;<br>                LL t = num * k;<br>                <span class="hljs-keyword">if</span>(!inNum.<span class="hljs-built_in">count</span>(t)) &#123;<br>                    pq.<span class="hljs-built_in">push</span>(t);<br>                    inNum.<span class="hljs-built_in">insert</span>(t);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="解法2动态规划"><a href="#解法2动态规划" class="headerlink" title="解法2动态规划"></a>解法2动态规划</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p2 = <span class="hljs-number">1</span>, p3 = <span class="hljs-number">1</span>, p5 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> num2 = dp[p2] * <span class="hljs-number">2</span>, num3 = dp[p3] * <span class="hljs-number">3</span>, num5 = dp[p5] * <span class="hljs-number">5</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(num2, num3), num5);<br>            <span class="hljs-keyword">if</span> (dp[i] == num2) &#123;<br>                p2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == num3) &#123;<br>                p3++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == num5) &#123;<br>                p5++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>扩展题313超级丑数，思路完全相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; primes)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> pcnt = primes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pointers</span><span class="hljs-params">(pcnt,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">mins</span><span class="hljs-params">(pcnt,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;++i) &#123;  <br>            ll curMin = INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; pcnt;++k) &#123;<br>                mins[k] = <span class="hljs-built_in">ll</span>(dp[pointers[k]]) * primes[k];<br>                curMin = <span class="hljs-built_in">min</span>(curMin, mins[k]);<br>            &#125;<br>            dp[i] = curMin;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; pcnt;++k) &#123;<br>                <span class="hljs-keyword">if</span>(mins[k] == curMin) &#123;<br>                    pointers[k]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Kiman Yang<br>
        <strong>本文链接：</strong><a href="https://kimanyang.xyz/2022/02/18/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E4%B8%8EC++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" title="https:&#x2F;&#x2F;kimanyang.xyz&#x2F;2022&#x2F;02&#x2F;18&#x2F;%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E4%B8%8EC++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;kimanyang.xyz&#x2F;2022&#x2F;02&#x2F;18&#x2F;%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E4%B8%8EC++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/C/" rel="tag">C++</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">lambda表达式</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/" rel="tag">优先队列</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6/" rel="tag">多路归并</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1652002228285"></script>


	<script async src="/js/search.js?v=1652002228285"></script>


<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":240,"height":480},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
